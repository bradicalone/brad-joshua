/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/******  GLOBAL VARIABLES  *******/\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar animate768 = \"M565.1,0v900H0c0,0,0-75.3,0-192.4c0-211.7,0-303.7,0-533.1C0,50.5,0,0,0,0H565.1z;\" + \"M565.1,0v900H182.7c0,0-44-72.5-44-191.7c0-107.5,121.8-396.1,121.8-533.8C260.5,41,245.9,0,245.9,0H565.1z;\" + \"M571.8,0v900H386.7c0,0-31.4-42.7-31.4-191.7C355.3,568,555,285,555,80.7C555,20,551.5,0,551.5,0H571.8z;\" + \"M573,0v900h-2.3c0,0,0.4-65.2,0.4-192.4c0-176.8-0.2-347.9-0.2-533.4c0-124-0.2-174.2-0.2-174.2H573z\";\n\nvar animate400 = \"M390,800H6c0,0-6-45.9-6-161.3C0,443.6,5,286.1,5,47.3C5,10.7,3,0,3,0h387V800z;\" + \"M390,800H96c0,0-46-45.9-46-161.3c0-195.1,130-352.6,130-591.3c0-36.7-3-47.3-3-47.3h213V800z;\" + \"M390,800H243c0,0-37-45.9-37-161.3c0-195.1,176-352.6,176-591.3c0-36.7-1-47.3-1-47.3h9V800z;\" + \"M390,800h-7c0,0,0-45.9,0-161.3c0-195.1,5-352.6,5-591.3c0-36.7-1-47.3-1-47.3h3V800z\";\n\nvar isFirefox = typeof InstallTrigger !== 'undefined';\nvar isSafari = navigator.userAgent.indexOf(\"Safari\") != -1 && navigator.userAgent.indexOf(\"Chrome\") === -1;\n//If user is on ipad / iphone / ipod\nvar isIOS = function isIOS() {\n    var userAgent = navigator.userAgent || navigator.vendor || window.opera;\n    return (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream\n    );\n};\n\nvar wW = window.innerWidth;\nvar wH = window.innerHeight;\nvar lastDist = void 0;\n\n//Firefox Bug, transforms not working, so sets attribute to 0 instead\nif (isFirefox) {\n    //svg morfing problem\n    document.getElementsByTagName('feGaussianBlur')[0].setAttribute('stdDeviation', '6');\n    //svg css problem\n    _('svg-circle').setAttribute('r', 0);\n    _('svg-circle').style.transform = 'scale(1)';\n}\n\nif (isSafari) _('svg-page').style.visibility = \"hidden\";\n\nfunction _(clss) {\n\n    var classes = document.getElementsByClassName(clss);\n\n    if (classes.length === 1) {\n        return classes[0];\n    }\n    if (classes.length > 1) {\n        return classes;\n    } else return \"Not a working class\";\n};\n\nvar easeOut = function easeOut(progress) {\n    return Math.pow(--progress, 5) + 1;\n};\n\n//String: indicates new size of width or height that you want. Size: of the new size of the string. El: the element you want it for\nvar newSize = function newSize(string, size, el) {\n    if (typeof el !== 'undefined') {\n\n        var ogWidth = el.getBoundingClientRect().width;\n        var ogHeight = el.getBoundingClientRect().height;\n        if (ogWidth === 0 || ogHeight === 0) {\n            ogWidth = el.getAttribute('width');\n            ogHeight = el.getAttribute('height');\n        }\n    } else {\n        var ogWidth = 762.22;\n        var ogHeight = 668.97;\n    }\n\n    if (string === 'height') {\n        var ratio = ogHeight / size;\n        return {\n            height: size,\n            width: ogWidth / ratio\n        };\n    } else if (string === 'width') {\n        var _ratio = ogWidth / size;\n        return {\n            width: size,\n            height: ogHeight / _ratio\n        };\n    } else console.log('check parameters');\n};\n\nWebFont.load({\n    google: {\n        families: ['Do Hyeon', 'Orbitron']\n    },\n    active: function active() {\n        //Starts when google fonts are loaded     \n        slotMachine();\n        Stretch();\n    }\n});\n\nfunction slotMachine() {\n\n    var canvas = document.getElementById('slot-machine');\n    var ctx = canvas.getContext('2d');\n\n    var Slot = function Slot() {\n        this.x = 0;\n        this.width = canvas.width = wW < 970 ? 360 : 475;\n        this.height = canvas.height = wW < 970 ? 360 : 475;\n        this.text = 'PHOTO';\n        this.letters = [];\n\n        this.addLetter = function (n) {\n\n            var letterHeight = wW < 970 ? -124 : -158;\n\n            //Places letters at top index 1,3,5\n            var bottom = wW < 970 ? this.height + 60 : this.height + 96;\n            for (var j = 0; j < n; j++) {\n                //Resets x every iteration\n                this.x = 0;\n                //Adjust bottom and height all letters\n                letterHeight = wW < 970 ? letterHeight + 121 : letterHeight + 158;\n                for (var i = 0; i < this.text.length; i++) {\n\n                    var data = {\n                        top: letterHeight,\n                        letter: this.text[i],\n                        x: i === 0 ? -5 : wW < 970 ? this.x += 74 : this.x += 100.8,\n                        speed: 9,\n                        bottom: bottom - letterHeight,\n                        start: i % 2 === 0 ? \"up\" : \"down\"\n                    };\n                    n === 4 ? this.letters.push(data) : this.letters.unshift(data);\n\n                    var letter = data;\n\n                    if (i % 2 === 0) {\n                        this.drawUp(letter);\n                    } else {\n\n                        if (wW < 970) {\n                            //fixes spacing issue Orbitron font\n                            i === 3 ? letter.x += 3 : true;\n                            i === 1 ? letter.x -= 3 : true;\n                        }\n                        this.drawDown(letter);\n                    }\n                }\n            }\n        };\n        this.addLetter(4);\n    };\n\n    Slot.prototype.drawUp = function (text) {\n\n        ctx.font = wW < 970 ? \"Bold 62pt Orbitron\" : \"105pt Do Hyeon\";\n        ctx.fillText(text.letter, text.x, text.bottom);\n    };\n    Slot.prototype.drawDown = function (text) {\n\n        ctx.fillStyle = \"#0D1B56\";\n        ctx.font = wW < 970 ? \"Bold 62pt Orbitron\" : \"105pt Do Hyeon\";\n        ctx.fillText(text.letter, text.x, text.top);\n    };\n\n    Slot.prototype.update = function () {\n\n        // var push = wW < 970 ? -61 : -74\n        var push = wW < 970 ? -61 : -75;\n        if (!slotMachine.prototype.toggle) return;\n\n        //New set if letters drawn based on spacing\n        if (this.letters[19].bottom <= push) {\n\n            this.letters.splice(15, 5);\n            this.addLetter(1);\n        }\n\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        for (var i = 0; i < this.letters.length; i++) {\n\n            var letter = this.letters[i];\n\n            letter.top += letter.speed;\n            letter.bottom -= letter.speed;\n\n            if (letter.start === \"up\") {\n\n                this.drawUp(letter);\n            } else this.drawDown(letter);\n        }\n        requestAnimationFrame(this.update.bind(this));\n    };\n    var slot = new Slot();\n\n    document.querySelector('.photo .start-canvas').addEventListener('click', function () {\n\n        //Start Canvas\n        slotMachine.prototype.toggle = true;\n        requestAnimationFrame(slot.update.bind(slot));\n    });\n\n    document.querySelector('.photo .stop-canvas').addEventListener('click', function () {\n        //Stop Canvas\n        slotMachine.prototype.toggle = false;\n    });\n}\n\nfunction Stretch() {\n\n    var canvas = document.getElementById('stretch');\n    var ctx = canvas.getContext('2d');\n\n    if (wW < 970) {\n        var width = 400;\n        var height = 375;\n        var strtch = 15;\n        var letterDist = 53;\n        var x = 65;\n        var stretchX = 5;\n        var mixedNum = 5;\n    }\n    if (wW < 400) {\n        var width = 360;\n        var height = 375;\n        var x = 50;\n        var mixedNum = -10;\n    }\n    if (wW > 970) {\n        var width = 650;\n        var height = 450;\n        var strtch = 30;\n        var letterDist = 65;\n        var x = 125;\n        var mixedNum = 5;\n    }\n    /** CHANGE NUMBER FOR lineCount TO ADD OR SUBTRACT HOW MANY LINES OF WORDS **/\n    var lineCount = 7;\n    var count = 0;\n    var t = lineCount - 1;\n    var colors = [\"#DAF7A6\", \"#FFC300 \", \"#FF5733\", \"#C70039\", \"#900C3F\", \"#581845\", \"#37102b\"];\n    var Letters = function Letters() {\n        // this.text = 'SOLUTIONS'\n        this.letters = [];\n        this.total = this.letters.length - 1;\n        this.total = 0;\n        this.y = 0;\n\n        this.width = canvas.width = width;\n        this.height = canvas.height = height;\n        this.text = 'DEVELOPER';\n\n        this.pushLetters = function (x, dist) {\n            //If pushLetters is ran again makes sure this.y = 0\n            if (this.y) this.y = 0;\n            var canvasHeight = this.height;\n            for (var i = 0; i < lineCount; i++) {\n                var data = {\n                    x: x,\n                    letter: this.text,\n                    stretch: strtch,\n                    start: 0,\n                    speed: i,\n                    dist: typeof dist === 'number' ? dist : 0,\n                    //Letters distance between each other virticle \n                    distance: this.y += letterDist,\n                    //Letters start on the bottom\n                    bottom: wW < 970 ? canvasHeight + 45 : canvasHeight + 62,\n                    begin: 1,\n                    //When the next rotation starts\n                    beginY: 0,\n                    scaleTotal: 4,\n                    distY: 0,\n                    color: colors[i]\n                };\n                this.letters.push(data);\n            }\n        };\n        this.pushLetters(x);\n    };\n\n    var drawUp = function drawUp(letter, dist) {\n\n        ctx.setTransform(1, 0, 0, letter.scale, letter.x, letter.bottom - dist);\n        ctx.font = wW < 970 ? \"40pt Do Hyeon\" : \"60pt Do Hyeon\";\n        ctx.fillStyle = letter.color;\n        ctx.fillText(letter.letter, 0, letter.textY);\n        // var text = ctx.measureText(letter.letter)\n    };\n    var stretch = function stretch(text) {\n        ctx.canvas.style.letterSpacing = text.dist + 'px';\n        ctx.font = wW < 970 ? \"40pt Do Hyeon\" : \"60pt Do Hyeon\";\n        ctx.fillStyle = text.color;\n        ctx.fillText(text.letter, text.x, text.bottom - text.distance);\n    };\n\n    var drawDown = function drawDown(letter) {\n        ctx.font = wW < 970 ? \"40pt Do Hyeon\" : \"60pt Do Hyeon\";\n        ctx.fillStyle = letter.color;\n        ctx.fillText(letter.letter, letter.x, letter.y);\n    };\n\n    var drawBackFlip = function drawBackFlip(letter) {\n        ctx.font = wW < 970 ? \"40pt Do Hyeon\" : \"60pt Do Hyeon\";\n        ctx.fillStyle = letter.color;\n        ctx.setTransform(1, 0, 0, letter.scale, letter.x, letter.y);\n        ctx.fillText(letter.letter, 0, letter.textY);\n    };\n\n    Letters.prototype.addLetters = function (timestamp) {\n\n        if (!Stretch.prototype.toggle) return;\n        var j = 0;\n\n        ctx.globalCompositeOperation = 'destination-under';\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        for (var i = 0; i < this.letters.length; i++) {\n\n            var letter = this.letters[i];\n            letter.y = letter.bottom - letter.distance;\n\n            //FOURTH AND LAST CALL, REMOVE WORDS\n            if (count === 3 && i === t) {\n\n                if (!letter.start) letter.start = timestamp;\n                var runtime = timestamp - letter.start;\n                var progress = Math.min(runtime / 600, 1);\n                letter.y += letter.distance * progress;\n\n                letter.scale = 0 || (letter.begin - letter.scaleTotal * progress).toFixed(2);\n                letter.textY = (letter.beginY + letter.distY * progress).toFixed(2);\n                drawBackFlip(letter);\n\n                if (letter.scale == -1 || letter.scale < -1) {\n\n                    letter.beginY = 10;\n                    letter.distY = wW < 970 ? -5 : -10;\n                    letter.scaleTotal = -4;\n                    letter.begin = -3;\n                }\n\n                if (progress === 1) {\n                    //Removes item from array after each word is finished animating\n                    this.letters.splice(t, 1);\n                    t--;\n                }\n                if (t === -1) {\n                    setTimeout(function () {\n                        this.total = 0;\n                        count = 0;\n                        t = lineCount - 1;\n                        this.letters.length = 0;\n                        this.pushLetters(x);\n                    }.bind(this), 200);\n                }\n            }\n            if (count === 3 && i !== t) drawDown(letter);\n\n            //THIRD, LETTER STRETCH IN\n            if (count === 2 && i === t) {\n                if (!letter.start) letter.start = timestamp;\n                var runtime = timestamp - letter.start;\n                var progress = Math.min(runtime / 125, 1);\n                letter.dist = letter.stretch - letter.stretch * progress;\n\n                letter.x = mixedNum + letter.stretch * progress * 4;\n\n                stretch(letter);\n\n                if (progress === 1) {\n                    t--;\n                }\n                //RESETS VARIABLES, CALLS FUNCTION ALL OVER AGAIN\n                if (t === -1) {\n                    setTimeout(function () {\n                        count++;\n                        t = lineCount - 1;\n                        this.letters.length = 0;\n                        this.pushLetters(x, 0);\n                    }.bind(this), 200);\n                }\n            }\n            if (count === 2 && i !== t) {\n\n                stretch(letter);\n            }\n\n            //SECOND, LETTER STRETCH OUT\n            if (count === 1 && i === j) {\n\n                if (!letter.start) letter.start = timestamp;\n                var runtime = timestamp - letter.start;\n                var progress = Math.min(runtime / 150, 1);\n\n                letter.dist = letter.stretch * progress;\n                letter.x = x - letter.dist * 4;\n\n                stretch(letter);\n\n                if (progress === 1) {\n                    j++;\n                }\n\n                if (j === this.letters.length) {\n                    count++;\n                    this.letters.length = 0;\n                    // -5 because letters stretched to far, need to fix numbers\n                    // wW < 970 ? this.pushLetters(5, 15) : this.pushLetters(5, 30);\n                    this.pushLetters(mixedNum, wW < 970 ? 15 : 30);\n                }\n            }\n            if (count == 1 && i !== j) {\n                letter.x = letter.x;\n                letter.dist = letter.dist;\n                stretch(letter);\n            }\n\n            //FIRST, LETTER CLIMBE\n            if (i === j && count === 0) {\n\n                if (!letter.start) letter.start = timestamp;\n                var runtime = timestamp - letter.start;\n                var progress = Math.min(runtime / 600, 1);\n                var dist = letter.distance * progress;\n\n                letter.scale = 0 || (letter.begin - letter.scaleTotal * progress).toFixed(2);\n                letter.textY = (letter.beginY + letter.distY * progress).toFixed(2);\n\n                drawUp(letter, dist);\n\n                //Adds second flip to make upright text half way up canvas\n                if (letter.scale == -1 || letter.scale < -1) {\n                    //When the next rotation starts for beginY and distY\n                    letter.beginY = wW < 970 ? 5 : 10;\n                    letter.distY = wW < 970 ? -5 : -10;\n                    letter.scaleTotal = -4;\n                    letter.begin = -3;\n                }\n\n                if (progress === 1) {\n                    j++;\n                }\n\n                if (j === this.letters.length) {\n                    count++;\n                    this.letters.length = 0;\n                    this.pushLetters(x, 0);\n                }\n            }\n        }\n        requestAnimationFrame(this.addLetters.bind(this));\n    };\n    var letters = new Letters();\n\n    document.querySelector('.developer .start-canvas').addEventListener('click', function (e) {\n\n        Stretch.prototype.toggle = true;\n        requestAnimationFrame(letters.addLetters.bind(letters));\n    });\n\n    document.querySelector('.developer .stop-canvas').addEventListener('click', function () {\n\n        Stretch.prototype.toggle = false;\n    });\n};\n\nfunction ImageShatter() {\n    var sizing = function sizing(content) {\n        if (content === 'dur') {\n            if (window.innerWidth < 600) return 2.6;else if (window.innerWidth > 600) return 3.5;\n        }\n        if (content === 'img') {\n            if (window.innerWidth <= 600) return 400;else if (window.innerWidth > 1200) return 580;else return 500;\n        }\n    };\n\n    var ns = 'http://www.w3.org/2000/svg';\n    var img = new Image();\n    var ctx, canvas;\n    var particleCanvas, particleCtx;\n    var canvasParentWidth;\n    var canvasParentHeight;\n    var ending = [];\n    var retractStart = 0;\n    var imgCanvas = function imgCanvas(width, height, img, callback) {\n        //Watch where this is loaded into when portfolio done\n        // document.body.innerHTML += '<canvas id=\"img-canvas\"></canvas>';\n        // canvas = document.getElementById('img-canvas')\n        canvas = document.getElementById('particle');\n        ctx = canvas.getContext(\"2d\");\n\n        canvas.width = width;\n        canvas.height = height;\n        canvasParentWidth = _('svg-page').getBoundingClientRect().width;\n        canvasParentHeight = _('svg-page').getBoundingClientRect().height;\n\n        ctx.drawImage(img, 0, 0, width, height);\n\n        //Calls function for clickable event listener to run and appends background canvas\n        callback(canvas, createParticleCanvas());\n    };\n\n    function createParticleCanvas() {\n\n        // Create our canvas\n        particleCanvas = document.createElement(\"canvas\");\n        particleCtx = particleCanvas.getContext(\"2d\");\n\n        // Size our canvas with additional sizing\n        particleCanvas.width = canvasParentWidth;\n        particleCanvas.height = canvasParentHeight;\n\n        // Position out canvas\n        particleCanvas.style.position = \"absolute\";\n        particleCanvas.style.top = \"0\";\n        particleCanvas.style.left = \"0\";\n\n        // Make sure it's on top of other elements\n        particleCanvas.style.zIndex = \"500\";\n\n        // Make sure other elements under it are clickable\n        particleCanvas.style.pointerEvents = \"none\";\n        var foreignObject = document.createElementNS(ns, \"foreignObject\");\n        foreignObject.setAttribute('class', \"particleObject\");\n        foreignObject.setAttribute('width', canvasParentWidth);\n        foreignObject.setAttribute('height', canvasParentHeight);\n        foreignObject.appendChild(particleCanvas);\n\n        document.querySelector('g.design').appendChild(foreignObject);\n    }\n\n    //Image comes appart\n    var ExplodingParticle = function ExplodingParticle() {\n        var _this2 = this;\n\n        this.begin = 0;\n\n        // Set how long we want our particle to animate for\n        this.animationDuration = 1000; // in ms\n\n        // Set the speed / distance for our particle\n        this.speed = {\n            x: window.innerWidth < 768 ? -5 + Math.random() * 10 : -10 + Math.random() * 20,\n            y: window.innerWidth < 768 ? -5 + Math.random() * 10 : -10 + Math.random() * 20\n        };\n\n        // Size our particle\n        window.innerWidth < 768 ? this.radius = 3 + Math.random() * 3 : this.radius = 4 + Math.random() * 4;\n\n        // Set a max time to live for our particle\n        this.life = 30 + Math.random() * 10;\n        this.remainingLife = this.life;\n\n        // This function will be called by our animation logic later on\n        this.draw = function (ctx) {\n\n            var p = _this2;\n\n            if (_this2.remainingLife > 0 && _this2.radius > 0) {\n\n                // Draw a circle at the current location\n                ctx.beginPath();\n                ctx.arc(p.startX, p.startY, p.radius, 0, Math.PI * 2);\n                ctx.fillStyle = \"rgba(\" + _this2.rgbArray[0] + ',' + _this2.rgbArray[1] + ',' + _this2.rgbArray[2] + \", 1)\";\n                ctx.fill();\n\n                // Update the particle's location and life\n                p.remainingLife--;\n                p.radius -= 0.25;\n                p.startX += p.speed.x;\n                p.startY += p.speed.y;\n            }\n        };\n        this.retract = function (begin, finale, timestamp) {\n\n            if (!retractStart) retractStart = timestamp;\n\n            var runtime = timestamp - retractStart;\n            var progress = Math.min(runtime / 3000, 1);\n\n            // canvas.style.opacity = 1 - progress\n            particleCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n\n            for (var i = 0; i < begin.length; i++) {\n                var start = begin[i];\n                var end = finale[i];\n\n                var distX = Math.abs(start.startX - end.x);\n                var distY = Math.abs(start.startY - end.y);\n\n                //If end x or y is greater than x or y subtract else add\n                start.x = start.startX > end.x ? start.startX - distX * progress : start.startX + distX * progress;\n                start.y = start.startY > end.y ? start.startY - distY * progress : start.startY + distY * progress;\n                start.rad = start.begin + end.rad * progress;\n\n                particleCtx.beginPath();\n\n                particleCtx.arc(start.x, start.y, start.rad, 0, Math.PI * 2);\n                particleCtx.fillStyle = \"rgba(\" + start.rgbArray[0] + ',' + start.rgbArray[1] + ',' + start.rgbArray[2] + ',' + start.rgbArray[3] + \")\";\n\n                particleCtx.fill();\n            }\n            if (progress === 1) {\n                //returns the photo back if ran again\n                return;\n            }\n\n            requestAnimationFrame(function (timestamp) {\n                this.retract(begin, finale, timestamp);\n            }.bind(_this2));\n        };\n    };\n\n    var particles = [];\n\n    function createParticleAtPoint(x, y, colorData) {\n        var particle = new ExplodingParticle();\n\n        particle.rgbArray = colorData;\n        particle.startX = x;\n        particle.startY = y;\n        particle.startTime = Date.now();\n\n        particles.push(particle);\n        var end = {};\n        end.start = 0;\n        end.rad = particle.radius;\n        end.x = x;\n        end.y = y;\n        ending.push(end);\n    }\n\n    var opac = 1;\n    function update() {\n        if (typeof particleCtx !== \"undefined\") {\n            particleCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n        }\n        //image fades as it's breaking apart\n        canvas.style.opacity = opac = opac - .08;\n\n        // Draw all of our particles in their new location\n        for (var i = 0; i < particles.length; i++) {\n\n            particles[i].draw(particleCtx);\n\n            // When particles \n            if (particles[i].radius < 0) {\n                var percent = (Date.now() - particles[i].startTime) / particles[i].animationDuration;\n                var dur = sizing('dur');\n\n                if (percent > dur) {\n\n                    var particle = new ExplodingParticle();\n\n                    particle.retract(particles, ending);\n\n                    return;\n                }\n            }\n        }\n        window.requestAnimationFrame(update);\n    }\n\n    var clearData = function clearData() {\n        retractStart = null;\n        canvas.removeAttribute('style');\n        particleCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n        ending = [];\n        particles = [];\n    };\n\n    img.onload = function () {\n        var width = sizing('img');\n        var height = width;\n        imgCanvas(width, height, this, runEvents);\n    };\n    img.src = 'images/design-img.png';\n\n    function runEvents(imgCanvas) {\n        var foreignObject = document.querySelector('.design .item-canvas');\n\n        var imageLeft = parseInt(foreignObject.getAttribute('x'));\n        var imageTop = parseInt(foreignObject.getAttribute('y'));\n        // let reductionFactor = window.width <= 400 ? 15 : Math.round(imgCanvas.width / 15)\n        if (window.innerWidth < 600) var reductionFactor = 15;\n        if (window.innerWidth >= 600) var reductionFactor = 22;\n        if (window.innerWidth >= 1200) var reductionFactor = 33;\n\n        //Removes canvas with particles made from when closing svg page\n        _('close-btn').addEventListener('click', clearData);\n\n        imgCanvas.addEventListener('click', function (e) {\n            if (e.target.style.opacity) {\n\n                return clearData();\n            }\n\n            //width first one pixel, then all of height pixels, width another pixel then all of height pixels \n            var rgbaData = ctx.getImageData(0, 0, this.width, this.height).data;\n            var count = 0;\n            for (var x = 0; x < this.width; x++) {\n                for (var y = 0; y < this.height; y++) {\n\n                    if (count % reductionFactor === 0) {\n\n                        var index = (y * this.width + x) * 4;\n                        var rgbaColorArr = rgbaData.slice(index, index + 4);\n\n                        var globalX = imageLeft + x;\n                        var globalY = imageTop + y;\n\n                        createParticleAtPoint(globalX, globalY, rgbaColorArr);\n                    }\n                    count++;\n                }\n            }\n            update();\n        });\n    }\n}\nImageShatter();\n\nfunction StarryNight() {\n\n    var canvas = document.getElementById('starryNight');\n    var ctx = canvas.getContext('2d');\n    var data = [];\n    var trailData = [];\n    var rgb = trailData.length > 1 && 150 / trailData.length;\n    var j = 0;\n    var houseWidth = window.innerWidth < 768 ? 380 : 600;\n    var houseHeight = newSize('width', houseWidth).height;\n    this.width = canvas.width = _('svg-page').getAttribute('width');\n    this.height = canvas.height = _('svg-page').getAttribute('height');\n    this.toggle = true;\n\n    this.images = [];\n\n    //Men Data\n    var menData = {\n        headArc: window.innerWidth < 768 ? 4 : 6,\n        stepDown: window.innerWidth < 768 ? 12 : 17,\n        rotatedPos: 0,\n        rotateDegree: 14,\n        j: 0, //Each point of animation, walk, stand still, rotate ,falling\n        start: 0,\n        begin: 0,\n        lastPosX: 90,\n        lastPosY: undefined,\n        arcStartX: window.innerWidth < 768 ? 7 : 10,\n        arcStartY: 5\n\n        //House animation Data\n    };this.house = {\n        houseImg: undefined,\n        toggle: undefined,\n        currentY: undefined,\n        start: 0,\n        right: this.width - houseWidth,\n        bottom: this.height - houseHeight,\n        startY: function startY() {\n            return this.bottom + houseWidth / 2.4;\n        },\n        startX: function startX() {\n            return this.right;\n        },\n        begin: function begin() {\n            menData.lastPosY = houseHeight / 2.24 - starryNight.images[0].height;\n            ctx.drawImage(this.houseImg, this.startX(), this.startY(), houseWidth, houseHeight);\n        },\n        rise: this.height / 2,\n        moveLeft: window.innerWidth < 500 ? this.width / 20 : this.width / 8\n\n        //Star Trail Data\n    };var lastPosition = function lastPosition(xPos, yPos, radius, alpha) {\n        trailData.push({\n            x: xPos,\n            y: yPos,\n            radius: radius,\n            alpha: alpha\n        });\n        if (trailData.length > 25) trailData.shift();\n    };\n\n    this.randomMax = function (min, max) {\n        return Math.floor(Math.random() * (max - min) + min);\n    };\n\n    //Adds data for Shooting star\n    this.addData = function () {\n        for (var i = 0; i < 8; i++) {\n            var measurements = {\n                // Starts randomly on the x axis\n                delay: i === 0 ? 0 : this.randomMax(1, 2),\n                x: this.randomMax(0, this.width / 2),\n                y: this.randomMax(200, this.height),\n                radius: window.innerWidth < 768 ? this.randomMax(5, 13) : this.randomMax(8, 16),\n                distance: this.width + 100,\n                globAlpha: 1,\n                opac: 1,\n                endPos: this.randomMax(100, this.width),\n                start: 0,\n                time: 0,\n                explodeStart: 0,\n                explodeSize: window.innerWidth < 768 ? 20 : 35\n            };\n            data.push(measurements);\n        }\n    }.bind(this);\n\n    //When prototype.toggle = false this automatically gets ran to be able to run animation again\n    this.restoreData = function () {\n        data = [];\n        trailData = [];\n        j = 0;\n        this.addData();\n        menData.begin = null;\n    };\n\n    function drawHouse(image, timestamp) {\n        if (!image.start) image.start = timestamp;\n        var runtime = timestamp - image.start;\n        var progress = runtime / 2000;\n\n        var distance = image.rise * progress;\n\n        //Floating in place\n        if (image.currentY) {\n\n            image.toggle ? image.x = image.currentX - distance : image.x = image.currentX + distance;\n            image.toggle ? image.y = image.currentY + distance : image.y = image.currentY - distance;\n        }\n\n        if (distance >= image.rise) {\n            //Makes currentY true and updates postion of the image\n            image.currentY = image.y;\n            image.currentX = image.x;\n            image.toggle ? image.toggle = false : image.toggle = true;\n            image.start = 0;\n            image.rise = 50;\n        }\n        //Ends the first rise of the image\n        if (!image.currentY) {\n            image.x = image.startX() - image.moveLeft * progress;\n            image.y = image.startY() - image.rise * progress;\n        }\n\n        ctx.drawImage(image.houseImg, image.x, image.y, houseWidth, houseHeight);\n    }\n\n    function drawStars(cir) {\n        ctx.save();\n        ctx.globalAlpha = cir.alpha;\n\n        ctx.beginPath();\n        ctx.arc(cir.xPos, cir.yPos, cir.radius, 0, 2 * Math.PI);\n        ctx.fillStyle = 'rgba(255, 255, 73, ' + cir.opacity + ')';\n        ctx.fill();\n        ctx.restore();\n        lastPosition(cir.xPos, cir.yPos, cir.radius, cir.alpha);\n    }\n\n    function drawTrail(trail) {\n        ctx.save();\n        ctx.globalAlpha = 0.2;\n        ctx.beginPath();\n        ctx.arc(trail.x, trail.y, trail.rad, 0, 2 * Math.PI, true);\n        ctx.fillStyle = 'rgba(238,' + trail.color + ', 6, ' + trail.fade + ')';\n        ctx.fill();\n        ctx.restore();\n    }\n    function drawExplosion(circle, timestamp) {\n\n        if (!circle.explodeStart) circle.explodeStart = timestamp;\n        var runtime = timestamp - circle.explodeStart;\n        var progress = runtime / 400;\n        var ease = easeOut(progress);\n        ctx.beginPath();\n        ctx.arc(circle.xPos, circle.yPos, 0 + circle.explodeSize * ease, 0, 2 * Math.PI, true);\n        ctx.fillStyle = 'rgba(249, 255, 0, ' + (1 - .9 * progress) + ')';\n        ctx.fill();\n    }\n    function drawMen(men) {\n\n        if (menData.j >= 4 && menData.j <= 5) {\n            ctx.translate(men.translateX, men.translateY);\n            ctx.rotate(men.rotate * Math.PI / 180);\n            ctx.drawImage(men.img, -men.width / 2, -men.height, men.width, men.height);\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\n        } else {\n            ctx.save();\n            ctx.globalAlpha = men.opac;\n            ctx.beginPath();\n            ctx.arc(men.arcX, men.arcY, men.arcRadius, 0, 2 * Math.PI);\n            ctx.fillStyle = \"#000\";\n            ctx.fill();\n            ctx.drawImage(men.img, men.x, men.y, men.width, men.height);\n            ctx.restore();\n        }\n    }\n\n    var draw = function (timestamp) {\n        if (!StarryNight.prototype.toggle) {\n            return this.restoreData();\n        }\n\n        //House\n        var image = this.house;\n\n        ctx.clearRect(0, 0, this.width, this.height);\n\n        //Men running start , Stars start after house gets to top. \n        if (image.currentY) {\n\n            //**  START OF STARS  **/\n\n            // Draws the trail opacity  \n            if (menData.j >= 1) {\n                for (var i = 0; i < trailData.length; i++) {\n                    var trail = trailData[i];\n                    var fadeSize = i / trailData.length;\n\n                    //Trail tapers as it goes.\n                    var radiusTaper = (trail.radius - 2) / trailData.length;\n                    trail.color = 240 - (i + j);\n                    trail.fade = i / trailData.length;\n\n                    //Tapers down the raidus of the trail\n                    trail.rad = trail.radius = trail.radius - radiusTaper;\n                    // trail.rad = trail.radius\n                    drawTrail(trail);\n                }\n\n                //Draws stars\n                for (var _i = 0; _i < data.length; _i++) {\n                    var circle = data[_i];\n\n                    if (j >= _i) {\n\n                        if (!circle.start) circle.start = timestamp;\n                        var _runtime = timestamp - circle.start;\n                        var _progress = _runtime / 2000;\n                        var ease = easeOut(_progress);\n                        circle.time = circle.delay - ease;\n\n                        //If the current circle delay = progress draws next circle, (random drawing look)\n                        if (circle.time <= 0) {\n\n                            //current circle set to undefined keep from running again\n                            circle.delay = undefined;\n                            j++;\n                        }\n                        circle.alpha = circle.globAlpha - 1 * _progress;\n                        circle.opacity = circle.opac - .9 * _progress;\n                        // circle.duration = ease\n\n                        if (j % 3 !== 0 && menData.j >= 1) {\n                            circle.xPos = circle.x + circle.endPos * ease;\n                            circle.yPos = 0 + circle.y * ease;\n                            ctx.globalCompositeOperation = 'destination-over';\n                        } else {\n                            circle.xPos = circle.x + circle.endPos * ease;\n                            circle.yPos = 0 + circle.y * _progress;\n                            ctx.globalCompositeOperation = 'source-over';\n                        }\n\n                        drawStars(circle);\n\n                        //Explosion start\n                        if (circle.xPos > image.x && circle.yPos > image.y) {\n\n                            drawExplosion(circle, timestamp);\n                        }\n\n                        if (j === data.length) {\n                            j = 0;\n                            data = [];\n                            trailData = [];\n                            this.addData();\n                        }\n                    }\n                }\n            }\n            //**  START OF MEN  **/\n            var menLength = starryNight.images.length - 1;\n\n            for (var _i2 = 0; _i2 < menLength; _i2++) {\n                var men = starryNight.images[_i2];\n\n                if (!menData.begin) menData.begin = timestamp;\n                var runtime = timestamp - menData.begin;\n                var progress = Math.min(runtime / 2000, 1);\n\n                //First walk out\n                if (menData.j === 0) {\n                    menData.start = parseInt((progress * 15).toFixed(0));\n                    menData.distanceX = window.innerWidth < 768 ? 95 : 205;\n                }\n                //Second Walk stands still\n                if (menData.j === 1) {\n                    //Starts and ends with last dude\n                    menData.start = 15;\n                    // Keeping count at last man instead of counting through them to animate\n                    menData.distanceX = 0;\n                }\n\n                //Third walk down and to the end\n                if (menData.j === 2) {\n                    menData.start = parseInt((progress * 15).toFixed(0));\n                    men.walkDown = Math.min(progress * 6, 1) * menData.stepDown;\n                    // menData.distanceX = 250\n                    menData.distanceX = window.innerWidth < 768 ? 159 : 250;\n                }\n\n                //Looks down\n                if (menData.j === 3) {\n                    var headIterate = Math.min(runtime / 1000, 1);\n\n                    //updates men.walkdown that gets ran before back to 0\n                    men.walkDown = 0;\n                    menData.start = 16;\n                    menData.distanceX = 0;\n                    men.arcX = image.x + (menData.lastPosX + (men.width / 2 + 2)) + menData.arcStartX * headIterate;\n                    men.arcY = image.y + (menData.lastPosY + 4) + menData.arcStartY * headIterate;\n                    men.arcRadius = menData.headArc;\n                }\n                //Rotates back and forth\n                if (menData.j === 4) {\n                    //2nd rotated position\n                    var newRotatedPos = menData.rotatedPos - (menData.rotateDegree * iterate - menData.rotatedPos);\n                    menData.start = 14;\n\n                    menData.distanceX = 0;\n\n                    men.translateX = image.x + (menData.lastPosX + men.width / 1.8);\n                    men.translateY = image.y + (menData.lastPosY + men.height);\n                    var iterate = Math.min(progress * 3, 3);\n\n                    if (menData.rotatedPos <= menData.rotateDegree) {\n                        menData.rotatedPos = menData.rotateDegree * iterate;\n                        men.rotate = menData.rotatedPos;\n                    } else {\n                        //Rotate back and forth\n                        if (newRotatedPos >= 0) men.rotate = newRotatedPos;\n                        if (newRotatedPos <= 0) men.rotate = -newRotatedPos;\n                    }\n\n                    //updates roatedPos for mendata.js = 5 to be used below\n                    if (progress === 1) {\n                        men.arcRadius = 0;\n                        menData.roatedPos = men.rotate;\n                    }\n                }\n                //Falls Down\n                if (menData.j === 5) {\n                    menData.start = parseInt((progress * 10).toFixed(0));\n\n                    men.translateX = image.x + (menData.lastPosX + men.width / 2) + this.width / 6 * progress;\n                    men.translateY = image.y + (menData.lastPosY + men.height) + this.height / 2 * progress;\n                    men.rotate = menData.roatedPos + 180 * progress;\n                    menData.distanceX = 0;\n                    if (progress === 1) men.opacity = 0;\n                }\n                if (menData.j === 6) {\n\n                    men.opac = men.opacity + 1 * progress;\n                }\n\n                if (men.startPos === menData.start) {\n\n                    //Constanatly updates men location on the House\n                    var lastX = menData.lastPosX + menData.distanceX * progress;\n                    var lastY = menData.lastPosY + (men.walkDown || 0);\n\n                    men.x = image.x + (menData.lastPosX + menData.distanceX * progress);\n                    men.y = image.y + (menData.lastPosY + (men.walkDown || 0));\n\n                    drawMen(men);\n\n                    if (progress < 1) {} else {\n                        //Resets or updates positions\n                        menData.lastPosX = lastX;\n                        menData.lastPosY = lastY;\n                        menData.j++;\n                        menData.begin = 0;\n                        menData.start = 0;\n                    }\n                }\n            }\n        };\n        drawHouse(image, timestamp);\n\n        requestAnimationFrame(draw);\n    }.bind(this);\n\n    document.querySelector('.animations .start-canvas').addEventListener('click', function () {\n\n        StarryNight.prototype.toggle = true;\n        requestAnimationFrame(draw);\n    }.bind(this));\n\n    document.querySelector('.animations .stop-canvas').addEventListener('click', function () {\n\n        StarryNight.prototype.toggle = false;\n    });\n}\n\nStarryNight.prototype.loadImages = function () {\n    var height = window.innerWidth < 768 ? 60 : 80;\n    var width = window.innerWidth < 768 ? 48 : 64;\n    var $this = this;\n    var count = 0;\n    var images = [];\n    var ext = isFirefox ? \"png\" : \"svg\";\n\n    var men = [{ src: \"images/men/zero.\" + ext, height: height, width: width }, { src: \"images/men/one.\" + ext, height: height, width: width }, { src: \"images/men/two.\" + ext, height: height, width: width }, { src: \"images/men/three.\" + ext, height: height, width: width }, { src: \"images/men/four.\" + ext, height: height, width: width }, { src: \"images/men/five.\" + ext, height: height, width: width }, { src: \"images/men/six.\" + ext, height: height, width: width }, { src: \"images/men/seven.\" + ext, height: height, width: width }, { src: \"images/men/eight.\" + ext, height: height, width: width }, { src: \"images/men/nine.\" + ext, height: height, width: width }, { src: \"images/men/ten.\" + ext, height: height, width: width }, { src: \"images/men/eleven.\" + ext, height: height, width: width }, { src: \"images/men/twelve.\" + ext, height: height, width: width }, { src: \"images/men/thirteen.\" + ext, height: height, width: width }, { src: \"images/men/fourteen.\" + ext, height: height, width: width }, { src: \"images/men/fifteen.\" + ext, height: height, width: width }, { src: \"images/men/headless.\" + ext, height: height, width: width }, { src: \"images/men/house-floating.\" + ext }];\n\n    for (var i = 0; i < men.length; i++) {\n\n        var img = new Image();\n\n        try {\n            throw i;\n        } catch (i) {\n            img.onload = function () {\n\n                images.push({\n                    img: this,\n                    height: men[i].height,\n                    width: men[i].width,\n                    start: 0,\n                    startPos: i\n                });\n\n                if (++count === men.length) {\n\n                    //Sorts the men array in order due to loading images differently\n                    images.sort(function (a, b) {\n                        return a.startPos - b.startPos;\n                    });\n\n                    starryNight.images = images;\n                    //updates the undefined house property with this img\n                    $this.house.houseImg = img;\n                    $this.addData();\n                    $this.house.begin();\n                }\n            };\n            img.src = men[i].src;\n        }\n    }\n};\n\nvar Technologies = function Technologies() {\n    var svgPageWidth = _('svg-page').getAttribute('width');\n    var svgPageHeight = _('svg-page').getAttribute('height');\n    var width = svgPageWidth < 970 || svgPageHeight < 800;\n    this.canvas = document.getElementById('techIcons');\n\n    this.ctx = this.canvas.getContext('2d');\n    this.width = this.canvas.width = svgPageWidth;\n    this.height = this.canvas.height = svgPageHeight;\n    this.start = 0;\n    this.start;\n    this.bodyData = [];\n    this.icons;\n    this.j = 0;\n    var newTechnologies = this;\n    this.data = {\n        addBodyData: function addBodyData() {\n\n            if (width) {\n                //Body location X and Y\n                return {\n                    x: newTechnologies.width / 2 - newTechnologies.bodyData[1].width / 2.2,\n                    y: newTechnologies.height - newTechnologies.bodyData[1].height,\n                    translateX: newTechnologies.width / 2 - newTechnologies.bodyData[3].width / 2 + 60,\n                    translateY: newTechnologies.height - newTechnologies.bodyData[1].height + 70,\n                    headX: newTechnologies.width / 2 - newTechnologies.bodyData[1].width / 2.2 + 41,\n                    headY: newTechnologies.height - newTechnologies.bodyData[1].height - 61\n                };\n            } else {\n                return {\n                    x: newTechnologies.width / 2 - newTechnologies.bodyData[1].width / 2.2,\n                    y: newTechnologies.height - newTechnologies.bodyData[1].height,\n                    //Translate head rotation\n                    translateX: newTechnologies.width / 2 - newTechnologies.bodyData[3].width / 2 + 85,\n                    //Translate head rotation\n                    translateY: newTechnologies.height - newTechnologies.bodyData[1].height + 100,\n                    headX: newTechnologies.width / 2 - newTechnologies.bodyData[1].width / 2.2 + 57,\n                    headY: newTechnologies.height - newTechnologies.bodyData[1].height - 87\n                };\n            }\n        },\n        rotate: -140,\n        j: 0,\n        bookHeight: 200\n    };\n\n    this.sprites = [];\n\n    var ext = isFirefox ? \"png\" : \"svg\";\n\n    var bodyWidth = width ? 1.3 : 1.8;\n    var bodyHeight = width ? 1.3 : 1.8;\n    var src = [\"images/top-head.\" + ext, \"images/face-body.\" + ext, \"images/book.\" + ext, \"images/full-body.\" + ext];\n\n    if (width) {\n\n        var imgWidth = [284.5, 400, 320.96, 400];\n        var imgHeight = [170.9, 483.7, 226.8, 564.66];\n    } else {\n        var imgWidth = [553.5, 778.2, 629.9, 778];\n        var imgHeight = [332.49, 941, 443.27, 1098.9];\n    }\n\n    this.imgIcons = [{ src: \"images/icons/adobe-50-50.\" + ext, width: 40, height: 40 }, { src: \"images/icons/after-effects-52-52.\" + ext, width: 40, height: 40 }, { src: \"images/icons/artistic-52-54.\" + ext, width: 40, height: 42 }, { src: \"images/icons/bootstrap-50-50.\" + ext, width: 40, height: 40 }, { src: \"images/icons/camera-52-52.\" + ext, width: 40, height: 40 }, { src: \"images/icons/cloud-64-49.5.\" + ext, width: 42, height: 32.5 }, { src: \"images/icons/code-60-53.\" + ext, width: 43, height: 38 }, { src: \"images/icons/css-55-52.\" + ext, width: 42, height: 39.8 }, { src: \"images/icons/design-52-52.\" + ext, width: 40, height: 40 }, { src: \"images/icons/git-hub-55-55.\" + ext, width: 43, height: 43 }, { src: \"images/icons/google-drive-72-64.\" + ext, width: 46, height: 40.8 }, { src: \"images/icons/illustrator-52-52.\" + ext, width: 40, height: 40 }, { src: \"images/icons/js-55-56.\" + ext, width: 41, height: 42 }, { src: \"images/icons/node-50-50.\" + ext, width: 40, height: 40 }, { src: \"images/icons/nodejs-60.5-37.\" + ext, width: 55, height: 33.6 }, { src: \"images/icons/npm-70-27.2.\" + ext, width: 65, height: 25.2 }, { src: \"images/icons/photoshop-52-52.\" + ext, width: 40, height: 40 }, { src: \"images/icons/php-65-35.\" + ext, width: 45, height: 24.2 }, { src: \"images/icons/python-57-58.\" + ext, width: 40, height: 40.7 }, { src: \"images/icons/react-59-52.\" + ext, width: 42, height: 37 }, { src: \"images/icons/server-55-58.\" + ext, width: 40, height: 40 }];\n\n    this.loopImgs = function () {\n        var load = [];\n\n        for (var j = 0; j < 4; j++) {\n            load.push({\n                src: src[j],\n                width: imgWidth[j] / bodyWidth,\n                height: imgHeight[j] / bodyHeight\n            });\n        }\n        var icons = this.imgIcons;\n\n        for (var i = 0; i < icons.length; i++) {\n            var w = !width ? icons[i].src.replace(/^([a-z\\/]+)\\/([a-z-?]+)-(\\d\\d)(.+)/ig, \"$3\") : icons[i].width;\n            var h = !width ? icons[i].src.replace(/^(.+)(\\d{2})(.+)/ig, \"$2\") : icons[i].height;\n            // console.log(w,h, i);\n            load.push({\n                src: icons[i].src,\n                width: parseInt(w),\n                height: parseInt(h)\n            });\n        }\n        return load;\n    };\n    function random(min, max) {\n        return Math.floor(Math.random() * (max - min) + min);\n    };\n    this.addData = function (n) {\n        var icons = this.icons;\n        for (var i = 0; i < n; i++) {\n\n            this.sprites.push({\n                //Each icon draws for ever 30 mil sec\n                timing: 30,\n                endX: random(0, this.width / 2),\n                endY: random(0, this.height - (this.bodyData[1].height + 50)),\n                start: 0,\n                speed: random(4000, 9000),\n                x: this.width / 2,\n                y: this.data.addBodyData().y + 15, // plus 100 the sprite size\n                img: this.icons[i % icons.length].img,\n                width: this.icons[i % icons.length].width,\n                height: this.icons[i % icons.length].height,\n                X: 0,\n                Y: 0,\n                staticSpeed: 0,\n                rotate: random(180, 1440)\n            });\n        }\n    };\n};\n\nTechnologies.prototype.rotateHead = function (rotate, pos) {\n\n    var img = this.bodyData;\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.ctx.drawImage(img[1].img, pos.x, pos.y, img[1].width, img[1].height); //Face body\n    this.ctx.translate(pos.translateX, pos.translateY); // Translate \n    this.ctx.rotate(rotate * Math.PI / 180);\n    this.ctx.translate(-pos.translateX, -pos.translateY); // Translate back\n    this.ctx.drawImage(img[0].img, pos.headX, pos.headY, img[0].width, img[0].height); //Head draw in translated canves\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n};\n\nTechnologies.prototype.drawBook = function (data, pos) {\n    var img = this.bodyData;\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.ctx.globalCompositeOperation = 'destination-over';\n    this.ctx.drawImage(img[1].img, pos.x, pos.y, img[1].width, img[1].height); //Face body\n    this.ctx.translate(pos.translateX, pos.translateY); // Translate \n    this.ctx.rotate(-140 * Math.PI / 180);\n    this.ctx.translate(-pos.translateX, -pos.translateY); // Translate back\n    this.ctx.drawImage(img[0].img, pos.headX, pos.headY, img[0].width, img[0].height); //Head draw in translated canves\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n    this.ctx.translate(pos.translateX + img[2].width / 2, pos.translateY); // Translate  \n    this.ctx.scale(data.scale, data.scale); //Scales book\n    this.ctx.translate(-pos.translateX - img[2].width / 2, -pos.translateY); // Translate back for\n    this.ctx.drawImage(img[2].img, data.bookX, data.bookY, img[2].width, img[2].height); //book image\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n};\n\nTechnologies.prototype.drawBody = function (data, pos) {\n    var img = this.bodyData;\n\n    this.ctx.drawImage(img[1].img, pos.x, pos.y, img[1].width, img[1].height); //Face body\n    this.ctx.translate(pos.translateX, pos.translateY); // Translate \n    this.ctx.rotate(-140 * Math.PI / 180);\n    this.ctx.translate(-pos.translateX, -pos.translateY); // Translate back\n    this.ctx.drawImage(img[0].img, pos.headX, pos.headY, img[0].width, img[0].height); //Head draw in translated canves\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.translate(pos.translateX + img[2].width / 2, pos.translateY); // Translate  \n    this.ctx.scale(1.05, 1.05);\n    this.ctx.translate(-pos.translateX - img[2].width / 2, -pos.translateY); // Translate back\n    this.ctx.drawImage(img[2].img, data.bookX, data.bookY, img[2].width, img[2].height); //book image\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n};\n\nTechnologies.prototype.drawIcons = function (spr) {\n    this.ctx.setTransform(1, 0, 0, 1, spr.X, spr.Y);\n    this.ctx.rotate(spr.turn * Math.PI / 180);\n    this.ctx.drawImage(spr.img, -spr.width / 2, -spr.height / 2, spr.width, spr.height);\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n};\n\nTechnologies.prototype.draw = function (timestamp) {\n    if (!this.toggle) return;\n    var width = this.width < 970 || this.height < 800;\n    var img = this.bodyData;\n    var data = this.data;\n    var pos = data.addBodyData();\n\n    if (!this.start) this.start = timestamp;\n    var runtime = timestamp - this.start;\n    var progress = Math.min(runtime / 1000, 1);\n\n    if (progress < 1 && data.j <= 1) {\n\n        if (width) {\n            //Updates x loactions and y location of book\n            data.bookX = pos.translateX - 40 - 0;\n            data.bookY = pos.translateY - 110 - 60 * progress;\n        } else {\n            //Updates x loactions and y location of book\n            data.bookX = pos.translateX - 60 - 0;\n            data.bookY = pos.translateY - 180 - 60 * progress;\n        }\n        //Rotate head\n        if (data.j === 0) {\n\n            var rotate = data.rotate * progress;\n            this.rotateHead(rotate, pos);\n        }\n        //PUsh up book\n        if (data.j === 1) {\n\n            data.scale = .5 + .55 * progress;\n            this.drawBook(data, pos);\n        }\n    } else {\n\n        //Draw Icons\n        if (data.j === 2) {\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            this.drawBody(data, pos);\n\n            var sprites = this.sprites.length;\n\n            for (var i = 0; i < sprites; i++) {\n\n                var spr = this.sprites[i];\n\n                if (i <= this.j) {\n\n                    spr.staticSpeed++;\n\n                    if (!spr.start) spr.start = timestamp;\n                    var run = timestamp - spr.start;\n                    var prog = run / spr.speed;\n\n                    if (i % 2) {\n                        //left up\n                        spr.X = spr.x - spr.endX * prog;\n                        spr.Y = spr.y - spr.endY * prog;\n                        spr.turn = -spr.rotate * prog;\n                    } else {\n                        //right up;\n                        spr.X = spr.x + spr.endX * prog;\n                        spr.Y = spr.y - spr.endY * prog;\n                        spr.turn = spr.rotate * prog;\n                    }\n\n                    spr.totalX = spr.X;\n                    spr.totalY = spr.Y;\n\n                    if (spr.totalX + spr.width <= 0 || spr.totalY + spr.height <= 0 || spr.totalX > this.width + spr.width) {\n\n                        //Resets values, for same icon to run again\n                        this.sprites[i].start = 0;\n                    }\n                    this.drawIcons(spr);\n                    if (spr.staticSpeed === spr.timing) this.j++;\n                }\n            }\n        } else {\n            this.start = 0;\n            data.j++;\n        }\n    }\n    requestAnimationFrame(this.draw.bind(this));\n};\n\nTechnologies.prototype.loadImages = function () {\n    var $this = this;\n    var counter = 0;\n    var loadedImages = 0;\n    var imgs = [];\n\n    this.loopImgs().forEach(function (image, i) {\n        counter++;\n        var img = new Image();\n\n        img.onload = function () {\n\n            //Width or height doesn't exist updates 0 for it\n            imgs.push({ img: this, i: i, width: image.width, height: image.height });\n\n            if (++loadedImages >= counter) {\n                imgs.sort(function (a, b) {\n                    return a.i - b.i;\n                });\n                //When Icons load full body image gets added\n                $this.ctx.drawImage(imgs[3].img, $this.width / 2 - imgs[1].width / 2.2, $this.height - imgs[3].height, imgs[3].width, imgs[3].height); //Full-body image\n\n                var bodyImgs = imgs.splice(0, 4);\n\n                $this.bodyData = bodyImgs;\n                $this.icons = imgs;\n\n                //Icon data\n                $this.addData(imgs.length);\n            }\n        };\n        img.src = image.src;\n    });\n};\n\nfunction SvgPage() {\n    var svgCloseButton = document.getElementsByClassName('close-btn svg-button')[0];\n    var svgCircle = document.getElementsByClassName('svg-circle')[0];\n    var toggle, btnOpen, event;\n    var hovermap = hoverMap();\n\n    var removeGooey = function removeGooey(e) {\n        setTimeout(function () {\n            hovermap[1](e);\n        }, 1400);\n\n        //    console.log( hovermap[1])\n        //     var dist = hovermap[1](e)[0]; // Position distance of show-icon gooey\n        //     hovermap[0]( dist, true )  // handler(e) function\n    };\n    this.start;\n    //Page animated down removes circle to be animated again\n    this.animateEnd = function (e) {\n        console.log('hey you');\n        _('interactive-container').style.pointerEvents = 'auto';\n\n        if (toggle) {\n            //Safari only\n            _('svg-page').style.visibility = 'hidden';\n            svgCircle.classList.remove('circle-animate');\n\n            _(btnOpen)[0].style.display = 'none';\n            document.querySelector('g.' + btnOpen + ' .items').classList.remove('items-active');\n\n            toggle = false;\n        }\n    };\n\n    this.animateCircle = function (timestamp, elem) {\n\n        if (!this.start) this.start = timestamp;\n\n        var runtime = timestamp - this.start;\n        var progress = Math.min(runtime / this.speed, 1);\n        isFirefox ? svgCircle.setAttribute('r', 1500 * progress) : svgCircle.style.transform = 'scale(' + (0 + 1 * progress) + ')';\n\n        if (progress < 1) {\n            requestAnimationFrame(function (timestamp) {\n                this.animateCircle(timestamp, elem);\n            }.bind(this));\n        } else {\n            //Canvas fades in after page is animated open\n            document.querySelector('g.' + elem + ' .items').classList.add('items-active');\n            document.getElementsByClassName(elem)[1].parentElement.classList.add('showCanvas');\n            this.start = null;\n        }\n    };\n    var closeButtonShow = function closeButtonShow(num) {\n        var opposite = !num ? -56 : 0;\n        _('x-circle').style.transform = 'translateX(' + num + 'px)';\n        _('line')[0].style.transform = 'translateX(' + opposite + 'px) rotate(-45deg)';\n        _('line')[1].style.transform = 'translateX(' + opposite + 'px) rotate(45deg)';\n    };\n\n    // Open page function\n    this.openModals = function (e) {\n\n        try {\n            btnOpen = e.target.id;\n        } catch (err) {\n            btnOpen = e;\n        }\n\n        _('interactive-container').style.pointerEvents = 'none';\n        event = e;\n        _(btnOpen)[0].style.display = 'block';\n        closeButtonShow(-56);\n        //Google 'Do Hyeon' font bug, function has to be ran again in view\n        if (btnOpen === 'photo') slotMachine();\n        //Throbbing Finger image icon\n        if (btnOpen === 'design') document.getElementById('finger').classList.add('finger-scale');\n\n        if (isSafari) {\n\n            toggle = true;\n            _('svg-page').style.visibility = \"visible\";\n            svgCircle.classList.add('circle-animate');\n\n            svgCircle.onanimationend = function () {\n\n                document.querySelector('g.' + btnOpen + ' .items').classList.add('items-active');\n                document.getElementsByClassName(btnOpen)[1].parentElement.classList.add('showCanvas');\n            };\n\n            //Closes the page animated down\n            svgCloseButton.addEventListener('click', function () {\n                toggle = true;\n\n                //Automatically stops canvas \n                Stretch.prototype.toggle = false;\n                slotMachine.prototype.toggle = false;\n                StarryNight.prototype.toggle = false;\n                Technologies.prototype.toggle = false;\n\n                //Canvas / Items fades out\n                document.getElementsByClassName(btnOpen)[1].parentElement.classList.remove('showCanvas');\n            });\n        } else {\n            toggle = false;\n\n            requestAnimationFrame(function (timestamp) {\n                this.speed = 600;\n                this.animateCircle(timestamp, btnOpen);\n            }.bind(this));\n\n            svgCloseButton.addEventListener('click', function (e) {\n                closeButtonShow(0);\n                Stretch.prototype.toggle = false;\n                slotMachine.prototype.toggle = false;\n                StarryNight.prototype.toggle = false;\n                Technologies.prototype.toggle = false;\n                document.getElementsByClassName(btnOpen)[1].parentElement.classList.remove('showCanvas');\n\n                setTimeout(function () {\n                    isFirefox ? _('svg-circle').setAttribute('r', 0) : _('svg-circle').style.transform = 'scale(0)';\n\n                    //Current SVG element hides\n                    document.getElementsByClassName(btnOpen)[0].style.display = 'none';\n                    document.querySelector('g.' + btnOpen + ' .items').classList.remove('showCanvas');\n                    // document.getElementsByClassName(btnOpen)[1].parentElement.classList.remove('showCanvas')\n                }, 1900);\n            });\n        }\n    }.bind(this);\n\n    var popUpCards = function () {\n        var open_modals = this.openModals;\n\n        var popUpcards = _('card-popups');\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = popUpcards[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var cards = _step.value;\n\n                cards.addEventListener('click', function (e) {\n                    removeGooey(e);\n                    open_modals(this.attributes[3].value);\n                });\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    }.bind(this);\n    if (wW < 768) popUpCards();\n\n    _('circle-thumbnails').addEventListener('click', function (e) {\n        if (wW < 768) {\n            hovermap[1](e);\n        } else {\n            removeGooey(e);\n            this.openModals(e);\n        }\n    }.bind(this));\n};\n//Add to window object to be used for html page onend function\nwindow.svgPage = new SvgPage();\n\nfunction getPos(ele) {\n\n    var elemRect = ele.getBoundingClientRect();\n    var mainSvg = document.getElementsByClassName('svg-page')[0].getBoundingClientRect();\n    var elemLeft = (mainSvg.width - (parseInt(ele.getAttribute('width')) || elemRect.width)) / 2;\n\n    return {\n        width: elemRect.width,\n        mainSvg: mainSvg,\n        left: elemRect.left,\n        top: elemRect.top,\n        height: elemRect.height,\n        //Places image's property left to the center of it's container (center of page)\n        centeredLeft: elemLeft\n    };\n};\n\n//Different screen sizing , elements adjust to it\nfunction adjustElements() {\n    var pathD768 = \"M565.1,0v900H0c0,0,0-75.3,0-192.4c0-211.7,0-303.7,0-533.1C0,50.5,0,0,0,0H565.1z\";\n    var pathD400 = \"M390,800H0c0,0,0-87.3,0-161.3S0,84,0,47.3S0,0,0,0h390V800z\";\n    var smallSplines = \".42 0 1 1;.42 0 1 1;.42 0 1 1;.42 0 1 1;\";\n    var smallKeyTimes = \"0; 0.20; 0.45; 1\";\n    var svg = document.getElementsByClassName('svg-page')[0];\n\n    //Sets sizing for opening closing svg-page wave\n    if (wH < 840 && wW) {\n        var svgWidth = wW < 500 ? wW - 20 : wW - 50;\n        var svgHeight = wH < 680 ? wH - 15 : wH - 50;\n    } else {\n        var svgWidth = wW < 500 ? wW - 20 : wW - 50;\n        var svgHeight = 840;\n    }\n\n    if (wW <= 615) {\n        document.getElementById('path').setAttribute('d', pathD768);\n        _('path').setAttribute('values', animate768);\n        _('path').setAttribute('keyTimes', smallKeyTimes);\n        _('path').setAttribute('keySplines', smallSplines);\n    }\n\n    if (wW <= 400) {\n        document.getElementById('path').setAttribute('d', pathD400);\n        _('path').setAttribute('values', animate400);\n    }\n\n    if (wW >= 970 && wH) {\n\n        svg.setAttribute(\"height\", svgHeight);\n    } else {\n        if (wH > 840) {\n\n            svg.setAttribute(\"viewBox\", \"0 0 \" + \" \" + svgWidth + \" \" + svgHeight);\n            svg.setAttribute(\"width\", svgWidth);\n            svg.setAttribute(\"height\", svgHeight);\n        }\n        if (wH < 840) {\n            svg.setAttribute(\"viewBox\", \"0 0 \" + \" \" + svgWidth + \" \" + svgHeight);\n            svg.setAttribute(\"width\", svgWidth);\n            svg.setAttribute(\"height\", svgHeight);\n        }\n    }\n\n    if (wW && wH) {\n\n        //Add to element when more canvases are added to HTML\n        var elementG = document.querySelectorAll('g.photo, g.developer, g.design, g.animations, g.technologies');\n\n        elementG.forEach(function (el, i) {\n            var groupName = el.classList[0];\n\n            if (groupName === 'photo') {\n                var canvas = document.getElementById('slot-machine');\n                document.getElementById('canvas-area').setAttribute('transform', 'translate(157, 0)');\n\n                Array.prototype.forEach.call(el.children, function (elem, i) {\n\n                    //Camera SVG\n                    if (i === 0) {\n\n                        var newHeight = newSize('width', 700, elem).height;\n\n                        elem.setAttribute('width', 700);\n                        elem.setAttribute('height', newHeight);\n\n                        var _pos = getPos(elem);\n                        var setAttributeY = _pos.mainSvg.height - newHeight - 5;\n\n                        elem.setAttribute('x', _pos.centeredLeft);\n                        elem.setAttribute('y', setAttributeY);\n\n                        if (wW <= 500 || wH <= 800) {\n\n                            elem.style.visibility = 'hidden';\n                        }\n                    }\n                    //ForeignObject holds canvas\n                    if (i === 2) {\n\n                        if (wW < 970) {\n                            var canvasArea = document.getElementById('canvas-area');\n\n                            var _pos2 = getPos(canvasArea);\n\n                            if (wH < 640 && wW < 800) {\n\n                                elem.setAttribute('y', 240);\n                            } else {\n\n                                //firefox\n                                !isFirefox ? elem.setAttribute('y', svg.getAttribute('height') - _pos2.height - 16) : svg.getAttribute('width') / 2 - 397.6 / 2;\n                                elem.setAttribute('y', svg.getAttribute('height') - 397.6 - 16);\n                                // elem.setAttribute('y', 250)\n                            }\n\n                            elem.setAttribute('width', 360);\n                            elem.setAttribute('height', 360);\n                            !isFirefox ? elem.setAttribute('x', _pos2.left - 6) : elem.setAttribute('x', svg.getAttribute('width') / 2 - 397.6 / 2 + 20);\n                            // elem.setAttribute('y', svg.getAttribute('height') - pos.height - 16)\n                        } else {\n                            var posHeight = getPos(elem);\n                            var width = parseInt(elem.getAttribute('width'));\n                            var elemLeft = posHeight.mainSvg.width - width - 15;\n\n                            elem.setAttribute('y', 60);\n                            elem.setAttribute('x', elemLeft);\n                        }\n\n                        if (wW <= 500) {\n                            var _thisPos = getPos(elem);\n                            elem.setAttribute('x', _thisPos.centeredLeft);\n\n                            if (wH < 620) {\n                                elem.setAttribute('y', 200);\n                            }\n                        }\n                    }\n                    //Items\n                    if (i === 1) {\n                        var pos = getPos(document.getElementById('canvas-area'));\n\n                        elem.childNodes[1].setAttribute('width', 400);\n                        elem.childNodes[1].setAttribute('height', 235);\n                        elem.childNodes[1].setAttribute('x', 20);\n                        if (wW < 970) {\n                            elem.childNodes[1].setAttribute('y', 0);\n                        } else {\n                            elem.childNodes[1].setAttribute('y', 100);\n                        }\n                        if (window.innerWidth <= 500) {\n                            elem.childNodes[1].setAttribute('width', 335);\n                            elem.childNodes[1].setAttribute('x', 10);\n                            var thisPos = getPos(elem.childNodes[1]);\n                        }\n                    }\n                });\n            };\n            if (groupName === 'developer') {\n                Array.prototype.forEach.call(el.children, function (elem, i) {\n\n                    //foreignObject holds canvas\n                    if (i === 1) {\n                        if (wW < 970) {\n                            elem.setAttribute('width', 400);\n                            elem.setAttribute('height', 375);\n                        }\n                        var pos = getPos(el.children[0]);\n                        elem.setAttribute('y', 200);\n\n                        if (window.innerWidth <= 850) {\n                            if (wH < 690) {\n                                elem.setAttribute('y', 25);\n                                elem.setAttribute('x', 5);\n                            } else {\n                                elem.setAttribute('x', 50);\n                                elem.setAttribute('y', 75);\n                            }\n                        }\n                        if (window.innerWidth < 505) {\n                            if (wH < 690) {\n                                elem.setAttribute('y', 50);\n                                elem.setAttribute('x', 0);\n                            }\n                            elem.childNodes[1].setAttribute('width', 360);\n                            elem.setAttribute('height', 375);\n\n                            var thisPos = getPos(elem.childNodes[1]);\n                            elem.setAttribute('y', 50);\n                            elem.setAttribute('x', 5);\n                        }\n                    }\n                    //items\n                    if (i === 0) {\n                        if (window.innerWidth < 505) {\n                            elem.childNodes[1].setAttribute('x', 10);\n                            elem.childNodes[1].setAttribute('y', 424);\n                            elem.childNodes[1].setAttribute('width', 370);\n                        }\n                        if (wW > 505 && wW < 850) {\n                            if (wH < 690) {\n                                elem.childNodes[1].setAttribute('y', 425);\n                                elem.childNodes[1].setAttribute('width', 370);\n                            } else elem.childNodes[1].setAttribute('y', 460);\n                        }\n                    }\n                });\n            }\n            if (groupName === 'design') {\n                var items = el.children[0].children[0];\n                var canvasArea = el.children[1];\n\n                if (wH && wW > 970) {\n\n                    if (canvasArea) {\n                        if (wW > 1200) {\n                            canvasArea.setAttribute('width', 580);\n                            canvasArea.setAttribute('height', 580);\n                        }\n                        canvasArea.setAttribute('y', 80);\n                    }\n                    if (items) {\n                        items.setAttribute('y', 200);\n                    }\n                } else if (wW > 750 && wW < 970) {\n\n                    if (canvasArea) {\n                        //For Safari overflow not working\n                        wW < 810 ? canvasArea.setAttribute('x', 210) : canvasArea.setAttribute('x', 255);\n                        canvasArea.setAttribute('y', 160);\n                        if (wH < 703) {\n                            //For Safari overflow not working\n                            canvasArea.setAttribute('height', 450);\n                        }\n                    }\n                    if (items) {\n                        items.setAttribute('y', 0);\n                    }\n                } else {\n                    items.setAttribute('y', 0);\n                    items.setAttribute('x', 10);\n                    wH < 700 ? items.setAttribute('height', 250) : items.setAttribute('height', 260);\n                    items.setAttribute('width', 340);\n\n                    var height = items.getAttribute('height');\n                    canvasArea.setAttribute('y', height);\n\n                    wW < 600 ? canvasArea.setAttribute('width', 400) : canvasArea.setAttribute('width', 500);\n                    wW < 600 ? canvasArea.setAttribute('height', 400) : canvasArea.setAttribute('height', 500);\n\n                    var canvasPos = getPos(canvasArea);\n                    canvasArea.setAttribute('x', canvasPos.centeredLeft);\n                    //For safari, so photo doesn't show the overflow\n                    canvasArea.setAttribute('height', svg.getAttribute('height') - items.getAttribute('height'));\n                }\n            }\n            if (groupName === 'animations') {\n                var items = el.children[0].children[0];\n                var canvasArea = el.children[1];\n                var svgPageHeight = svg.getAttribute('height');\n\n                if (wH && wW > 970) {\n                    canvasArea.setAttribute('height', svgPageHeight);\n                }\n                if (wW < 768) {\n                    var _bottom = (svg.getAttribute('height') - 310) / 2;\n                    items.setAttribute('x', 15);\n                    items.setAttribute('y', _bottom);\n                    items.setAttribute('height', 320);\n                    items.setAttribute('width', 370);\n                } else {\n                    canvasArea.setAttribute('height', svgPageHeight);\n                }\n            }\n            if (groupName === 'technologies') {\n                var items = el.children[0].children[0];\n                var canvasArea = el.children[1];\n\n                if (wW < 650 && wH < 655) {\n                    var bottom = (svg.getAttribute('height') - 370) / 2;\n                    items.setAttribute('y', bottom);\n                    items.setAttribute('x', 5);\n                }\n            }\n        });\n    }\n};\n\nif (wW < 970 || wH < 800) {\n    adjustElements();\n} else {\n    //Adds margin between full height threshhold for svg-page\n    if (wH < 840) {\n        _('svg-page').setAttribute('height', wH - 40);\n    }\n    if (wW < 1000) {\n        _('svg-page').setAttribute('width', wW - 40);\n    }\n    var designCanvas = document.querySelector('.design .item-canvas');\n    designCanvas.setAttribute('width', 580);\n    designCanvas.setAttribute('height', 580);\n}\n\n//Moves close button to right of svg-page\nfunction placeCloseButton() {\n\n    var btnPos = getPos(_('close-btn'));\n    _('close-btn').style.transform = 'translateX(' + (btnPos.mainSvg.width - 56) + 'px)';\n}\nplaceCloseButton();\n\nfunction hoverMap() {\n    var btnWrap = _('button-wrap');\n    var dist;\n    var lastDist;\n    var currentPath; //Path to be removed when mouseout\n\n    var mouseOut = function mouseOut(dist) {\n        // dist from opening popups to remove pointer\n        var pointerDist = typeof dist === 'number' ? dist : lastDist;\n\n        _('oval-pointer').style.transform = 'translate(-80px, 0px )';\n\n        if (isFirefox) {\n\n            _('show-icon').style.transform = 'translate(-24px,' + pointerDist + 'px )';\n        } else if (isSafari) {\n\n            _('show-icon').style.transform = 'translate(-24px,' + pointerDist + 'px )';\n        } else {\n\n            _('show-icon').style.transform = 'translate(-22px,' + pointerDist + 'px )';\n        }\n    };\n\n    if (wW > 768) btnWrap.onmouseover = handler;\n\n    function handler(e) {\n        dist = getDistance(e.target.className, e.target.id);\n\n        function getDistance(el, id) {\n            var totalDist = function totalDist(n) {\n                return n * 37;\n            };\n            var nodelist = _(el);\n            var elArray = [].slice.call(nodelist);\n\n            for (var i = 0; i < elArray.length; i++) {\n                if (elArray[i].id == id) return totalDist(i);\n            }\n        }\n\n        function getPathElement(el, map_paths) {\n            var newPathArray = [];\n            var pathArray = [].slice.call(map_paths);\n\n            //Puts elements in correct order\n            for (var i = pathArray.length - 1; i >= 0; i--) {\n                newPathArray.push(pathArray[i]);\n            }\n\n            var target = document.getElementById(el);\n            var targetArray = [].slice.call(_(target.className));\n\n            for (var i = 0; i < targetArray.length; i++) {\n                if (targetArray[i] === target) return newPathArray[i];\n            }\n        };\n\n        var animateGooey = function animateGooey() {\n\n            if (!_('show-icon').classList.contains('icon-transition')) {\n\n                // transforms only up and down before out.\n                _('show-icon').style.transform = 'translate(-22px,' + dist + 'px )';\n\n                setTimeout(function () {\n                    _('show-icon').classList.add('icon-transition');\n                    _('show-icon').style.transform = 'translate(-15px,' + dist + 'px )';\n                    _('oval-pointer').style.transform = 'translate(0px, 0px )';\n                }, 100);\n            } else {\n                _('show-icon').style.transform = 'translate(-15px,' + dist + 'px )';\n                _('oval-pointer').style.transform = 'translate(0px, 0px )';\n            }\n        };\n\n        var animatePathLines = function animatePathLines(path, map_paths) {\n            var classId = path.id.replace(/-sm$/ig, \"\");\n\n            for (var i = 0; i < map_paths.length; i++) {\n                //Removes all classes before target element class gets added\n                if (map_paths[i].classList.length === 2) {\n\n                    var className = map_paths[i].classList[1];\n                    map_paths[i].classList.remove(className);\n                }\n            }\n            path.classList.add(classId);\n            return classId;\n        };\n\n        var removeCardsClass = function removeCardsClass(target) {\n\n            var card = _('card-icon');\n            var length = card.length;\n\n            while (length--) {\n                var styleTransform = +card[length].style.transform.replace(/([^-\\d])/ig, '');\n                if (styleTransform !== 0) card[length].style.transform = 'translateY(0px)';\n            }\n        };\n        var animateCardsUp = function animateCardsUp(path) {\n\n            var card = _('card-icon');\n            var regEx = /-.+$/ig;\n            var target = path.id.replace(regEx, '');\n            var length = card.length;\n\n            //If target also has 2 classList, remove that class and add p0opupcard\n            while (length--) {\n                var cardParent = card[length].parentNode;\n                var styleTransform = +card[length].style.transform.replace(/([^-\\d])/ig, '');\n\n                if (target === cardParent.id.replace(regEx, '')) {\n                    // card[length].style.transform = 'translateY(-140px)'\n\n                    card[length].style.transform = 'translateY(-140px)';\n                } else if (styleTransform !== 0) {\n                    card[length].style.transform = 'translateY(0px)';\n                }\n            }\n        };\n\n        function AnimateCircles(path, map_paths) {\n\n            var circles = document.querySelectorAll('#pulse-circles circle');\n            var paths = [];\n            //Removes all classes before target elements classes gets added\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = circles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var cir = _step2.value;\n\n                    if (cir.classList.length > 1) {\n                        cir.classList.remove(cir.classList[1]);\n                    }\n                }\n                //Stops before error when not passing arguments from click handler\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            if (!arguments.length) return;\n\n            //Pairs circles and returns the pairs so classes can be added\n            var pairCircles = function pairCircles() {\n                var cir = [];\n                for (var j = 0; j < circles.length; j += 2) {\n\n                    cir.push([circles[j], circles[j + 1]]);\n                }\n                return cir;\n            };\n\n            for (var i = 0; i < map_paths.length; i++) {\n\n                paths.unshift(map_paths[i].id);\n            }\n\n            var index = paths.indexOf(path.id);\n            var cirPairs = pairCircles()[index];\n\n            cirPairs[0].classList.add('middle-pulse');\n            cirPairs[1].classList.add('ring-pulse');\n        };\n\n        var removeCircles = function removeCircles(string) {\n            var activeCircles = document.querySelectorAll('.middle-pulse, .ring-pulse');\n\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = activeCircles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var cir = _step3.value;\n\n\n                    cir.addEventListener('animationend', function (e) {\n\n                        e.target.classList.remove(e.target.classList[1]);\n                    });\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n        };\n        function removeAll(string) {\n            removeCircles(string);\n            mouseOut(dist);\n            removeCardsClass();\n            try {\n                //Path to be removed when mouseout\n                document.getElementById(currentPath).classList.remove(currentPath);\n            } catch (err) {}\n        }\n        function handleMap(e) {\n            var target = e.target.classList.value;\n\n            //If click comes from opening svg modals\n            if (target === 'card-color-st39' || wW > 768 && e.type === 'click') {\n\n                return removeAll(path);\n            }\n            // mouse over\n            if (e.target.id) {\n                //Start the path animated lines\n                var map_paths = wW > 768 ? _('map-paths') : _('map-paths-sm');\n                var path = getPathElement(e.target.id, map_paths);\n\n                //Used to update translate for button location\n                lastDist = dist;\n\n                animateGooey();\n                currentPath = animatePathLines(path, map_paths);\n                AnimateCircles(path, map_paths);\n                animateCardsUp(path);\n\n                //Only runs after mouseover elements run first, then initiated. \n                _('interactive-container').onmouseover = function (e) {\n                    if (e.target.className !== 'open-canvas-page' && wW > 768) {\n\n                        removeAll();\n                    }\n                };\n            }\n        }\n\n        if (e.type == 'mouseover' && wW > 768) {\n            handleMap(e);\n        } else if (e.type === 'click') {\n\n            handleMap(e);\n        }\n        return [dist];\n    }\n    return [mouseOut, handler]; // To be able to use mouseOut function and handler function that returns dist to use for mouseOut Func\n};\n\nvar toggleStars = {\n    toggle: false\n};\n\nvar robotSection = function robotSection(e) {\n\n    var stars = [];\n    var animateStars = function animateStars() {\n\n        var canvas = document.getElementById('star-canvas');\n        var ctx = canvas.getContext('2d');\n        var width = canvas.width = window.innerWidth;\n        var height = canvas.height = window.innerHeight;\n\n        var randomWidth = function randomWidth() {\n            //max and min\n            return Math.random() * (width / 2 - width / 9) + width / 9;\n        };\n\n        var NightStars = function NightStars() {\n            var _this3 = this;\n\n            var randomStart = randomWidth();\n\n            this.duration = 2000; //used to delay stars\n            this.radius = 13 + Math.random() * 5; //size of stars\n\n            this.i = 0; //x and y speed\n            this.k = 0; //opacity speed\n\n            this.start = {\n                y: Math.random() * height\n            };\n\n            this.Flicker = function (increntment) {\n                return Math.cos(increntment - Math.PI / 180) * .2;\n            };\n\n            this.radSize = function (increntment) {\n                return Math.sin(increntment - Math.PI / 180) * 7;\n            };\n\n            this.x = function (increntment, starSize) {\n                //full screen animate change this.randomWidth back to width / 2\n                return Math.cos(increntment - Math.PI / 180) * (randomStart + starSize);\n            };\n\n            this.y = function (increntment) {\n                return Math.sin(-increntment - Math.PI / 180) * 160;\n            };\n\n            this.draw = function (ctx) {\n                var s = _this3;\n\n                var opacSpeed = s.k += .3;\n                var speed = s.i += s.randomSpeed;\n\n                var radSize = s.radSize(speed);\n                var flicker = s.Flicker(opacSpeed);\n\n                var y = s.y(speed);\n                var x = s.x(speed, s.radius);\n\n                ctx.translate(width / 2, s.start.y);\n                var gradient = ctx.createRadialGradient(x, y, .4, x, y, 14);\n\n                gradient.addColorStop(0, 'LightSkyBlue');\n                gradient.addColorStop(.9, 'DodgerBlue');\n                gradient.addColorStop(1, 'RoyalBlue');\n\n                ctx.beginPath();\n                ctx.arc(x, y, s.radius - radSize - flicker, 0, Math.PI * 2);\n                ctx.fillStyle = gradient;\n                ctx.fill();\n\n                ctx.translate(-width / 2, -s.start.y);\n            };\n        };\n\n        function createStars(starCount, update) {\n            var delay = 0;\n\n            for (var i = 0; i < starCount; i++) {\n                delay += Math.random() * width;\n\n                var nightStars = new NightStars();\n                nightStars.randomSpeed = .001 + Math.random() * .006;\n                nightStars.startTime = Date.now();\n                nightStars.duration += delay; //sets a random delay for stars to start\n                stars.push(nightStars);\n            }\n            update();\n        }\n\n        function update() {\n            //Stopping stars\n            if (toggleStars.toggle) {\n                stars.length = 0;\n                ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n                return;\n            }\n\n            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n\n            var all = stars.length;\n            for (var i = 0; i < all; i++) {\n                // let percent = Math.min( ( Date.now() - stars[i].startTime ) / stars[i].duration, 1 )  //Delay to start stars\n                var percent = Math.min(Date.now() - stars[i].startTime, 1); // No delay\n\n                if (percent === 1) {\n                    stars[i].draw(ctx);\n                }\n            }\n            requestAnimationFrame(update);\n        }\n\n        return {\n            createStars: createStars,\n            update: update\n        };\n    };\n\n    var updateText = function () {\n\n        var toggle = true;\n        var textField = _('text-field');\n\n        function changeToggle(boolean) {\n            toggle = boolean;\n        }\n        return {\n            toggleFalse: function toggleFalse() {\n                changeToggle(false);\n            },\n            updateImgText: function updateImgText(img) {\n\n                changeToggle(true);\n\n                var imgText = img.getAttribute('data-target');\n                var textLength = imgText.length;\n\n                for (var i = 0; i < textLength; i++) {\n\n                    (function (i) {\n                        setTimeout(function () {\n\n                            if (!toggle) return;\n\n                            textField.textContent += imgText[i];\n                        }, 100 * i);\n                    })(i);\n                }\n            }\n        };\n    }();\n\n    function electricBox() {\n        var randomCir = [0, 1, 2, 3, 4, 5];\n\n        function getRandom(num) {\n            return Math.floor(Math.random() * Math.floor(num));\n        }\n        function findNum(item) {\n\n            var newNum = randomCir.splice(item, 1);\n\n            _('robot-st34')[newNum].classList.add('blink');\n            if (randomCir.length) {\n                relay(randomCir);\n            }\n        }\n        function relay(el) {\n            window.setTimeout(function () {\n                var item = getRandom(el.length - 1);\n                findNum(item);\n            }, 80);\n        }\n        relay(randomCir);\n    };\n\n    function checkForClasses() {\n        var circles = _('robot-st34').length;\n\n        // Add blinking light classes\n        for (var i = 0; i < circles; i++) {\n            if (_('robot-st34')[i].classList.contains('blink')) {\n\n                _('robot-st34')[i].classList.remove('blink');\n            }\n        }\n        electricBox();\n    };\n\n    // Add electricity for robot box stomach\n    function addElectricity() {\n        var pathLength = _('electric-path').length;\n        for (var i = 0; i < pathLength; i++) {\n            _('electric-path')[i].style.strokeDasharray = 20;\n            _('electric-path')[i].style.strokeDashoffset = 280;\n        }\n        var start = 0;\n\n        function draw(timestamp) {\n            if (!start) start = timestamp;\n            var runtime = timestamp - start;\n            var progress = Math.min(runtime / 1200, 1);\n\n            for (var i = 0; i < pathLength; i++) {\n                _('electric-path')[i].style.strokeDashoffset = 280 + 280 * progress;\n            }\n\n            if (progress < 1) {\n                requestAnimationFrame(draw);\n            } else {\n                for (var i = 0; i < pathLength; i++) {\n                    _('electric-path')[i].setAttribute('style', '');\n                }\n                return;\n            }\n        }\n        requestAnimationFrame(draw);\n    };\n\n    /** Outter function scope variables **/\n    var designImages = document.getElementsByClassName('designImages');\n    var img_container = document.getElementsByClassName('image-container')[0];\n\n    var animateSlider = {\n        target: null,\n        partialDist: 0,\n        j: 0,\n        dist: 0,\n        start: 0,\n        images: [],\n        imgStart: 0,\n        newStart: function newStart(num) {\n\n            return parseInt(this.images[num].style.transform.replace(/^([\\w]*)\\(|(px.*)$/ig, ''));\n        },\n        containerWidth: function containerWidth() {\n            return parseInt(img_container.style.width.replace(/px/ig, ''));\n        },\n        cloneImage: function cloneImage(img) {\n            var clonedImg = img.cloneNode(true);\n            clonedImg.className = '';\n            clonedImg.removeAttribute('style');\n            imgInlarge.checkForDuplicates('designVisible');\n            imgInlarge.moveElement(clonedImg, 'designVisible');\n        },\n        draw: function draw(timestamp) {\n\n            if (!this.start) this.start = timestamp;\n\n            var runtime = timestamp - this.start;\n            var progress = Math.min(runtime / 700, 1);\n\n            this.images[0].style.transform = 'translate(' + (this.imgStart - this.dist * progress) + 'px, -50%)';\n\n            if (progress === 1) {\n\n                //Second photo following the first to be animated automatically\n                if (this.j === 1) {\n\n                    //checks if left or right button click with a negative left or positive right and updates imgStart\n                    this.imgStart = this.dist < 0 ? -this.containerWidth() : this.containerWidth();\n                    this.dist = this.dist < 0 ? -this.containerWidth() : this.containerWidth();\n\n                    this.start = 0;\n                    var item = this.images.shift();\n                    this.images.push(item);\n                    this.j = 0;\n                } else {\n\n                    //User double clicks same button when 2nd image isn't finished it draws again\n                    if (this.imgStart !== this.dist) {\n\n                        this.draw();\n                    } else {\n                        //Stops typed text from running only when photo stops into place\n                        _('text-field').textContent = '';\n                        updateText.updateImgText(this.images[0]); //Starts the typed text function\n\n                        this.cloneImage(this.images[0]);\n                    }\n                    return this.j++;\n                }\n            }\n            requestAnimationFrame(animateSlider.draw.bind(this));\n        },\n        animateData: function animateData(e) {\n            var target = this.target.innerText;\n            var newStart = this.newStart(0);\n            this.partialDist = newStart;\n\n            //If user clicks before image done animating, updates current location and starts again\n            if (newStart !== 0 && !isNaN(newStart)) {\n\n                if (target === '<') {\n                    //If user double clicks same button right away\n                    if (newStart < 0) {\n                        this.imgStart = newStart;\n                        this.dist = this.containerWidth() + newStart;\n                    } else {\n                        this.j = 0;\n                        this.dist = newStart;\n                        this.imgStart = newStart;\n                    }\n                }\n                if (target === '>') {\n\n                    if (newStart < 0) {\n                        this.j = 0;\n                        this.imgStart = newStart;\n                        this.dist = newStart;\n                        //If user double clicks same button right away\n                    } else {\n                        this.imgStart = newStart;\n                        this.dist = -this.containerWidth() + newStart;\n                    }\n                }\n                this.start = 0;\n            } else {\n                this.start = 0;\n\n                if (target === '<') {\n                    //first click starts image outside the head\n                    this.j >= 1 ? this.imgStart = 0 : this.imgStart = this.containerWidth();\n                    this.dist = this.containerWidth();\n                } else {\n                    //first click starts image outside the head\n                    this.j >= 1 ? this.imgStart = 0 : this.imgStart = -this.containerWidth();\n                    this.dist = -this.containerWidth();\n                }\n\n                this.draw();\n            }\n        },\n        // load images into array to be used for slider\n        loadImages: function loadImages() {\n            for (var i = 0; i < designImages.length; i++) {\n                var element = designImages[i];\n                this.images.push(element);\n            }\n        }\n    };\n\n    // Keeps from resize event loading click handler\n    if (e.type !== 'resize' && e.type !== 'scroll') {\n\n        _('btnContainer').addEventListener('click', function (e) {\n            e.stopPropagation();\n            animateSlider.target = e.target;\n            animateSlider.animateData(e);\n\n            checkForClasses();\n            addElectricity();\n            updateText.toggleFalse();\n            _('text-field').textContent = '';\n        });\n    }\n\n    return [animateSlider, animateStars]; // To be used in the window.onload section\n};\n\nfunction DesignSlider() {\n    var img_container = document.getElementsByClassName('image-container')[0];\n    var img_container_rect = img_container.getBoundingClientRect();\n    this.ellipse = document.getElementsByClassName('clip-ellipse')[0];\n    this.rec = document.getElementsByClassName('screen-path')[0].getBoundingClientRect();\n    this.sectionContainer = document.getElementsByClassName('section-three-robot')[0].getBoundingClientRect();\n\n    var actualTop = this.rec.top - this.sectionContainer.top; //when page not fully scrolled into view it's the actual top\n\n    this.setEllipseAttributes = function () {\n        this.ellipse.setAttribute('rx', this.rec.width / 2);\n        this.ellipse.setAttribute('ry', this.rec.height / 2);\n        this.ellipse.setAttribute('cx', this.rec.left + this.rec.width / 2 - 5);\n        this.ellipse.setAttribute('cy', actualTop + this.rec.height / 2);\n    };\n    this.setImgContainer = function () {\n        var container_Width = this.rec.width / 9 + this.rec.width;\n        var img_containerY = actualTop - (img_container_rect.height - this.rec.height) / 2;\n        img_container.style.transform = 'translate(-50%,' + img_containerY + 'px)'; //-48% to make up for 53% robot-svg offset\n        img_container.style.width = container_Width + 'px';\n    };\n    this.setButtonLocation = function () {\n\n        var addedWidth = window.innerWidth < 768 ? 70 : 200; //Distance bigger than robot head\n\n        var x = (window.innerWidth - (this.rec.width + addedWidth)) / 2;\n        var y = window.innerWidth > 768 ? actualTop + this.rec.height / 2 - 25 : this.rec.bottom - this.sectionContainer.top; // - 25 for the btnContainer height / 2\n\n        _('btnContainer').style.width = this.rec.width + addedWidth + 'px';\n        _('btnContainer').style.transform = 'translate(' + x + 'px,' + y + 'px)';\n    };\n    return function () {\n\n        return [this.setEllipseAttributes(), this.setImgContainer(), this.setButtonLocation()];\n    }.bind(this);\n}\n\nwindow.addEventListener('resize', function (e) {\n\n    var updateRobot = robotSection(e);\n\n    var designSlider = new DesignSlider();\n    designSlider(); //updates canvas size\n    updateRobot[1](); //updates button, image location , attributes of robot\n});\n\n// **** ASSEMBLY LINE SECTION ****\n\nvar AssemblyLine = function () {\n    function AssemblyLine() {\n        _classCallCheck(this, AssemblyLine);\n\n        this.mainSVG = _('assembly-line-svg');\n        this.sliders = _('roller_unit');\n        this.codeContainers = _('code-container');\n    }\n\n    _createClass(AssemblyLine, [{\n        key: \"getRect\",\n        value: function getRect(el) {\n            var rect = el.getBoundingClientRect();\n            var bBox = el.getBBox();\n            return { rect: rect, bBox: bBox };\n        }\n    }, {\n        key: \"getElemValue\",\n        value: function getElemValue(pos) {\n            var _$exec = /[1-9].*/.exec(this.mainSVG.getAttribute('viewBox')),\n                _$exec2 = _slicedToArray(_$exec, 1),\n                size = _$exec2[0];\n\n            var regEx = /^(\\d{4})\\s(\\d{3})$/ig;\n            var values = [];\n            values.length = 0;\n            var length = this.sliders.length;\n            var rollerUnit = this.sliders;\n            var codeElements = this.codeContainers;\n            for (var i = 0; i < length; i++) {\n                var rollerElem = rollerUnit[i];\n                var codeElem = codeElements[i];\n\n                switch (pos) {\n                    case 'container':\n                        return slidersContainer;\n                    case 'viewBoxWidth':\n                        return size.replace(regEx, '$1');\n                    case 'viewBoxHeight':\n                        return size.replace(regEx, '$2');\n                    case 'el':\n                        values.push(rollerElem);\n                        break;\n                    case 'rectX':\n                        values.push(this.getRect(rollerElem).rect.x); // not in use\n                        break;\n                    case 'codeBox.x':\n                        values.push(this.getRect(codeElem).rect.x);\n                        break;\n                    case 'codebBox.x':\n                        values.push(this.getRect(codeElem).bBox.x);\n                        break;\n                    case 'bBoxX':\n                        values.push(this.getRect(rollerElem).bBox.x); // not in use\n                        break;\n                    case 'y':\n                        values.push(this.getRect(rollerElem).bBox.y);\n                        break;\n                    case 'width':\n                        values.push(this.getRect(rollerElem).bBox.width);\n                        break;\n                    case 'height':\n                        values.push(this.getRect(rollerElem).bBox.height);\n                        break;\n                }\n            }\n            return values;\n        }\n    }]);\n\n    return AssemblyLine;\n}();\n\n;\n\nvar RollerUnit = function (_AssemblyLine) {\n    _inherits(RollerUnit, _AssemblyLine);\n\n    function RollerUnit() {\n        _classCallCheck(this, RollerUnit);\n\n        var _this4 = _possibleConstructorReturn(this, (RollerUnit.__proto__ || Object.getPrototypeOf(RollerUnit)).call(this));\n\n        _this4.getRect = _this4.getRect;\n        _this4.draw = _this4.draw.bind(_this4);\n        _this4.beginPos = [];\n        _this4.dist = [];\n        _this4.lessThan = '';\n        _this4.start = 0;\n        _this4.time = 1000;\n        _this4.current = {};\n        _this4.click = 0;\n        _this4.beltClick = 0;\n        _this4.foreinObjs = _('assembly-img-foreignObj');\n        _this4.foreinGroup = _('assembly-img-wrap');\n        _this4.belts = _('belt');\n        return _this4;\n    }\n\n    _createClass(RollerUnit, [{\n        key: \"startPos\",\n        value: function startPos(elem) {\n            var arr = [];\n            var el = elem;\n            var length = el.length;\n            for (var i = 0; i < length; i++) {\n                if (el[i].hasAttribute('style')) {\n                    arr.push(parseInt(el[i].style.transform.replace(/^([\\w]*)\\(([?-\\d].*)px\\)/ig, \"$2\")));\n                } else {\n                    arr.push(0);\n                }\n            }\n            return arr;\n        }\n    }, {\n        key: \"min\",\n        value: function min(start) {\n            var actual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n            var rect = Math.min.apply(Math, _toConsumableArray(start));\n            var dist = Math.min.apply(Math, _toConsumableArray(actual));\n            var index = start.indexOf(rect);\n            return { index: index, dist: dist };\n        }\n    }, {\n        key: \"max\",\n        value: function max(start, actual) {\n            var rect = Math.max.apply(Math, _toConsumableArray(start));\n            var dist = Math.max.apply(Math, _toConsumableArray(actual));\n            var index = start.indexOf(rect);\n            return { index: index, dist: dist };\n        }\n    }, {\n        key: \"getDistance\",\n        value: function getDistance() {\n            var _this5 = this;\n\n            var width = this.getElemValue('width')[0];\n            var arr = [];\n            var startingPoint = this.getElemValue('codeBox.x');\n            var actualDist = this.getElemValue('codebBox.x');\n\n            var maxElement = this.max(startingPoint, actualDist);\n            var minElement = this.min(startingPoint, actualDist);\n\n            var moveEnd = function moveEnd(k) {\n                var dist = _this5.left ? 431 : -431; // moveBeginning dist * 2    \n                arr.push({ dist: dist, index: k });\n            };\n\n            var moveBeginning = function moveBeginning(k) {\n                var dist = _this5.left ? minElement.dist + width : -(minElement.dist + width);\n                var rightPageStart = _this5.left ? actualDist.reverse()[k] + width : -actualDist[k] - width;\n\n                _this5.lessThan = k; //Updates the smallest distance\n                arr.push({ dist: dist * 2, index: k, rightPageStart: rightPageStart, pageRight: true });\n            };\n\n            for (var k = 0; k < 3; k++) {\n\n                if (minElement.index === k) {\n                    this.right ? moveEnd(k) : moveBeginning(k);\n                } else if (maxElement.index === k) {\n                    this.right ? moveBeginning(k) : moveEnd(k);\n                } else {\n                    var dist = this.left ? 431 : -431; // moveBeginning dist * 2\n                    arr.push({ dist: dist, index: k });\n                }\n            }\n            arr.sort = function (a, b) {\n                return a.place - b.place;\n            };\n            return arr;\n        }\n\n        // Add and remove foreignObjects into slider\n\n    }, {\n        key: \"foreinObjArr\",\n        value: function foreinObjArr() {\n            // let length =  this.foreinObjs.length\n            var length = this.foreinGroup.length;\n            var arr = new Array(length);\n\n            // Puts image foreignobjects into array\n            while (length) {\n                length--;\n                arr[length] = this.foreinGroup[length];\n            }\n\n            var startingPoint = this.getElemValue('codeBox.x');\n            var index = this.min(startingPoint).index;\n\n            var add = arr.splice(3, 1);\n            var removed = arr.splice(index, 1);\n\n            var removedChild = removed[0].childNodes[1];\n            var addChild = add[0].childNodes[1];\n            arr.splice(index, 0, add[0]);\n            arr.push(removed[0]);\n\n            //Add and remove just transforms first\n            var styleTransform = removed[0].attributes[1];\n            removed[0].removeAttribute(styleTransform.name);\n            add[0].setAttribute(styleTransform.name, styleTransform.value);\n\n            //Strips attributes of removed and add same attributes to added foreignobject\n            while (removedChild.attributes.length > 1) {\n\n                var attrName = removedChild.attributes[1].name;\n                var attrValue = removedChild.attributes[1].value;\n\n                addChild.setAttribute(attrName, attrValue);\n                removedChild.removeAttribute(removedChild.attributes[1].name);\n            }\n\n            this.foreinGroup = arr;\n        }\n\n        // Ran once when page reloads\n\n    }, {\n        key: \"positionForiegnObject\",\n        value: function positionForiegnObject(_this) {\n            var sliders = this.codeContainers;\n            var foreignObjects = this.foreinObjs;\n            var length = sliders.length;\n\n            for (var i = 0; i < length; i++) {\n\n                var slider_x = this.getRect(this.codeContainers[i]).bBox.x;\n                var slider_y = this.getRect(this.codeContainers[i]).bBox.y;\n                var slider_width = this.getRect(this.codeContainers[i]).bBox.width;\n                var slider_height = this.getRect(this.codeContainers[i]).bBox.height;\n\n                foreignObjects[i].setAttribute('x', slider_x);\n                foreignObjects[i].setAttribute('y', slider_y);\n                foreignObjects[i].setAttribute('width', slider_width);\n                foreignObjects[i].setAttribute('height', slider_height);\n            }\n            //Inputs image into container\n            _this.targetElem();\n        }\n    }, {\n        key: \"moreThanHalf\",\n        value: function moreThanHalf(dist, positiveCurrent, startDist) {\n            return dist - (startDist - positiveCurrent);\n        }\n    }, {\n        key: \"lessThanHalf\",\n        value: function lessThanHalf(current, dist, startDist) {\n            var d = dist.dist < 0 ? dist.dist * -1 : dist.dist;\n\n            if (startDist === 0) {\n                if (dist.rightPageStart) {\n                    var diff = current - startDist;\n                    var totalDiff = d - (current - startDist);\n                    return diff + totalDiff;\n                }\n                return d - current;\n            } else {\n                if (dist.rightPageStart) {\n                    var _diff2 = current - startDist;\n                    var _totalDiff = d - Math.abs(current - startDist);\n                    return _diff2 + _totalDiff;\n                }\n                var _diff = d - Math.abs(current - startDist);\n                return _diff;\n            }\n        }\n    }, {\n        key: \"oppisiteDir\",\n        value: function oppisiteDir(current, startDist) {\n            if (startDist === 0) {\n                return current;\n            } else {\n                if (current > startDist) {\n                    // more than half\n                    return current - startDist;\n                }\n                return startDist - current; //less than half    \n            }\n        }\n    }, {\n        key: \"handleRightPageStart\",\n        value: function handleRightPageStart(d, rightPageStart, posCurrent, startDist) {\n\n            if (startDist < 0) {\n                //more than half\n                if (d > posCurrent) {\n                    var _distance = posCurrent;\n                    return { distance: _distance, pageRight: false\n                        //less than half\n                    };\n                }\n                var difference = 1141.2 - posCurrent;\n                var totalDif = d - (1141.2 - posCurrent);\n                var distance = difference + totalDif;\n                return { distance: distance, pageRight: true };\n            } else {\n\n                //less than half only element with a rightPageStart of 1141.2\n                if (rightPageStart > 1160) {\n                    //1160\n                    var _difference = d / 2 - posCurrent;\n                    var _totalDif = d - _difference;\n                    var _distance2 = _totalDif + _difference;\n                    return { distance: _distance2, pageRight: true\n                        //more than half\n                    };\n                } else if (posCurrent < startDist) {\n                    var _distance3 = startDist - posCurrent;\n                    return { distance: _distance3, pageRight: false\n                        //less than half \n                    };\n                } else {\n                    var diff = posCurrent - startDist;\n                    var totalDiff = d - (posCurrent - startDist);\n                    var _distance4 = diff + totalDiff;\n                    return { distance: _distance4, pageRight: true };\n                }\n            }\n        }\n        // ** RIGHT BUTTON IS NEGATIVE DIST, LEFT BUTTON IS POSITIVE DIST**\n\n    }, {\n        key: \"handleDoubleClick\",\n        value: function handleDoubleClick(current, dist, beginPos) {\n            //Updates how many times back and forth before animation finishes\n            this.click++;\n\n            var currentDirection = Math.sign(this.currentDist[1].dist);\n            var distDirection = Math.sign(dist[1].dist);\n\n            for (var i = 0; i < 3; i++) {\n\n                //Middle dist not equal both negative or positives then use current dist\n                var dist_i = currentDirection !== distDirection ? this.currentDist[i] : dist[i];\n                var d = dist_i.dist < 0 ? dist_i.dist * -1 : dist_i.dist; //changed this\n\n                //Starts off with positive variables\n                var rightPageStart = dist_i.rightPageStart < 0 ? dist_i.rightPageStart * -1 : dist_i.rightPageStart;\n                var startDist = beginPos[i] < 0 ? beginPos[i] * -1 : beginPos[i];\n                var posCurrent = current[i] < 0 ? current[i] * -1 : current[i];\n\n                // When clicked opposite direction\n                if (currentDirection !== distDirection) {\n\n                    if (rightPageStart) {\n                        var rightStart = this.right ? -rightPageStart : rightPageStart;\n\n                        var cur = this.handleRightPageStart(d, rightPageStart, posCurrent, startDist, this.currentDist[i].index);\n                        var curDist = this.right ? -cur.distance : cur.distance;\n                        var pageRight = cur.pageRight;\n\n                        this.dist.push({ dist: curDist, index: dist_i.index, rightPageStart: rightStart, pageRight: pageRight });\n                        this.beginPos.push(current[i]);\n                    } else {\n                        var distance = this.oppisiteDir(posCurrent, startDist);\n                        var _dist = this.right && distance > 0 ? -distance : distance;\n\n                        this.dist.push({ dist: _dist, index: dist_i.index, rightPageStart: dist_i.rightPageStart, pageRight: false });\n                        this.beginPos.push(current[i]);\n                    }\n                    //Clicked same direction\n                } else {\n                    //After element starts from hidden part of page\n                    if (this.right && rightPageStart && current[i] < 0 || this.left && current[i] > 0 && rightPageStart) {\n\n                        this.lessThan = dist_i.index; //have to update rightPageStart again due to running this.getDistance() twice\n                        var _distance5 = d / 2 - (rightPageStart - posCurrent);\n                        var PosOrNegDistance = this.right && _distance5 > 0 ? _distance5 * -1 : _distance5;\n\n                        this.dist.push({ dist: PosOrNegDistance, index: dist_i.index, rightPageStart: dist_i.rightPageStart, pageRight: false });\n                        this.beginPos.push(current[i]);\n                    } else {\n                        var lessThanhalf = startDist < posCurrent || startDist && posCurrent < d ? true : false;\n                        var _distance6 = lessThanhalf ? this.lessThanHalf(posCurrent, dist_i, startDist) : this.moreThanHalf(d, posCurrent, startDist);\n                        var _PosOrNegDistance = this.right ? -_distance6 : _distance6;\n\n                        this.dist.push({ dist: _PosOrNegDistance, index: dist_i.index, rightPageStart: dist_i.rightPageStart, pageRight: true });\n                        this.beginPos.push(current[i]);\n                    }\n                }\n            }\n            //Removes prior values in arrays\n            this.dist.splice(0, 3), this.beginPos.splice(0, 3);\n            console.log(this.dist, this.beginPos);\n        }\n        //Updates sliders positions\n\n    }, {\n        key: \"updatePos\",\n        value: function updatePos() {\n            // Handles back and forth clicking\n            if (this.start) {\n                this.start = 0;\n\n                this.currentDist = this.getDistance();\n                this.currentBeginPos = this.startPos(this.sliders);\n                return this.handleDoubleClick(this.current, this.dist, this.beginPos);\n            } else {\n                this.updateBeltPos();\n                this.beginPos.length = 0;\n                this.dist.length = 0;\n                var dist = this.getDistance();\n                var beginPos = this.startPos(this.sliders);\n                // 3 is length of slider elements\n                for (var i = 0; i < 3; i++) {\n\n                    this.beginPos.push(beginPos[i]);\n                    this.dist.push(dist[i]);\n                }\n                requestAnimationFrame(this.draw);\n            }\n        }\n    }, {\n        key: \"animateBelts\",\n        value: function animateBelts(topGears, bottomGears) {\n            _('teeth-wrapper-top').style.transform = \"translate(\" + topGears + \"px)\";\n            _('teeth-wrapper-bottom').style.transform = \"translate(\" + bottomGears + \"px)\";\n        }\n    }, {\n        key: \"animate\",\n        value: function animate(sliders, imgGroup, value) {\n            sliders.style.transform = \"translate(\" + value + \"px)\";\n            imgGroup.style.transform = \"translate(\" + value + \"px)\";\n        }\n    }, {\n        key: \"draw\",\n        value: function draw(timestamp) {\n            var time = this.time;\n            if (!this.start) this.start = timestamp;\n            this.runtime = timestamp - this.start;\n            var progress = Math.min(this.runtime / time, 1);\n\n            var j = this.lessThan;\n\n            for (var i = 0; i < 3; i++) {\n\n                var num = i !== j ? i : j;\n                var sliders = this.sliders[num];\n\n                var imgGroup = this.foreinGroup[num];\n\n                var beginPos = this.beginPos[num];\n                var dist = this.dist[num].dist;\n                var rightStart = this.dist[num].rightPageStart;\n                var pageRight = this.dist[num].pageRight;\n                //Right or Left side element animate to other side of screen\n                if (num === j && pageRight) {\n\n                    if (progress <= .5) {\n                        var value = beginPos - dist * progress;\n                        this.current[num] = value;\n                        this.animate(sliders, imgGroup, value);\n                    } else {\n                        var _value = rightStart - dist * (progress - .5);\n                        this.current[num] = _value;\n                        this.animate(sliders, imgGroup, _value);\n                    }\n                } else {\n                    var _value2 = beginPos - dist * progress;\n                    this.current[num] = _value2;\n                    this.animate(sliders, imgGroup, _value2);\n                }\n            }\n            // Belts Animation\n            var topGears = this.beltPos.startPos[0] + this.beltPos.dist * progress;\n            var bottomGears = this.beltPos.startPos[1] - this.beltPos.dist * progress;\n            this.animateBelts(topGears, bottomGears);\n            if (progress < 1) {\n                requestAnimationFrame(this.draw);\n            } else {\n                this.foreinObjArr();\n                this.start = 0;\n                this.beltClick++;\n                this.click = 0;\n                imgInlarge.targetElem();\n                return;\n            }\n        }\n        //Stars gears inline left or right depending on left or right click\n\n    }, {\n        key: \"beltDirections\",\n        value: function beltDirections() {\n            var beltWidth = _('bottom-main').getBBox().width;\n\n            if (this.right) {\n                _('bottom-teeth').style.transform = \"translate( \" + beltWidth + \"px )\";\n                _('top-teeth').style.transform = \"translate( \" + -beltWidth + \"px )\";\n            } else {\n                _('bottom-teeth').style.transform = \"translate( \" + -beltWidth + \"px )\";\n                _('top-teeth').style.transform = \"translate( \" + beltWidth + \"px )\";\n            }\n        }\n    }, {\n        key: \"updateBeltPos\",\n        value: function updateBeltPos() {\n            var belts = this.startPos(this.belts);\n            var startPos = void 0,\n                dist = void 0;\n\n            // Starts gears on one side of the page or the other \n            if (this.beltClick === 0 || this.beltClick && belts[0] === 0) this.beltDirections();\n\n            if (this.right) {\n                startPos = belts;\n                dist = _('top-teeth').getBBox().width / 3;\n            }\n            if (this.left) {\n                startPos = belts;\n                dist = -(_('top-teeth').getBBox().width / 3);\n            }\n\n            //Keeps Gears always looking like their never ending\n            if (this.beltClick === 3) {\n                this.beltClick = 0;\n                this.animateBelts(0, 0);\n                this.beltDirections();\n                startPos = [0, 0];\n            }\n            this.beltPos = { dist: dist, startPos: startPos };\n        }\n    }]);\n\n    return RollerUnit;\n}(AssemblyLine);\n\nvar InLargeImg = function (_RollerUnit) {\n    _inherits(InLargeImg, _RollerUnit);\n\n    function InLargeImg() {\n        _classCallCheck(this, InLargeImg);\n\n        var _this6 = _possibleConstructorReturn(this, (InLargeImg.__proto__ || Object.getPrototypeOf(InLargeImg)).call(this));\n\n        _this6.container = _('img-inlarge-container');\n        _this6.animateClipPath = _this6.animateClipPath.bind(_this6);\n        _this6.img = document.querySelector('.inlarge-img-wrap img');\n        _this6.imgWrap = document.getElementsByClassName('inlarge-img-wrap')[0];\n        _this6.mouseMove = _this6.mouseMove.bind(_this6);\n        _this6.removeListener = _this6.removeListener.bind(_this6);\n        _this6.mouseY = 0;\n        _this6.imageClose = _this6.imageClose.bind(_this6);\n        _this6.targetElem = _this6.targetElem;\n        _this6.checkForDuplicates = _this6.checkForDuplicates;\n        _this6.moveElement = _this6.moveElement;\n        _this6.Y = 0;\n        return _this6;\n    }\n\n    _createClass(InLargeImg, [{\n        key: \"addClickListener\",\n        value: function addClickListener() {\n            _('img-inlarge-container').addEventListener('click', this.imageClose);\n        }\n    }, {\n        key: \"removeClickListener\",\n        value: function removeClickListener() {\n            _('img-inlarge-container').removeEventListener('click', this.imageClose);\n        }\n    }, {\n        key: \"checkForDuplicates\",\n        value: function checkForDuplicates(clssName) {\n            var imgs = this.imgWrap.children;\n            var length = imgs.length;\n            while (length--) {\n                if (imgs[length].className === clssName) {\n                    this.img = imgs[length];\n                    this.removeImg();\n                }\n            }\n        }\n        //Recursion\n\n    }, {\n        key: \"targetElem\",\n        value: function targetElem(elemX) {\n\n            var length = this.foreinObjs.length;\n            var arr = [];\n            var groupArr = [];\n\n            for (var i = length - 1; i >= 0; i--) {\n\n                // 1st pushes only elements with style attribtues of x\n                if (!elemX && this.foreinObjs[i].hasAttribute('x')) {\n\n                    arr.push(this.foreinObjs[i].getBoundingClientRect().x);\n                    groupArr.push(this.foreinObjs[i].parentNode);\n                }\n                // Scaling image only\n                if (this.foreinObjs[i].parentNode.getBoundingClientRect().x === elemX && this.toggleMoveElement) {\n                    this.group = this.foreinObjs[i].parentNode;\n                    return;\n                }\n                if (this.foreinObjs[i].getBoundingClientRect().x === elemX) {\n                    this.checkForDuplicates('webVisible');\n                    var imgNode = this.foreinObjs[i].childNodes[1];\n                    var clonedImg = imgNode.cloneNode(true);\n                    return this.moveElement(clonedImg, 'webVisible');\n                }\n            }\n            // Middle element which is the median of the three elements\n            var sorted = arr.sort(function (a, b) {\n                return a - b;\n            })[1];\n            this.targetElem(sorted);\n        }\n    }, {\n        key: \"insertText\",\n        value: function insertText(img) {\n            var imgContent = _('img-content');\n            var url = img.attributes[2].value;\n            var text = img.attributes[1].textContent;\n            imgContent.textContent = text;\n            imgContent.innerHTML += '<br>' + '<a href=\"' + url + '\"> ' + url + ' </a>' + '</br>';\n        }\n    }, {\n        key: \"moveElement\",\n        value: function moveElement(el, cls) {\n            this.img = el; //updates image to be used elsewhere \n            el.classList.add(cls);\n            var img_content = _('img-content');\n            var fragment = document.createDocumentFragment();\n            fragment.appendChild(el);\n            this.imgWrap.insertBefore(fragment, img_content);\n            this.imgWrap.classList.add('show-img');\n            this.imgWrap.classList.remove('hide-img');\n        }\n    }, {\n        key: \"removeImg\",\n        value: function removeImg(e) {\n            var _this7 = this;\n\n            //Only ran to exit out of image from click handler\n            if (e) {\n                this.container.style.opacity = 0;\n                this.imgWrap.classList.replace('show-img', 'hide-img');\n                setTimeout(function () {\n                    _this7.imgWrap.classList.replace('hide-img', 'show-img');\n                    _this7.container.removeAttribute('style');\n                    _this7.img.style.display = 'none';\n                }, 1100);\n            } else {\n\n                _('img-content').textContent = '';\n                this.img.parentNode.removeChild(this.img);\n            }\n        }\n        // Removes images \n\n    }, {\n        key: \"imageClose\",\n        value: function imageClose(e) {\n            this.removeClickListener();\n            if (e.target.tagName !== 'IMG') {\n\n                this.removeImg(e);\n            }\n        }\n        // Displays image\n\n    }, {\n        key: \"showImage\",\n        value: function showImage(clssName) {\n            this.img = document.getElementsByClassName(clssName)[0];\n            this.insertText(this.img);\n            this.img.style.display = 'block';\n            this.addClickListener();\n            this.container.style.display = 'flex';\n            this.container.style.opacity = 1;\n        }\n        // **  REMOVE ANIMATECLIPPATH IF I DON'T REALLLY HAVE TO USE IT FOR FIREFOX **\n        //Firefox only\n\n    }, {\n        key: \"animateClipPath\",\n        value: function animateClipPath(timestamp) {\n            if (!this.start) this.start = timestamp;\n            this.runtime = timestamp - this.start;\n            var progress = Math.min(this.runtime / 1000, 1);\n            this.imgWrap.style.clipPath = \"circle(\" + (this.clipStart + this.clipValue * progress) + \"%)\";\n\n            if (progress < 1) {\n                requestAnimationFrame(this.animateClipPath);\n            } else {\n\n                if (this.container.style.opacity == 0) {\n\n                    // Removes flex and opacity, sets back to display none\n                    this.container.removeAttribute('style');\n                    // this.img.parentNode.removeChild(this.img)\n                }\n                this.start = 0;\n            }\n        }\n    }, {\n        key: \"getTransform\",\n        value: function getTransform() {\n            var regEx = /^scale/g;\n            var transform = this.group.style.transform.replace(/^(\\w*\\(-?\\d*.\\w*\\))(.*)/ig, \"$1\");\n            var checkForScale = transform.match(regEx);\n            //So two scale values don't get added to element when translate doesn't exist\n            if (checkForScale) {\n                return '';\n            } else {\n                return transform;\n            }\n        }\n    }, {\n        key: \"scalePhoto\",\n        value: function scalePhoto(dist, scale, translate) {\n            document.getElementById('slider_1_').style.transform = \"translateY(\" + dist + \"px)\";\n            this.group.style.transform = translate + (\"scale( \" + (1 + scale) + \" )\");\n        }\n    }, {\n        key: \"mouseMove\",\n        value: function mouseMove(e) {\n            // multipy by 1.5 because of the lag, so I speed it up just a bit\n            var dist = e.clientY - this.mouseY;\n            var value = dist / this.Y;\n            var scale = Math.min(value < 0 ? -value : -value, 1);\n            var translate = this.getTransform();\n            var translateValue = +translate.replace(/[^-\\d.]/ig, \"\");\n\n            //Checks if element is either -431 or 431 so the correct transform origin can be added\n            if (translateValue > 2) {\n                this.group.style.transformOrigin = 165 + \"px \" + 450 + \"px\";\n            } else if (translateValue < -1) {\n                this.group.style.transformOrigin = 1034 + \"px \" + 458 + \"px\";\n            }\n            //scale is 1 when clicked somewhere else\n            if (scale < 1 && dist <= 6) this.scalePhoto(dist, scale, translate);\n        }\n    }, {\n        key: \"mouseDown\",\n        value: function mouseDown(e) {\n\n            _('slide-group').addEventListener('mouseup', this.removeListener, true);\n\n            this.toggleMoveElement = true;\n            this.targetElem();\n            var verPiece = document.getElementById('vert_piece');\n            var vertY = verPiece.getBBox().y;\n            var handleY = _('img-scale').getBBox().y;\n\n            //Gets distance slider needs to go  \n            this.Y = handleY - vertY;\n\n            //Start position for distance\n            if (!this.mouseY) this.mouseY = e.clientY;\n            _('slide-group').addEventListener('mousemove', this.mouseMove, true);\n        }\n    }, {\n        key: \"removeListener\",\n        value: function removeListener(e) {\n            _('slide-group').removeEventListener('mousemove', this.mouseMove, true);\n\n            var translate = this.getTransform();\n            this.scalePhoto(0, 0, translate);\n\n            _('slide-group').removeEventListener('mouseup', this.removeListener, true);\n            _('img-scale').removeEventListener('mousedown', this.mouseDown, true);\n\n            //Updates position when mouseUp\n            this.mouseY = 0;\n            this.toggleMoveElement = false;\n        }\n    }]);\n\n    return InLargeImg;\n}(RollerUnit);\n\nvar rollerUnit = new RollerUnit();\nvar imgInlarge = new InLargeImg();\nrollerUnit.positionForiegnObject(imgInlarge);\n\n_('img-scale').addEventListener('mousedown', function (e) {\n\n    imgInlarge.mouseDown(e);\n}, true);\n\n_('buttons').addEventListener('click', function (e) {\n\n    e.stopPropagation();\n    var target = e.target.parentElement.classList[0];\n\n    if (target === 'img-left' || target === 'img-right') {\n        if (rollerUnit.click === 1) return;\n\n        rollerUnit.left = target === 'img-left' ? true : false;\n        rollerUnit.right = target === 'img-right' ? true : false;\n        rollerUnit.updatePos();\n    } else if (target === 'img-inlarge') {\n        imgInlarge.showImage('webVisible');\n    }\n});\n\ndocument.getElementById('button-inlarge').addEventListener('click', function (e) {\n    imgInlarge.showImage('designVisible');\n});\n\n// **** GRAPH SECTION ****\n\nvar random = function random(min, max) {\n    return Math.random() * (max - min) + min;\n};\n\nvar toggleRobot = {\n    toggle: false,\n    flight: false, //Toggles when scrolled out of screen view\n    direction: 'up'\n};\n\nfunction startRobotFlight() {\n    // *** Burners ***\n\n    var flames = _('robot-flame');\n    var length = flames.length;\n\n    var from = { x: 1, y: 1 };\n    var to = {};\n    var distance = {};\n    var keys = Object.keys(from);\n\n    var next = function next(timestamp) {\n        //starts all over from gets starting point of the last size\n        Object.assign(from, to);\n        var length = keys.length;\n        for (var i = 0; i < length; i++) {\n            var axis = keys[i];\n            to[axis] = random(.8, 1);\n            distance[axis] = from[axis] - to[axis];\n        }\n\n        time.start = timestamp;\n    };\n\n    var time = {\n        total: 40\n    };\n\n    var drawBurners = function drawBurners(timestamp) {\n        if (toggleRobot.flight) return;\n        if (time.runtime > time.total || !to.x) next(timestamp);\n\n        time.runtime = timestamp - time.start;\n        var progress = time.runtime / time.total;\n\n        var _keys$map = keys.map(function (axis) {\n            return from[axis] - progress * distance[axis];\n        }),\n            _keys$map2 = _slicedToArray(_keys$map, 2),\n            x = _keys$map2[0],\n            y = _keys$map2[1];\n\n        for (var i = 0; i < length; i++) {\n            var flame = flames[i];\n            flame.style.transform = \"scale(\" + x + \", \" + y + \")\";\n        }\n        requestAnimationFrame(drawBurners);\n    };\n\n    //*** Draws Stars ***\n    var graphs = document.getElementsByClassName('graph-st20');\n    var recClip = document.getElementsByClassName('rec-clip')[0];\n    var fragment = document.createDocumentFragment();\n    var robotRect = _('floating_robot').getBoundingClientRect();\n    var graph = document.getElementById('graph-svg');\n\n    var _$exec3 = /[1-9].*/.exec(graph.getAttribute('viewBox')),\n        _$exec4 = _slicedToArray(_$exec3, 1),\n        size = _$exec4[0];\n\n    var regEx = /([1-9.]*)\\s([1-9.].*)/ig;\n    var graphWidth = size.replace(regEx, '$1');\n    var graphHeight = size.replace(regEx, '$2');\n\n    var robotHeight = robotRect.height;\n    var robotWidth = robotRect.width;\n    var startY = graphHeight - robotHeight;\n    var startX = robotRect.x - (window.innerWidth - graphWidth) / 2;\n\n    //starts stars randomly\n    var randomInterval = function randomInterval(callback, data, min, max) {\n\n        var time = {\n            start: performance.now(),\n            total: random(min, max)\n        };\n        var draw = function draw(timestamp) {\n            if (toggleRobot.flight) return;\n            if (time.total <= timestamp - time.start) {\n                time.start = timestamp;\n                time.total = random(min, max);\n                callback(data);\n            }\n            requestAnimationFrame(draw);\n        };\n        requestAnimationFrame(draw);\n    };\n\n    var createStar = function createStar(cx, cy, radius) {\n        var star = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n        star.setAttribute(\"r\", radius);\n        star.setAttribute(\"cy\", cy);\n        star.setAttribute(\"cx\", cx);\n        star.setAttribute(\"fill\", \"white\");\n        star.setAttribute(\"fill-opacity\", 0);\n        return star;\n    };\n\n    var FallingStars = function FallingStars(data) {\n\n        var attr = new data(toggleRobot.direction);\n\n        var radius = attr.radius;\n        var cx = attr.cx;\n        var cy = attr.cy;\n        var dist = attr.dist;\n        var star = createStar(cx, cy, radius);\n\n        var time = {\n            start: performance.now(),\n            total: random(1900, 2000)\n        };\n\n        var draw = function draw(timestamp) {\n            if (toggleRobot.toggle || toggleRobot.flight) {\n                graph.removeChild(star);\n                return;\n            }\n            time.elapsed = timestamp - time.start;\n            var progress = Math.min(time.elapsed / time.total, 1);\n\n            var opacity = progress * 2;\n\n            star.setAttribute(\"cy\", cy + progress * dist);\n            star.setAttribute(\"fill-opacity\", progress < .5 ? opacity : 2 - opacity);\n            time.elapsed < time.total ? requestAnimationFrame(draw) : graph.removeChild(star);\n        };\n        requestAnimationFrame(draw);\n\n        //Inserts new star based on randomInterval runing throughStars()\n        fragment.appendChild(star);\n        graph.insertBefore(fragment, graph.firstChild);\n    };\n\n    var flyIntoPlace = {\n        beginY: graphHeight - robotHeight / 12,\n        hiddenX: function hiddenX() {\n            var difference = graphWidth - wW;\n            if (!wW < graphWidth) {\n\n                return robotRect.width + robotRect.x + difference;\n            }\n        },\n        hideRobot: function hideRobot(size) {\n            if (size === 1.3) {\n                var beginX = this.hiddenX();\n                _('floating_robot').style.transform = \"translate(\" + 0 + \"px, -\" + this.beginY + \"px)\";\n            }\n        },\n        createStars: function createStars() {\n            var attributes = function attributes(direction) {\n\n                if (direction === 'down') {\n\n                    toggleRobot.toggle = false;\n                    var radius = random(.5, 2.7);\n                    var cx = random(startX - 100, startX + robotWidth + 100);\n                    var cy = random(startY - 120, startY - 175);\n                    var dist = 100 + robotHeight;\n\n                    return { radius: radius, cx: cx, cy: cy, dist: dist };\n                } else if (direction === 'up') {\n\n                    var _radius = random(1.5, 3.7);\n                    var _cx = random(0 - 25, graphWidth + 25);\n                    var _cy = random(graphHeight - 80, graphHeight + 50);\n                    var _dist2 = -graphHeight;\n\n                    return { radius: _radius, cx: _cx, cy: _cy, dist: _dist2 };\n                }\n            };\n            //Every 80ms through 180ms of time.total it will draw a star\n            //**** STARTS STARS MOVING *****\n            randomInterval(FallingStars, attributes, 80, 180);\n        }\n    };\n\n    var graphData = {\n        start: 0,\n        total: 2000\n    };\n    var subtractRay = function subtractRay() {\n        _('left-text-panel').removeAttribute('clip-path');\n        _('rec-clip').style.transform = \"translate(485px, 520px)\";\n    };\n    var getStrokeLength = function getStrokeLength() {\n        var i = graphs.length;\n        var value = new Array(i);\n        function getLength() {\n            while (i--) {\n                value[i] = graphs[i].getTotalLength();\n            }\n        }\n        return {\n            runValue: function runValue() {\n                getLength();\n            },\n            getValue: function getValue() {\n                return value;\n            }\n        };\n    };\n    var strokeLength = getStrokeLength();\n    strokeLength.runValue();\n\n    var drawPercentStroke = function drawPercentStroke(progress) {\n        var stroke = strokeLength.getValue();\n        var i = graphs.length;\n        while (i--) {\n            graphs[i].style.stroke = 'url(#design-gradient)';\n\n            graphs[0].style.strokeDashoffset = stroke[0] + stroke[0] * progress;\n            graphs[1].style.strokeDashoffset = stroke[1] - stroke[1] * progress;\n        }\n    };\n    var animateGraph = function animateGraph(timestamp) {\n        if (!graphData.start) graphData.start = timestamp;\n        var runtime = timestamp - graphData.start;\n        var progress = Math.min(runtime / graphData.total, 1);\n\n        _('graph-percentage-top').textContent = Math.round(0 + 90 * progress) + ' %';\n        _('graph-percentage-bottom').textContent = Math.round(0 + 70 * progress) + ' %';\n        _('graph-rect').style.transform = 'translate(' + 412 * progress + 'px)';\n        drawPercentStroke(progress);\n\n        if (progress < 1) requestAnimationFrame(animateGraph);else return subtractRay();\n    };\n\n    var startAnimateGraph = function startAnimateGraph() {\n        recClip.style.transform = 'translate(0px, 0px)';\n        _('graph-clipping').classList.add('show-graphs');\n\n        //Animate graphs after recClip transform is done\n        setTimeout(function () {\n            requestAnimationFrame(animateGraph);\n        }, 2500);\n    };\n\n    var begin = {\n        start: 0,\n        total: 4000\n    };\n\n    var flyIn = function flyIn(timestamp) {\n        if (!begin.start) begin.start = timestamp;\n        begin.runtime = timestamp - begin.start;\n        var progress = Math.min(begin.runtime / begin.total, 1);\n        var curve = 624.9 / 2;\n        var ease = easeOut(progress);\n        var increment = curve * progress / 50;\n\n        var y = -flyIntoPlace.beginY + flyIntoPlace.beginY * progress;\n        var x = -Math.cos(increment + Math.PI / 180) * curve + curve;\n        // !begin.toggle\n        _('floating_robot').style.transform = \"translate(\" + -x + \"px, \" + y + \"px)\";\n        // : document.querySelector('#section-five-web .container-lg').style.transform = `scale(${1.3 - .3 * ease})`\n\n        if (progress === 1) {\n            // toggleRobot.toggle = true;\n            toggleRobot.direction = 'down';\n\n            //Resizes the whole container so robot fits into screen\n            if (wW > 1050) {\n                setTimeout(startAnimateGraph, 600);\n                document.querySelector('#section-five-web .container-lg').classList.add('scale-container');\n            } else {\n\n                startAnimateGraph();\n            }\n            return;\n        }\n        requestAnimationFrame(flyIn);\n    };\n    return { flyIn: flyIn, flyIntoPlace: flyIntoPlace, drawBurners: drawBurners };\n}\n\nvar navToggle = {\n    toggle: true\n};\n\nvar Navigation = function () {\n    function Navigation() {\n        _classCallCheck(this, Navigation);\n\n        this.navItems = document.querySelectorAll('.nav-list button');\n        this.scrollTo = this.scrollTo.bind(this);\n        this.animateScroll = this.animateScroll.bind(this);\n        this.start = 0;\n    }\n\n    _createClass(Navigation, [{\n        key: \"getDistance\",\n        value: function getDistance(el) {\n\n            var top = el.getBoundingClientRect().top;\n            var height = el.getBoundingClientRect().height;\n            var bottom = el.getBoundingClientRect().bottom;\n            return { top: top, height: height, bottom: bottom };\n        }\n    }, {\n        key: \"getScrolltoElement\",\n        value: function getScrolltoElement(target, regEx) {\n            var section = document.getElementsByTagName('section');\n            var length = section.length;\n            while (length--) {\n                if (target === section[length].id.replace(regEx, \"$1\")) {\n                    return {\n                        el: section[length],\n                        index: length\n                    };\n                }\n            }\n        }\n    }, {\n        key: \"outExpo\",\n        value: function outExpo(n) {\n            return 1 == n ? n : 1 - Math.pow(2, -10 * n);\n        }\n    }, {\n        key: \"animateScroll\",\n        value: function animateScroll(timestamp) {\n            if (!this.start) this.start = timestamp;\n            var runtime = timestamp - this.start;\n            var progress = this.outExpo(Math.min(runtime / 1200, 1));\n            var y = this.startPos + this.elDist * progress;\n\n            window.scroll(0, y);\n            if (progress < 1) {\n                requestAnimationFrame(this.animateScroll);\n            } else return navToggle.toggle = true;\n        }\n    }, {\n        key: \"toggleOpenBtn\",\n        value: function toggleOpenBtn() {\n            var i = this.navItems.length;\n            while (i--) {\n\n                if (this.navItems[i].style.transform) {\n                    console.log(this.navItems[i].removeAttribute('style'));\n                }\n            }\n        }\n    }, {\n        key: \"scrollTo\",\n        value: function scrollTo(e) {\n            this.toggleOpenBtn();\n            if (e.target.className === 'contact-modal') return;\n            var regEx = /(\\w+\\-\\w+)\\-\\w+/ig;\n            var sectionId = e.target.className.replace(regEx, \"$1\");\n\n            var scrollToElem = this.getScrolltoElement(sectionId, regEx).el;\n            var index = this.getScrolltoElement(sectionId, regEx).index;\n            var elDist = this.getDistance(scrollToElem, index).top;\n            this.elDist = elDist;\n            this.startPos = window.pageYOffset;\n            this.start = 0;\n\n            requestAnimationFrame(this.animateScroll);\n        }\n    }, {\n        key: \"scrollTo768\",\n        value: function scrollTo768(e) {\n\n            var targetBtn = e.target.parentNode.parentNode;\n            console.log(targetBtn);\n\n            if (targetBtn.hasAttribute('style')) {\n                return this.toggleOpenBtn();\n            }\n            this.toggleOpenBtn();\n            targetBtn.style.pointerEvents = 'auto';\n            targetBtn.style.transform = \"translateX(\" + -130 + \"px)\";\n        }\n    }, {\n        key: \"controller\",\n        value: function controller() {\n            var _this8 = this;\n\n            _('nav-list').addEventListener('click', function (e) {\n                console.log(e.target);\n                navToggle.toggle = false;\n                if (e.target.nodeName === \"BUTTON\") {\n\n                    _this8.scrollTo(e);\n                }\n                // Only @ screen size 768 and smaller\n                if (e.target.parentNode.classList[1] === 'nav-icon') {\n\n                    _this8.scrollTo768(e);\n                }\n            });\n        }\n    }]);\n\n    return Navigation;\n}();\n\nvar navigation = new Navigation();\nnavigation.controller();\n\nvar toggleAnimate = {\n    stars: true,\n    flightStars: true,\n    circuit: true\n    // circuitToggle.toggleAnim = false\n};var robot = new robotSection('event');\nvar robotFlight = startRobotFlight();\n\nvar triggerStars = function triggerStars(e) {\n    console.log(e.type);\n    var update = robot[1](e).update;\n    var star_count = 25;\n    var makeStars = robot[1]();\n    makeStars.createStars(star_count, update);\n};\n\nvar ScrollAnimate = function (_Navigation) {\n    _inherits(ScrollAnimate, _Navigation);\n\n    function ScrollAnimate() {\n        _classCallCheck(this, ScrollAnimate);\n\n        var _this9 = _possibleConstructorReturn(this, (ScrollAnimate.__proto__ || Object.getPrototypeOf(ScrollAnimate)).call(this));\n\n        _this9.sections = document.querySelectorAll('.section-three-robot, #section-five-web, #section-one-digital, #section-two-popups');\n        return _this9;\n    }\n\n    _createClass(ScrollAnimate, [{\n        key: \"checkElemTop\",\n        value: function checkElemTop(e) {\n            var length = this.sections.length;\n\n            while (length--) {\n                var dist = this.getDistance(this.sections[length]);\n                var elmTop = dist.top;\n                var elmHeight = dist.height;\n                var elmBottom = dist.bottom;\n\n                //Digital Hand\n                if (length === 0) {\n\n                    if (elmBottom < 100) toggleAnimate.circuit = false;\n                }\n                //Map\n                if (length === 1) {\n                    var pointerLocation = _('oval-pointer').getBoundingClientRect().x;\n\n                    //Stops scroll from running hovermap function over and over\n                    if (pointerLocation > 0) {\n                        var hovermap = hoverMap();\n                        var _dist3 = hovermap[1](e)[0]; // Position distance of show-icon gooey\n                        hovermap[0](_dist3, true); // handler(e) function remove gooey\n                    }\n                }\n                // Robot Design stars element\n                if (length === 2) {\n\n                    //Page in view start animate stars\n                    if (elmTop <= elmHeight && elmBottom >= elmHeight && toggleAnimate.stars) {\n\n                        toggleAnimate.stars = false;\n                        toggleStars.toggle = false;\n                        // triggerStars(e)\n                    }\n                    //Page out of view start stop animate\n                    if (!toggleAnimate.stars && (elmTop > elmHeight || elmBottom <= 0)) {\n                        toggleAnimate.stars = true;\n                        toggleStars.toggle = true;\n                    }\n                }\n                //Flying Robot / Graph element\n                if (length === 3) {\n\n                    if (elmTop < elmHeight / 2 && elmBottom >= elmHeight && toggleAnimate.flightStars) {\n                        toggleRobot.flight = false;\n                        toggleAnimate.flightStars = false;\n                        requestAnimationFrame(robotFlight.drawBurners);\n                        robotFlight.flyIntoPlace.createStars('up');\n                        requestAnimationFrame(robotFlight.flyIn);\n                    }\n                    if (!toggleAnimate.flightStars && (elmTop > elmHeight - 75 || elmBottom <= 0)) {\n\n                        //Removes ray\n                        _('rec-clip').style.display = \"none\";\n                        toggleAnimate.flightStars = true;\n                        toggleRobot.flight = true;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"scroll\",\n        value: function scroll() {\n            var _this10 = this;\n\n            window.addEventListener('scroll', function (e) {\n                // If nav item is clicked that scroll event will run and not trigger this scroll event\n                if (navToggle.toggle) {\n\n                    _this10.checkElemTop(e);\n                }\n            });\n        }\n    }]);\n\n    return ScrollAnimate;\n}(Navigation);\n\nvar scrollAnimate = new ScrollAnimate();\nscrollAnimate.scroll();\n\n//*** HAND SHAKE ***\n\nvar Digital = function () {\n    function Digital() {\n        _classCallCheck(this, Digital);\n\n        this.path = document.querySelectorAll('.stroke');\n        this.watch = document.getElementById('rotate_watch');\n    }\n\n    _createClass(Digital, [{\n        key: \"startHandAnimation\",\n        value: function startHandAnimation() {\n            var _this11 = this;\n\n            this.watch.classList.add('rotateWatch');\n            for (var i = 0; i < this.path.length; i++) {\n                console.log(this.path[i].getTotalLength());\n                this.path[i].classList.add('path');\n            }\n            //Removes animation after 4 intervals \n            setTimeout(function () {\n                _this11.removeDigitalAnimation();\n            }, 8100);\n        }\n    }, {\n        key: \"removeDigitalAnimation\",\n        value: function removeDigitalAnimation() {\n            this.watch.classList.remove('rotateWatch');\n            for (var i = 0; i < this.path.length; i++) {\n                this.path[i].classList.remove('path');\n            }\n        }\n    }]);\n\n    return Digital;\n}();\n\nvar circuitToggle = {\n    toggleAnim: true\n};\n\nvar Circuit = function () {\n    function Circuit() {\n        _classCallCheck(this, Circuit);\n\n        this.animCircuit = _('animate-circuit');\n        this.startAnimation = this.startAnimation.bind(this);\n        this.speed = [];\n        this.elements = [];\n        this.index = [];\n        this.pathLength = [];\n    }\n    //SVG .getTotalLength() fix\n\n\n    _createClass(Circuit, [{\n        key: \"getSvgPolylineLength\",\n        value: function getSvgPolylineLength(el) {\n            var totalLength = 0;\n            var prevPos = void 0;\n            for (var i = 0; i < el.points.numberOfItems; i++) {\n                var pos = el.points.getItem(i);\n                if (i > 0) {\n                    totalLength += Math.sqrt(Math.pow(pos.x - prevPos.x, 2) + Math.pow(pos.y - prevPos.y, 2));\n                }\n                prevPos = pos;\n            }\n            return totalLength;\n        }\n        //SVG .getTotalLength() fix\n\n    }, {\n        key: \"getSvgEementLength\",\n        value: function getSvgEementLength(el) {\n            var constructor = el.constructor;\n\n            switch (constructor) {\n                case SVGPolylineElement:\n                    return this.getSvgPolylineLength(el);\n                case SVGLineElement:\n                    return function (x1, x2, y1, y2) {\n                        return Math.sqrt((x2 -= x1) * x2 + (y2 -= y1) * y2);\n                    }(el.getAttribute('x1'), el.getAttribute('x2'), el.getAttribute('y1'), el.getAttribute('y2'));\n                case SVGRectElement:\n                    return el.getAttribute('width') * 2 + el.getAttribute('height') * 2;\n                case SVGPathElement:\n                    return el.getTotalLength();\n            }\n        }\n        //3rd method ran\n\n    }, {\n        key: \"getDashStroke\",\n        value: function getDashStroke(el) {\n\n            var length = el.length;\n            while (length--) {\n                var index = el[length];\n                try {\n                    // Fix for SVG.getTotalLength()  not working on some paths. \n                    this.pathLength.unshift(this.getSvgEementLength(_('animate-circuit')[index]));\n                } catch (err) {\n                    console.log(err);\n                }\n            }\n        }\n    }, {\n        key: \"addClasses\",\n        value: function addClasses() {\n            var length = this.elements.length;\n            while (length--) {\n                this.elements[length].classList.add('animatePath');\n            }\n        }\n        //2nd method ran\n\n    }, {\n        key: \"getRandomPath\",\n        value: function getRandomPath(count) {\n\n            var i = 0;\n            var length = count;\n\n            while (i < length) {\n\n                // item is the long-path which is at index 0 if count === 1, else run random \n                var item = Math.floor(Math.random() * 10);\n\n                //Checks first to make sure no duplicate items in array\n                var notInArray = this.index.indexOf(item) === -1;\n\n                if (notInArray) {\n                    i++;\n                    this.index.push(item);\n                    this.elements.push(_('animate-circuit')[item]);\n                }\n            }\n\n            this.animCircuit = this.elements;\n            return this.index;\n        }\n        //4th method ran\n\n    }, {\n        key: \"addData\",\n        value: function addData(index) {\n\n            this.speed.push({ speed: 0, j: 0, delay: 25 * index });\n        }\n        //1st method ran\n\n    }, {\n        key: \"setDashArray\",\n        value: function setDashArray(count) {\n            var index = this.getRandomPath(count);\n\n            var i = index.length;\n            this.getDashStroke(index);\n\n            while (i--) {\n\n                this.animCircuit[i].style.stroke = 'orange';\n                this.animCircuit[i].style.strokeDashoffset = -this.pathLength[i];\n                this.animCircuit[i].style.strokeDasharray = this.pathLength[i];\n\n                this.addData(count);\n\n                if (i === 0) this.startAnimation();\n            }\n        }\n        //Ran last\n\n    }, {\n        key: \"startAnimation\",\n        value: function startAnimation() {\n            var dist = this.pathLength;\n            var el = this.animCircuit;\n            var duration = this.speed;\n            var length = el.length;\n            var countSpeed = 5;\n\n            function draw() {\n                //Removes Animation\n                if (!toggleAnimate.circuit) {\n                    var i = el.length;\n\n                    while (i--) {\n                        el[i].removeAttribute('style');\n                    }\n                    return;\n                }\n\n                for (var _i3 = length - 1; _i3 >= 0; _i3--) {\n                    var dashArray = el[_i3].style.strokeDasharray;\n                    var dashOffset = el[_i3].style.strokeDashoffset;\n\n                    // StrokeDashoffset is less then 0 runs same direction \n                    if (dashOffset >= 0 && !duration[_i3].j) {\n                        duration[_i3].speed = 0;\n                        duration[_i3].j = 1;\n                        _iterator4 = 0;\n                    }\n\n                    var speed = duration[_i3].speed += countSpeed;\n                    var _iterator4 = dashOffset <= 0 ? -dist[_i3] : 0;\n\n                    //Stops strokedasharray at about a 3rd to keep the length that size\n                    if (dashArray >= dist[_i3] / 1.8) {\n\n                        el[_i3].style.strokeDasharray = dist[_i3] - speed;\n                    }\n\n                    el[_i3].style.strokeDashoffset = _iterator4 + speed;\n                }\n                requestAnimationFrame(draw);\n            }\n            requestAnimationFrame(draw);\n        }\n    }]);\n\n    return Circuit;\n}();\n\ncircuitToggle.toggleAnim = false;\n\nwindow.onload = function (e) {\n    var digital = new Digital();\n    var circuit = new Circuit();\n\n    // circuit.setDashArray(6)\n    digital.startHandAnimation();\n\n    var newTechnologies = new Technologies();\n    newTechnologies.loadImages();\n\n    document.querySelector('.technologies .start-canvas').addEventListener('click', function () {\n        Technologies.prototype.toggle = true;\n        requestAnimationFrame(newTechnologies.draw.bind(newTechnologies));\n    }.bind(this));\n\n    document.querySelector('.technologies .stop-canvas').addEventListener('click', function () {\n        Technologies.prototype.toggle = false;\n        requestAnimationFrame(newTechnologies.draw.bind(newTechnologies));\n    }.bind(this));\n\n    var starryNight = new StarryNight();\n    starryNight.loadImages();\n\n    hoverMap();\n\n    var designSlider = new DesignSlider();\n    designSlider();\n\n    robot[1](); //updates robot location\n    robot[0].loadImages(); //then loades images into slider\n\n    robotFlight.flyIntoPlace.hideRobot(1.3); //Hides flying robot out of screen view\n\n}.bind(undefined);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbWFpbi5qcz8yZWUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqKioqKiAgR0xPQkFMIFZBUklBQkxFUyAgKioqKioqKi8gXG5jb25zdCBhbmltYXRlNzY4ID0gXCJNNTY1LjEsMHY5MDBIMGMwLDAsMC03NS4zLDAtMTkyLjRjMC0yMTEuNywwLTMwMy43LDAtNTMzLjFDMCw1MC41LDAsMCwwLDBINTY1LjF6O1wiK1xuICAgICAgICAgICAgICAgICBcIk01NjUuMSwwdjkwMEgxODIuN2MwLDAtNDQtNzIuNS00NC0xOTEuN2MwLTEwNy41LDEyMS44LTM5Ni4xLDEyMS44LTUzMy44QzI2MC41LDQxLDI0NS45LDAsMjQ1LjksMEg1NjUuMXo7XCIrXG4gICAgICAgICAgICAgICAgIFwiTTU3MS44LDB2OTAwSDM4Ni43YzAsMC0zMS40LTQyLjctMzEuNC0xOTEuN0MzNTUuMyw1NjgsNTU1LDI4NSw1NTUsODAuN0M1NTUsMjAsNTUxLjUsMCw1NTEuNSwwSDU3MS44ejtcIitcbiAgICAgICAgICAgICAgICAgXCJNNTczLDB2OTAwaC0yLjNjMCwwLDAuNC02NS4yLDAuNC0xOTIuNGMwLTE3Ni44LTAuMi0zNDcuOS0wLjItNTMzLjRjMC0xMjQtMC4yLTE3NC4yLTAuMi0xNzQuMkg1NzN6XCI7XG5cbmNvbnN0IGFuaW1hdGU0MDAgPSBcIk0zOTAsODAwSDZjMCwwLTYtNDUuOS02LTE2MS4zQzAsNDQzLjYsNSwyODYuMSw1LDQ3LjNDNSwxMC43LDMsMCwzLDBoMzg3VjgwMHo7XCIrXG4gICAgICAgICAgICAgICAgIFwiTTM5MCw4MDBIOTZjMCwwLTQ2LTQ1LjktNDYtMTYxLjNjMC0xOTUuMSwxMzAtMzUyLjYsMTMwLTU5MS4zYzAtMzYuNy0zLTQ3LjMtMy00Ny4zaDIxM1Y4MDB6O1wiK1xuICAgICAgICAgICAgICAgICBcIk0zOTAsODAwSDI0M2MwLDAtMzctNDUuOS0zNy0xNjEuM2MwLTE5NS4xLDE3Ni0zNTIuNiwxNzYtNTkxLjNjMC0zNi43LTEtNDcuMy0xLTQ3LjNoOVY4MDB6O1wiK1xuICAgICAgICAgICAgICAgICBcIk0zOTAsODAwaC03YzAsMCwwLTQ1LjksMC0xNjEuM2MwLTE5NS4xLDUtMzUyLjYsNS01OTEuM2MwLTM2LjctMS00Ny4zLTEtNDcuM2gzVjgwMHpcIjtcblxuY29uc3QgaXNGaXJlZm94ID0gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGlzU2FmYXJpID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiU2FmYXJpXCIpICE9IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkNocm9tZVwiKSA9PT0gLTE7XG4vL0lmIHVzZXIgaXMgb24gaXBhZCAvIGlwaG9uZSAvIGlwb2RcbmxldCBpc0lPUyA9IGZ1bmN0aW9uKCl7XG4gICAgbGV0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmE7XG4gICAgcmV0dXJuIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KHVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbVxufVxuXG5jb25zdCB3VyA9IHdpbmRvdy5pbm5lcldpZHRoO1xuY29uc3Qgd0ggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5sZXQgbGFzdERpc3Q7XG5cblxuXG5cbi8vRmlyZWZveCBCdWcsIHRyYW5zZm9ybXMgbm90IHdvcmtpbmcsIHNvIHNldHMgYXR0cmlidXRlIHRvIDAgaW5zdGVhZFxuaWYoaXNGaXJlZm94KXtcbiAgICAvL3N2ZyBtb3JmaW5nIHByb2JsZW1cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZmVHYXVzc2lhbkJsdXInKVswXS5zZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicsICc2JylcbiAgICAvL3N2ZyBjc3MgcHJvYmxlbVxuICAgIF8oJ3N2Zy1jaXJjbGUnKS5zZXRBdHRyaWJ1dGUoJ3InLCAwKTtcbiAgICBfKCdzdmctY2lyY2xlJykuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKDEpJ1xufSBcblxuaWYoaXNTYWZhcmkpIF8oJ3N2Zy1wYWdlJykuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCJcblxuZnVuY3Rpb24gXyhjbHNzKXtcblxuICAgIGxldCBjbGFzc2VzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbHNzKTtcblxuICAgIGlmKGNsYXNzZXMubGVuZ3RoID09PSAxKXtcbiAgICAgICAgcmV0dXJuIGNsYXNzZXNbMF1cbiAgICB9XG4gICAgaWYoY2xhc3Nlcy5sZW5ndGggPiAxKXtcbiAgICAgICAgcmV0dXJuIGNsYXNzZXNcbiAgICB9ZWxzZSByZXR1cm4gXCJOb3QgYSB3b3JraW5nIGNsYXNzXCJcbn07XG5cbnZhciBlYXNlT3V0ID0gZnVuY3Rpb24ocHJvZ3Jlc3Mpe1xuICAgIHJldHVybiBNYXRoLnBvdygtLXByb2dyZXNzLCA1KSArIDE7XG59O1xuXG4vL1N0cmluZzogaW5kaWNhdGVzIG5ldyBzaXplIG9mIHdpZHRoIG9yIGhlaWdodCB0aGF0IHlvdSB3YW50LiBTaXplOiBvZiB0aGUgbmV3IHNpemUgb2YgdGhlIHN0cmluZy4gRWw6IHRoZSBlbGVtZW50IHlvdSB3YW50IGl0IGZvclxudmFyIG5ld1NpemUgPSBmdW5jdGlvbihzdHJpbmcsIHNpemUsIGVsKXtcbiAgICBpZih0eXBlb2YgZWwgICE9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgIFxuXG4gICAgICAgIHZhciBvZ1dpZHRoID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcbiAgICAgICAgdmFyIG9nSGVpZ2h0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgICAgIGlmKG9nV2lkdGggPT09IDAgfHwgb2dIZWlnaHQgPT09IDApe1xuICAgICAgICAgICAgb2dXaWR0aCA9IGVsLmdldEF0dHJpYnV0ZSgnd2lkdGgnKVxuICAgICAgICAgICAgb2dIZWlnaHQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpXG4gICAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgICAgdmFyIG9nV2lkdGggPSA3NjIuMjJcbiAgICAgICAgdmFyIG9nSGVpZ2h0ID0gNjY4Ljk3XG4gICAgfVxuICAgIFxuICAgIGlmKHN0cmluZyA9PT0gJ2hlaWdodCcgKXtcbiAgICAgICAgbGV0IHJhdGlvID0gb2dIZWlnaHQgLyBzaXplXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICAgICAgICB3aWR0aDogb2dXaWR0aCAvIHJhdGlvXG4gICAgICAgIH1cblxuICAgIH1lbHNlIGlmKHN0cmluZyA9PT0gJ3dpZHRoJyApe1xuICAgICAgICBsZXQgcmF0aW8gPSBvZ1dpZHRoIC8gc2l6ZVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHNpemUsXG4gICAgICAgICAgICBoZWlnaHQ6IG9nSGVpZ2h0IC8gcmF0aW9cbiAgICAgICAgfVxuICAgIH1lbHNlIGNvbnNvbGUubG9nKCdjaGVjayBwYXJhbWV0ZXJzJyk7XG59XG5cblxuV2ViRm9udC5sb2FkKHtcbiAgICBnb29nbGU6IHtcbiAgICAgIGZhbWlsaWVzOiBbJ0RvIEh5ZW9uJywgJ09yYml0cm9uJ11cbiAgICB9LFxuICAgIGFjdGl2ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgLy9TdGFydHMgd2hlbiBnb29nbGUgZm9udHMgYXJlIGxvYWRlZCAgICAgXG4gICAgICAgIHNsb3RNYWNoaW5lKCk7XG4gICAgICAgIFN0cmV0Y2goKTtcbiAgICB9XG59KVxuXG5mdW5jdGlvbiBzbG90TWFjaGluZSgpe1xuXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzbG90LW1hY2hpbmUnKTtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBcbiAgICB2YXIgU2xvdCA9IGZ1bmN0aW9uKCl7XG5cdCAgICB0aGlzLnggPSAwO1xuXHRcdHRoaXMud2lkdGggPSBjYW52YXMud2lkdGggPSB3VyA8IDk3MCA/IDM2MCA6IDQ3NTtcblx0ICAgIHRoaXMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IHdXIDwgOTcwID8gMzYwIDogNDc1O1xuXHRcdHRoaXMudGV4dCA9ICdQSE9UTydcblx0ICAgIHRoaXMubGV0dGVycyA9IFtdO1xuXG5cdCAgICB0aGlzLmFkZExldHRlciA9IGZ1bmN0aW9uKG4pe1xuXG5cdCAgICAgICAgdmFyIGxldHRlckhlaWdodCA9IHdXIDwgOTcwID8gLTEyNCA6IC0xNTg7XG5cblx0ICAgICAgICAvL1BsYWNlcyBsZXR0ZXJzIGF0IHRvcCBpbmRleCAxLDMsNVxuXHQgICAgICAgIHZhciBib3R0b20gPSB3VyA8IDk3MCA/IHRoaXMuaGVpZ2h0ICsgNjAgOiB0aGlzLmhlaWdodCArIDk2O1xuXHQgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBuOyBqKysgKXtcblx0ICAgICAgICAgICAgLy9SZXNldHMgeCBldmVyeSBpdGVyYXRpb25cblx0ICAgICAgICAgICAgdGhpcy54ID0gMFxuXHQgICAgICAgICAgICAvL0FkanVzdCBib3R0b20gYW5kIGhlaWdodCBhbGwgbGV0dGVyc1xuXHQgICAgICAgICAgICBsZXR0ZXJIZWlnaHQgPSB3VyA8IDk3MCA/IGxldHRlckhlaWdodCArIDEyMSA6IGxldHRlckhlaWdodCArIDE1OFxuXHQgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy50ZXh0Lmxlbmd0aDsgaSsrKXtcblxuXHQgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG9wOiBsZXR0ZXJIZWlnaHQsXG5cdCAgICAgICAgICAgICAgICAgICAgbGV0dGVyOiB0aGlzLnRleHRbaV0sXG5cdCAgICAgICAgICAgICAgICAgICAgeDogaSA9PT0gMCA/IC01IDogd1cgPCA5NzAgPyB0aGlzLngrPTc0IDogdGhpcy54Kz0xMDAuOCxcblx0ICAgICAgICAgICAgICAgICAgICBzcGVlZDogOSwgXG5cdCAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBib3R0b20gLSBsZXR0ZXJIZWlnaHQsXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGkgJSAyID09PSAwID8gXCJ1cFwiIDogXCJkb3duXCJcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG4gPT09IDQgPyB0aGlzLmxldHRlcnMucHVzaChkYXRhKSA6IHRoaXMubGV0dGVycy51bnNoaWZ0KGRhdGEpXG5cblx0ICAgICAgICAgICAgICAgIHZhciBsZXR0ZXIgPSBkYXRhXG5cdCAgICAgICAgXG5cdCAgICAgICAgICAgICAgICBpZihpJTIgPT09IDApe1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1VwKGxldHRlcilcblx0ICAgICAgICAgICAgICAgIH1lbHNle1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggd1cgPCA5NzAgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZpeGVzIHNwYWNpbmcgaXNzdWUgT3JiaXRyb24gZm9udFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPT09IDMgPyBsZXR0ZXIueCArPSAzIDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPT09IDEgPyBsZXR0ZXIueCAtPSAzIDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0Rvd24obGV0dGVyKVxuXHQgICAgICAgICAgICAgICAgfSBcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgdGhpcy5hZGRMZXR0ZXIoNClcblx0fVxuXG4gICAgU2xvdC5wcm90b3R5cGUuZHJhd1VwID0gZnVuY3Rpb24odGV4dCl7XG4gICAgICBcbiAgICAgICAgY3R4LmZvbnQgPSB3VyA8IDk3MCA/ICBcIkJvbGQgNjJwdCBPcmJpdHJvblwiIDogXCIxMDVwdCBEbyBIeWVvblwiO1xuICAgICAgICBjdHguZmlsbFRleHQodGV4dC5sZXR0ZXIsdGV4dC54LCB0ZXh0LmJvdHRvbSlcbiAgICB9XG4gICAgU2xvdC5wcm90b3R5cGUuZHJhd0Rvd24gPSBmdW5jdGlvbih0ZXh0KXtcbiAgICAgICAgXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IFwiIzBEMUI1NlwiO1xuICAgICAgICAgY3R4LmZvbnQgPSB3VyA8IDk3MCA/IFwiQm9sZCA2MnB0IE9yYml0cm9uXCIgOiBcIjEwNXB0IERvIEh5ZW9uXCI7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LmxldHRlcix0ZXh0LngsIHRleHQudG9wKVxuXG4gICAgfVxuXG4gICAgU2xvdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcblxuICAgICAgICAvLyB2YXIgcHVzaCA9IHdXIDwgOTcwID8gLTYxIDogLTc0XG4gICAgICAgIHZhciBwdXNoID0gd1cgPCA5NzAgPyAtNjEgOiAtNzVcbiAgICBcdGlmKCFzbG90TWFjaGluZS5wcm90b3R5cGUudG9nZ2xlKSByZXR1cm47XG4gICAgXG4gICAgICAgIC8vTmV3IHNldCBpZiBsZXR0ZXJzIGRyYXduIGJhc2VkIG9uIHNwYWNpbmdcbiAgICAgICAgaWYodGhpcy5sZXR0ZXJzWzE5XS5ib3R0b20gPD0gcHVzaCApe1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMubGV0dGVycy5zcGxpY2UoMTUsNSlcbiAgICAgICAgICAgIHRoaXMuYWRkTGV0dGVyKDEpXG4gICAgICAgIH1cblxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsMCxjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG4gICAgICAgIFxuICAgIFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGV0dGVycy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbGV0dGVyID0gdGhpcy5sZXR0ZXJzW2ldXG5cbiAgICAgICAgICAgIGxldHRlci50b3AgKz0gbGV0dGVyLnNwZWVkIFxuICAgICAgICAgICAgbGV0dGVyLmJvdHRvbSAtPSBsZXR0ZXIuc3BlZWQgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGxldHRlci5zdGFydCA9PT0gXCJ1cFwiKXtcblxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1VwKGxldHRlcilcblxuICAgICAgICAgICAgfWVsc2UgdGhpcy5kcmF3RG93bihsZXR0ZXIpXG4gICAgXHR9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKVxuICAgIH1cbiAgICB2YXIgc2xvdCA9IG5ldyBTbG90KClcbiAgICBcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGhvdG8gLnN0YXJ0LWNhbnZhcycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgICAgXG4gICAgXHQvL1N0YXJ0IENhbnZhc1xuICAgIFx0c2xvdE1hY2hpbmUucHJvdG90eXBlLnRvZ2dsZSA9IHRydWVcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNsb3QudXBkYXRlLmJpbmQoc2xvdCkpXG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGhvdG8gLnN0b3AtY2FudmFzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgXHQvL1N0b3AgQ2FudmFzXG4gICAgXHRzbG90TWFjaGluZS5wcm90b3R5cGUudG9nZ2xlID0gZmFsc2VcbiAgICB9KTtcblxufVxuXG5cblxuZnVuY3Rpb24gU3RyZXRjaCgpe1xuXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdHJldGNoJyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBcbiAgICBpZih3VyA8IDk3MCl7XG4gICAgICAgIHZhciB3aWR0aCA9IDQwMFxuICAgICAgICB2YXIgaGVpZ2h0ID0gIDM3NVxuICAgICAgICB2YXIgc3RydGNoID0gMTVcbiAgICAgICAgdmFyIGxldHRlckRpc3QgPSA1M1xuICAgICAgICB2YXIgeCA9IDY1XG4gICAgICAgIHZhciBzdHJldGNoWCA9IDVcbiAgICAgICAgdmFyIG1peGVkTnVtID0gNVxuICAgIH1cbiAgICBpZih3VyA8IDQwMCl7XG4gICAgICAgIHZhciB3aWR0aCA9IDM2MFxuICAgICAgICB2YXIgaGVpZ2h0ID0gIDM3NVxuICAgICAgICB2YXIgeCA9IDUwXG4gICAgICAgIHZhciBtaXhlZE51bSA9IC0xMFxuICAgIH1cbiAgICBpZih3VyA+IDk3MCl7XG4gICAgICAgIHZhciB3aWR0aCA9IDY1MFxuICAgICAgICB2YXIgaGVpZ2h0ID0gIDQ1MFxuICAgICAgICB2YXIgc3RydGNoID0gMzBcbiAgICAgICAgdmFyIGxldHRlckRpc3QgPSA2NVxuICAgICAgICB2YXIgeCA9IDEyNVxuICAgICAgICB2YXIgbWl4ZWROdW0gPSA1XG4gICAgfVxuICAgIC8qKiBDSEFOR0UgTlVNQkVSIEZPUiBsaW5lQ291bnQgVE8gQUREIE9SIFNVQlRSQUNUIEhPVyBNQU5ZIExJTkVTIE9GIFdPUkRTICoqL1xuICAgIHZhciBsaW5lQ291bnQgPSA3O1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIHQgPSBsaW5lQ291bnQgLSAxO1xuICAgIHZhciBjb2xvcnMgPSBbXCIjREFGN0E2XCIsIFwiI0ZGQzMwMCBcIiwgXCIjRkY1NzMzXCIsIFwiI0M3MDAzOVwiLCBcIiM5MDBDM0ZcIiwgXCIjNTgxODQ1XCIsIFwiIzM3MTAyYlwiXVxuICAgIHZhciBMZXR0ZXJzID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gdGhpcy50ZXh0ID0gJ1NPTFVUSU9OUydcbiAgICAgICAgdGhpcy5sZXR0ZXJzID0gW107XG4gICAgICAgIHRoaXMudG90YWwgPSB0aGlzLmxldHRlcnMubGVuZ3RoIC0gMVxuICAgICAgICB0aGlzLnRvdGFsID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcblxuICAgICAgICBcbiAgICAgICAgdGhpcy53aWR0aCA9IGNhbnZhcy53aWR0aCA9IHdpZHRoXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IGhlaWdodFxuICAgICAgICB0aGlzLnRleHQgPSAnREVWRUxPUEVSJ1xuICAgICAgICBcbiAgICAgICAgdGhpcy5wdXNoTGV0dGVycyA9IGZ1bmN0aW9uKHgsIGRpc3Qpe1xuICAgICAgICAgICAgLy9JZiBwdXNoTGV0dGVycyBpcyByYW4gYWdhaW4gbWFrZXMgc3VyZSB0aGlzLnkgPSAwXG4gICAgICAgICAgICBpZih0aGlzLnkpIHRoaXMueSA9IDBcbiAgICAgICAgICAgIHZhciBjYW52YXNIZWlnaHQgPSB0aGlzLmhlaWdodFxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxpbmVDb3VudDsgaSsrKXtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVyOiB0aGlzLnRleHQsXG4gICAgICAgICAgICAgICAgICAgIHN0cmV0Y2g6IHN0cnRjaCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHNwZWVkOiBpLFxuICAgICAgICAgICAgICAgICAgICBkaXN0OiB0eXBlb2YgZGlzdCA9PT0gJ251bWJlcicgPyBkaXN0IDogMCxcbiAgICAgICAgICAgICAgICAgICAgLy9MZXR0ZXJzIGRpc3RhbmNlIGJldHdlZW4gZWFjaCBvdGhlciB2aXJ0aWNsZSBcbiAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiB0aGlzLnkgKz0gbGV0dGVyRGlzdCxcbiAgICAgICAgICAgICAgICAgICAgIC8vTGV0dGVycyBzdGFydCBvbiB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogd1cgPCA5NzAgPyBjYW52YXNIZWlnaHQgKyA0NSA6IGNhbnZhc0hlaWdodCArIDYyLFxuICAgICAgICAgICAgICAgICAgICBiZWdpbjogMSxcbiAgICAgICAgICAgICAgICAgICAgLy9XaGVuIHRoZSBuZXh0IHJvdGF0aW9uIHN0YXJ0c1xuICAgICAgICAgICAgICAgICAgICBiZWdpblk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlVG90YWw6IDQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3RZOiAwLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JzW2ldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGV0dGVycy5wdXNoKGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoTGV0dGVycyh4KVxuICAgIH1cblxuICAgIHZhciBkcmF3VXAgPSBmdW5jdGlvbihsZXR0ZXIsIGRpc3Qpe1xuXG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsIGxldHRlci5zY2FsZSxsZXR0ZXIueCwgbGV0dGVyLmJvdHRvbSAtIGRpc3QgKVxuICAgICAgICBjdHguZm9udCA9IHdXIDwgOTcwID8gXCI0MHB0IERvIEh5ZW9uXCIgOiBcIjYwcHQgRG8gSHllb25cIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxldHRlci5jb2xvclxuICAgICAgICBjdHguZmlsbFRleHQobGV0dGVyLmxldHRlciwgMCwgbGV0dGVyLnRleHRZKTtcbiAgICAgICAgLy8gdmFyIHRleHQgPSBjdHgubWVhc3VyZVRleHQobGV0dGVyLmxldHRlcilcbiAgICB9XG4gICAgdmFyIHN0cmV0Y2ggPSBmdW5jdGlvbih0ZXh0KXtcbiAgICAgICAgY3R4LmNhbnZhcy5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gdGV4dC5kaXN0ICsncHgnXG4gICAgICAgIGN0eC5mb250ID0gd1cgPCA5NzAgPyBcIjQwcHQgRG8gSHllb25cIiA6IFwiNjBwdCBEbyBIeWVvblwiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGV4dC5jb2xvclxuICAgICAgICBjdHguZmlsbFRleHQodGV4dC5sZXR0ZXIsIHRleHQueCwgdGV4dC5ib3R0b20gLSB0ZXh0LmRpc3RhbmNlIClcbiAgICB9XG5cbiAgICB2YXIgZHJhd0Rvd24gPSBmdW5jdGlvbihsZXR0ZXIpe1xuICAgICAgICBjdHguZm9udCA9IHdXIDwgOTcwID8gXCI0MHB0IERvIEh5ZW9uXCIgOiBcIjYwcHQgRG8gSHllb25cIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxldHRlci5jb2xvclxuICAgICAgICBjdHguZmlsbFRleHQobGV0dGVyLmxldHRlciwgbGV0dGVyLngsIGxldHRlci55KVxuICAgIH1cblxuICAgIHZhciBkcmF3QmFja0ZsaXAgPSBmdW5jdGlvbihsZXR0ZXIpe1xuICAgICAgICBjdHguZm9udCA9IHdXIDwgOTcwID8gXCI0MHB0IERvIEh5ZW9uXCIgOiBcIjYwcHQgRG8gSHllb25cIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxldHRlci5jb2xvclxuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsMCwwLCBsZXR0ZXIuc2NhbGUsbGV0dGVyLngsIGxldHRlci55IClcbiAgICAgICAgY3R4LmZpbGxUZXh0KGxldHRlci5sZXR0ZXIsIDAsIGxldHRlci50ZXh0WSk7XG4gICAgfVxuICAgIFxuICAgIExldHRlcnMucHJvdG90eXBlLmFkZExldHRlcnMgPSBmdW5jdGlvbih0aW1lc3RhbXApe1xuXG4gICAgXHRpZighU3RyZXRjaC5wcm90b3R5cGUudG9nZ2xlKSByZXR1cm47XG4gICAgICAgXHR2YXIgaiA9IDA7XG5cdFxuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLXVuZGVyJztcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCk7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwwLGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZXR0ZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGxldHRlciA9IHRoaXMubGV0dGVyc1tpXTtcbiAgICAgICAgICAgIGxldHRlci55ID0gbGV0dGVyLmJvdHRvbSAtIGxldHRlci5kaXN0YW5jZVxuXG4gICAgICAgICAgICAvL0ZPVVJUSCBBTkQgTEFTVCBDQUxMLCBSRU1PVkUgV09SRFNcbiAgICAgICAgICAgIGlmKGNvdW50ID09PSAzICYmIGkgPT09IHQpIHtcblxuICAgICAgICAgICAgICAgIGlmKCFsZXR0ZXIuc3RhcnQpIGxldHRlci5zdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgIHZhciBydW50aW1lID0gdGltZXN0YW1wIC0gbGV0dGVyLnN0YXJ0XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gTWF0aC5taW4ocnVudGltZSAvIDYwMCwgMSlcbiAgICAgICAgICAgICAgICBsZXR0ZXIueSArPSAobGV0dGVyLmRpc3RhbmNlICogcHJvZ3Jlc3MpXG5cbiAgICAgICAgICAgICAgICBsZXR0ZXIuc2NhbGUgPSAwIHx8IChsZXR0ZXIuYmVnaW4gLSAoIGxldHRlci5zY2FsZVRvdGFsICogcHJvZ3Jlc3MpICkudG9GaXhlZCgyKVxuICAgICAgICAgICAgICAgIGxldHRlci50ZXh0WSA9ICAobGV0dGVyLmJlZ2luWSArICggbGV0dGVyLmRpc3RZICogcHJvZ3Jlc3MpICkudG9GaXhlZCgyKVxuICAgICAgICAgICAgICAgIGRyYXdCYWNrRmxpcChsZXR0ZXIpXG5cbiAgICAgICAgICAgICAgICAgaWYobGV0dGVyLnNjYWxlID09IC0xIHx8IGxldHRlci5zY2FsZSA8IC0xKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVyLmJlZ2luWSA9IDEwXG4gICAgICAgICAgICAgICAgICAgIGxldHRlci5kaXN0WSA9IHdXIDwgOTcwID8gLTUgOiAtMTBcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVyLnNjYWxlVG90YWwgPSAtNFxuICAgICAgICAgICAgICAgICAgICBsZXR0ZXIuYmVnaW4gPSAtM1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKCBwcm9ncmVzcyA9PT0gMSApe1xuICAgICAgICAgICAgICAgICAgICAvL1JlbW92ZXMgaXRlbSBmcm9tIGFycmF5IGFmdGVyIGVhY2ggd29yZCBpcyBmaW5pc2hlZCBhbmltYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZXR0ZXJzLnNwbGljZSh0LDEpXG4gICAgICAgICAgICAgICAgICAgIHQtLVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiggdCA9PT0gLTEgKXtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b3RhbCA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGxpbmVDb3VudCAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGV0dGVycy5sZW5ndGggPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hMZXR0ZXJzKHgpXG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgMjAwKVxuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiggY291bnQgPT09IDMgJiYgaSAhPT0gdCApIGRyYXdEb3duKGxldHRlcilcblxuXG4gICAgICAgICAgICAvL1RISVJELCBMRVRURVIgU1RSRVRDSCBJTlxuICAgICAgICAgICAgaWYoIGNvdW50ID09PSAyICYmIGkgPT09IHQgKSB7XG4gICAgICAgICAgICAgICAgaWYoIWxldHRlci5zdGFydCkgbGV0dGVyLnN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgdmFyIHJ1bnRpbWUgPSB0aW1lc3RhbXAgLSBsZXR0ZXIuc3RhcnRcbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBNYXRoLm1pbihydW50aW1lIC8gMTI1LCAxKVxuICAgICAgICAgICAgICAgIGxldHRlci5kaXN0ID0gbGV0dGVyLnN0cmV0Y2ggLSAobGV0dGVyLnN0cmV0Y2ggKiBwcm9ncmVzcylcblxuICAgICAgICAgICAgICAgIGxldHRlci54ID0gbWl4ZWROdW0gKyAobGV0dGVyLnN0cmV0Y2ggKiBwcm9ncmVzcykgKiA0XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3RyZXRjaChsZXR0ZXIpXG5cbiAgICAgICAgICAgICAgIGlmKHByb2dyZXNzID09PSAxICl7XG4gICAgICAgICAgICAgICAgICAgIHQtLVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL1JFU0VUUyBWQVJJQUJMRVMsIENBTExTIEZVTkNUSU9OIEFMTCBPVkVSIEFHQUlOXG4gICAgICAgICAgICAgICAgaWYodCA9PT0gLTEpe1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gbGluZUNvdW50IC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZXR0ZXJzLmxlbmd0aCA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaExldHRlcnMoeCwgMClcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAyMDApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoY291bnQgPT09IDIgJiYgaSAhPT0gdCkge1xuXG4gICAgICAgICAgICAgICAgc3RyZXRjaChsZXR0ZXIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgICAvL1NFQ09ORCwgTEVUVEVSIFNUUkVUQ0ggT1VUXG4gICAgICAgICAgICBpZiggY291bnQgPT09IDEgJiYgaSA9PT0gaiApIHtcblxuICAgICAgICAgICAgICAgIGlmKCFsZXR0ZXIuc3RhcnQpIGxldHRlci5zdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgIHZhciBydW50aW1lID0gdGltZXN0YW1wIC0gbGV0dGVyLnN0YXJ0XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gTWF0aC5taW4ocnVudGltZSAvIDE1MCwgMSk7XG5cbiAgICAgICAgICAgICAgICBsZXR0ZXIuZGlzdCA9IGxldHRlci5zdHJldGNoICogcHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgbGV0dGVyLnggPSB4IC0gKGxldHRlci5kaXN0ICogNClcbiAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3RyZXRjaChsZXR0ZXIpXG5cbiAgICAgICAgICAgICAgICBpZiggcHJvZ3Jlc3MgPT09IDEgKXtcbiAgICAgICAgICAgICAgICAgICAgaisrXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoIGogPT09IHRoaXMubGV0dGVycy5sZW5ndGggKXtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxldHRlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gLTUgYmVjYXVzZSBsZXR0ZXJzIHN0cmV0Y2hlZCB0byBmYXIsIG5lZWQgdG8gZml4IG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgLy8gd1cgPCA5NzAgPyB0aGlzLnB1c2hMZXR0ZXJzKDUsIDE1KSA6IHRoaXMucHVzaExldHRlcnMoNSwgMzApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hMZXR0ZXJzKG1peGVkTnVtLCB3VyA8IDk3MCA/IDE1IDogMzAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCBjb3VudCA9PSAxICYmIGkgIT09IGogKSB7XG4gICAgICAgICAgICAgICAgbGV0dGVyLnggPSBsZXR0ZXIueFxuICAgICAgICAgICAgICAgIGxldHRlci5kaXN0ID0gbGV0dGVyLmRpc3RcbiAgICAgICAgICAgICAgICBzdHJldGNoKGxldHRlcilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9GSVJTVCwgTEVUVEVSIENMSU1CRVxuICAgICAgICAgICAgaWYoIGkgPT09IGogJiYgY291bnQgPT09IDAgKXtcblxuICAgICAgICAgICAgICAgIGlmKCFsZXR0ZXIuc3RhcnQpIGxldHRlci5zdGFydCA9IHRpbWVzdGFtcCBcbiAgICAgICAgICAgICAgICB2YXIgcnVudGltZSA9IHRpbWVzdGFtcCAtIGxldHRlci5zdGFydFxuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IE1hdGgubWluKHJ1bnRpbWUgLyA2MDAsIDEpXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBsZXR0ZXIuZGlzdGFuY2UgKiBwcm9ncmVzcztcbiAgICBcbiAgICAgICAgICAgICAgICBsZXR0ZXIuc2NhbGUgPSAwIHx8IChsZXR0ZXIuYmVnaW4gLSAoIGxldHRlci5zY2FsZVRvdGFsICogcHJvZ3Jlc3MpICkudG9GaXhlZCgyKVxuICAgICAgICAgICAgICAgIGxldHRlci50ZXh0WSA9ICAobGV0dGVyLmJlZ2luWSArICggbGV0dGVyLmRpc3RZICogcHJvZ3Jlc3MpICkudG9GaXhlZCgyKVxuICAgXG4gICAgICAgICAgICAgICAgZHJhd1VwKGxldHRlciwgZGlzdClcbiAgXG4gICAgICAgICAgICAgICAgLy9BZGRzIHNlY29uZCBmbGlwIHRvIG1ha2UgdXByaWdodCB0ZXh0IGhhbGYgd2F5IHVwIGNhbnZhc1xuICAgICAgICAgICAgICAgIGlmKGxldHRlci5zY2FsZSA9PSAtMSB8fCBsZXR0ZXIuc2NhbGUgPCAtMSl7XG4gICAgICAgICAgICAgICAgICAgIC8vV2hlbiB0aGUgbmV4dCByb3RhdGlvbiBzdGFydHMgZm9yIGJlZ2luWSBhbmQgZGlzdFlcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVyLmJlZ2luWSA9IHdXIDwgOTcwID8gNSA6IDEwXG4gICAgICAgICAgICAgICAgICAgIGxldHRlci5kaXN0WSA9IHdXIDwgOTcwID8gLTUgOiAtMTBcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVyLnNjYWxlVG90YWwgPSAtNFxuICAgICAgICAgICAgICAgICAgICBsZXR0ZXIuYmVnaW4gPSAtM1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiggcHJvZ3Jlc3MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaisrXG4gICAgICAgICAgICAgICAgfSAgICAgIFxuICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiggaiA9PT0gdGhpcy5sZXR0ZXJzLmxlbmd0aCApe1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGV0dGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hMZXR0ZXJzKHgsIDApXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYWRkTGV0dGVycy5iaW5kKHRoaXMpKVxuICAgIH1cbiAgICB2YXIgbGV0dGVycyA9IG5ldyBMZXR0ZXJzKClcblxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kZXZlbG9wZXIgLnN0YXJ0LWNhbnZhcycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG5cbiAgICAgICAgU3RyZXRjaC5wcm90b3R5cGUudG9nZ2xlID0gdHJ1ZVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGxldHRlcnMuYWRkTGV0dGVycy5iaW5kKGxldHRlcnMpIClcbiBcbiAgICB9KTsgICBcblxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kZXZlbG9wZXIgLnN0b3AtY2FudmFzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuXG4gICAgICAgU3RyZXRjaC5wcm90b3R5cGUudG9nZ2xlID0gZmFsc2VcblxuICAgIH0pXG59O1xuXG5mdW5jdGlvbiBJbWFnZVNoYXR0ZXIoKXtcbiAgICB2YXIgc2l6aW5nID0gZnVuY3Rpb24oY29udGVudCl7XG4gICAgICAgIGlmKGNvbnRlbnQgPT09ICdkdXInKXtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA8IDYwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gMi42XG4gICAgICAgICAgICBlbHNlIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+IDYwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gMy41XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgaWYoY29udGVudCA9PT0gJ2ltZycpe1xuICAgICAgICAgICAgaWYod2luZG93LmlubmVyV2lkdGggPD0gNjAwKSBcbiAgICAgICAgICAgICAgICByZXR1cm4gNDAwXG4gICAgICAgICAgICBlbHNlIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+IDEyMDApXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gNTgwXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIDUwMFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgdmFyIGN0eCwgY2FudmFzO1xuICAgIHZhciBwYXJ0aWNsZUNhbnZhcywgcGFydGljbGVDdHg7XG4gICAgdmFyIGNhbnZhc1BhcmVudFdpZHRoO1xuICAgIHZhciBjYW52YXNQYXJlbnRIZWlnaHQ7XG4gICAgdmFyIGVuZGluZyA9IFtdXG4gICAgdmFyIHJldHJhY3RTdGFydCA9IDA7XG4gICAgdmFyIGltZ0NhbnZhcyA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIGltZyxjYWxsYmFjayl7XG4gICAgICAgIC8vV2F0Y2ggd2hlcmUgdGhpcyBpcyBsb2FkZWQgaW50byB3aGVuIHBvcnRmb2xpbyBkb25lXG4gICAgICAgIC8vIGRvY3VtZW50LmJvZHkuaW5uZXJIVE1MICs9ICc8Y2FudmFzIGlkPVwiaW1nLWNhbnZhc1wiPjwvY2FudmFzPic7XG4gICAgICAgIC8vIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbWctY2FudmFzJylcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcnRpY2xlJylcbiAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aFxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgICAgIGNhbnZhc1BhcmVudFdpZHRoID0gXygnc3ZnLXBhZ2UnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxuICAgICAgICBjYW52YXNQYXJlbnRIZWlnaHQgPSBfKCdzdmctcGFnZScpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCB3aWR0aCxoZWlnaHQpXG5cbiAgICAgICAgLy9DYWxscyBmdW5jdGlvbiBmb3IgY2xpY2thYmxlIGV2ZW50IGxpc3RlbmVyIHRvIHJ1biBhbmQgYXBwZW5kcyBiYWNrZ3JvdW5kIGNhbnZhc1xuICAgICAgICBjYWxsYmFjayhjYW52YXMsY3JlYXRlUGFydGljbGVDYW52YXMoKSlcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpY2xlQ2FudmFzKCkge1xuXG4gICAgICAgIC8vIENyZWF0ZSBvdXIgY2FudmFzXG4gICAgICAgIHBhcnRpY2xlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgcGFydGljbGVDdHggPSBwYXJ0aWNsZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgLy8gU2l6ZSBvdXIgY2FudmFzIHdpdGggYWRkaXRpb25hbCBzaXppbmdcbiAgICAgICAgcGFydGljbGVDYW52YXMud2lkdGggPSBjYW52YXNQYXJlbnRXaWR0aFxuICAgICAgICBwYXJ0aWNsZUNhbnZhcy5oZWlnaHQgPSBjYW52YXNQYXJlbnRIZWlnaHRcbiAgICAgIFxuICAgICAgICAvLyBQb3NpdGlvbiBvdXQgY2FudmFzXG4gICAgICAgIHBhcnRpY2xlQ2FudmFzLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBwYXJ0aWNsZUNhbnZhcy5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICAgICAgcGFydGljbGVDYW52YXMuc3R5bGUubGVmdCA9IFwiMFwiO1xuICAgICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBpdCdzIG9uIHRvcCBvZiBvdGhlciBlbGVtZW50c1xuICAgICAgICBwYXJ0aWNsZUNhbnZhcy5zdHlsZS56SW5kZXggPSBcIjUwMFwiO1xuICAgICAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIG90aGVyIGVsZW1lbnRzIHVuZGVyIGl0IGFyZSBjbGlja2FibGVcbiAgICAgICAgcGFydGljbGVDYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICB2YXIgZm9yZWlnbk9iamVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggbnMsIFwiZm9yZWlnbk9iamVjdFwiKTtcbiAgICAgICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgXCJwYXJ0aWNsZU9iamVjdFwiKVxuICAgICAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBjYW52YXNQYXJlbnRXaWR0aClcbiAgICAgICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGNhbnZhc1BhcmVudEhlaWdodClcbiAgICAgICAgZm9yZWlnbk9iamVjdC5hcHBlbmRDaGlsZChwYXJ0aWNsZUNhbnZhcylcbiAgICAgICBcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZy5kZXNpZ24nKS5hcHBlbmRDaGlsZChmb3JlaWduT2JqZWN0KVxuXG4gICAgfVxuXG4gICAgXG4gICAgICAgIFxuICAgIC8vSW1hZ2UgY29tZXMgYXBwYXJ0XG4gICAgdmFyIEV4cGxvZGluZ1BhcnRpY2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYmVnaW4gPSAwXG5cbiAgICAgICAgLy8gU2V0IGhvdyBsb25nIHdlIHdhbnQgb3VyIHBhcnRpY2xlIHRvIGFuaW1hdGUgZm9yXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRHVyYXRpb24gPSAxMDAwOyAvLyBpbiBtc1xuXG4gICAgICAgIC8vIFNldCB0aGUgc3BlZWQgLyBkaXN0YW5jZSBmb3Igb3VyIHBhcnRpY2xlXG4gICAgICAgIHRoaXMuc3BlZWQgPSB7XG4gICAgICAgICAgICB4OiB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OCA/IC01ICsgTWF0aC5yYW5kb20oKSAqIDEwIDogLTEwICsgTWF0aC5yYW5kb20oKSAqIDIwLFxuICAgICAgICAgICAgeTogd2luZG93LmlubmVyV2lkdGggPCA3NjggPyAtNSArIE1hdGgucmFuZG9tKCkgKiAxMCA6IC0xMCArIE1hdGgucmFuZG9tKCkgKiAyMFxuICAgICAgICB9O1xuICAgICAgXG4gICAgICAgIC8vIFNpemUgb3VyIHBhcnRpY2xlXG4gICAgICAgIHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4ID8gdGhpcy5yYWRpdXMgPSAzICsgTWF0aC5yYW5kb20oKSAqIDMgOiB0aGlzLnJhZGl1cyA9IDQgKyBNYXRoLnJhbmRvbSgpICogNDtcbiAgICAgIFxuICAgICAgXG4gICAgICAgIC8vIFNldCBhIG1heCB0aW1lIHRvIGxpdmUgZm9yIG91ciBwYXJ0aWNsZVxuICAgICAgICB0aGlzLmxpZmUgPSAzMCArIE1hdGgucmFuZG9tKCkgKiAxMDtcbiAgICAgICAgdGhpcy5yZW1haW5pbmdMaWZlID0gdGhpcy5saWZlXG5cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBieSBvdXIgYW5pbWF0aW9uIGxvZ2ljIGxhdGVyIG9uXG4gICAgICAgIHRoaXMuZHJhdyA9IGN0eCA9PiB7XG5cbiAgICAgICAgICAgIGxldCBwID0gdGhpc1xuICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYodGhpcy5yZW1haW5pbmdMaWZlID4gMCAmJiB0aGlzLnJhZGl1cyA+IDApIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBEcmF3IGEgY2lyY2xlIGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgY3R4LmFyYyhwLnN0YXJ0WCwgcC5zdGFydFksIHAucmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYShcIiArIHRoaXMucmdiQXJyYXlbMF0gKyAnLCcgKyB0aGlzLnJnYkFycmF5WzFdICsgJywnICsgdGhpcy5yZ2JBcnJheVsyXSArIFwiLCAxKVwiXG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcGFydGljbGUncyBsb2NhdGlvbiBhbmQgbGlmZVxuICAgICAgICAgICAgICAgIHAucmVtYWluaW5nTGlmZS0tXG4gICAgICAgICAgICAgICAgcC5yYWRpdXMgLT0gMC4yNVxuICAgICAgICAgICAgICAgIHAuc3RhcnRYICs9IHAuc3BlZWQueFxuICAgICAgICAgICAgICAgIHAuc3RhcnRZICs9IHAuc3BlZWQueVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmV0cmFjdCA9IChiZWdpbiwgZmluYWxlLCB0aW1lc3RhbXApID0+IHtcblxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIXJldHJhY3RTdGFydCkgcmV0cmFjdFN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBydW50aW1lID0gdGltZXN0YW1wIC0gcmV0cmFjdFN0YXJ0XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gTWF0aC5taW4ocnVudGltZSAvIDMwMDAsIDEpXG4gICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGNhbnZhcy5zdHlsZS5vcGFjaXR5ID0gMSAtIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgcGFydGljbGVDdHguY2xlYXJSZWN0KDAsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYmVnaW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBiZWdpbltpXVxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBmaW5hbGVbaV1cbiAgICAgICAgICAgICAgICBcbiAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RYID0gTWF0aC5hYnMoc3RhcnQuc3RhcnRYICAtIGVuZC54KVxuICAgICAgICAgICAgICAgIHZhciBkaXN0WSA9IE1hdGguYWJzKHN0YXJ0LnN0YXJ0WSAtIGVuZC55KVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vSWYgZW5kIHggb3IgeSBpcyBncmVhdGVyIHRoYW4geCBvciB5IHN1YnRyYWN0IGVsc2UgYWRkXG4gICAgICAgICAgICAgICAgc3RhcnQueCA9IHN0YXJ0LnN0YXJ0WCA+IGVuZC54ID8gc3RhcnQuc3RhcnRYIC0gKGRpc3RYICogcHJvZ3Jlc3MpIDogc3RhcnQuc3RhcnRYICsgKGRpc3RYICogcHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgc3RhcnQueSA9IHN0YXJ0LnN0YXJ0WSA+IGVuZC55ID8gc3RhcnQuc3RhcnRZIC0gKGRpc3RZICogcHJvZ3Jlc3MpIDogc3RhcnQuc3RhcnRZICsgKGRpc3RZICogcHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgc3RhcnQucmFkID0gc3RhcnQuYmVnaW4gKyAoZW5kLnJhZCAqIHByb2dyZXNzKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHBhcnRpY2xlQ3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcGFydGljbGVDdHguYXJjKHN0YXJ0LngsIHN0YXJ0LnksIHN0YXJ0LnJhZCwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlQ3R4LmZpbGxTdHlsZSA9IFwicmdiYShcIiArIHN0YXJ0LnJnYkFycmF5WzBdICsgJywnICsgc3RhcnQucmdiQXJyYXlbMV0gKyAnLCcgKyBzdGFydC5yZ2JBcnJheVsyXSArICcsJysgc3RhcnQucmdiQXJyYXlbM10rXCIpXCJcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHBhcnRpY2xlQ3R4LmZpbGwoKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYocHJvZ3Jlc3MgPT09IDEgKXtcbiAgICAgICAgICAgIC8vcmV0dXJucyB0aGUgcGhvdG8gYmFjayBpZiByYW4gYWdhaW5cbiAgICAgICAgICAgIHJldHVybiBcbiAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKHRpbWVzdGFtcCl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyYWN0KGJlZ2luLCBmaW5hbGUsIHRpbWVzdGFtcClcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbiAgICB2YXIgcGFydGljbGVzID0gW107XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWNsZUF0UG9pbnQoeCwgeSwgY29sb3JEYXRhKSB7XG4gICAgICAgIGxldCBwYXJ0aWNsZSA9IG5ldyBFeHBsb2RpbmdQYXJ0aWNsZSgpO1xuICAgICAgICBcbiAgICAgICAgcGFydGljbGUucmdiQXJyYXkgPSBjb2xvckRhdGE7XG4gICAgICAgIHBhcnRpY2xlLnN0YXJ0WCA9IHg7XG4gICAgICAgIHBhcnRpY2xlLnN0YXJ0WSA9IHk7XG4gICAgICAgIHBhcnRpY2xlLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIFxuICAgICAgICBwYXJ0aWNsZXMucHVzaChwYXJ0aWNsZSk7XG4gICAgICAgIGxldCBlbmQgPSB7fVxuICAgICAgICBlbmQuc3RhcnQgPSAwO1xuICAgICAgICBlbmQucmFkID0gcGFydGljbGUucmFkaXVzO1xuICAgICAgICBlbmQueCA9IHg7XG4gICAgICAgIGVuZC55ID0geTtcbiAgICAgICAgZW5kaW5nLnB1c2goZW5kKVxuICAgICAgXG4gICAgfVxuXG4gICAgdmFyIG9wYWMgPSAxO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYodHlwZW9mIHBhcnRpY2xlQ3R4ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBwYXJ0aWNsZUN0eC5jbGVhclJlY3QoMCwgMCwgd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9pbWFnZSBmYWRlcyBhcyBpdCdzIGJyZWFraW5nIGFwYXJ0XG4gICAgICAgIGNhbnZhcy5zdHlsZS5vcGFjaXR5ID0gKG9wYWMgPSBvcGFjIC0gLjA4KVxuXG4gICAgICAgIC8vIERyYXcgYWxsIG9mIG91ciBwYXJ0aWNsZXMgaW4gdGhlaXIgbmV3IGxvY2F0aW9uXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJ0aWNsZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgcGFydGljbGVzW2ldLmRyYXcocGFydGljbGVDdHgpO1xuXG4gICAgICAgICAgICAvLyBXaGVuIHBhcnRpY2xlcyBcbiAgICAgICAgICAgIGlmKHBhcnRpY2xlc1tpXS5yYWRpdXMgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBlcmNlbnQgPSAoRGF0ZS5ub3coKSAtIHBhcnRpY2xlc1tpXS5zdGFydFRpbWUpIC8gcGFydGljbGVzW2ldLmFuaW1hdGlvbkR1cmF0aW9uICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxldCBkdXIgPSBzaXppbmcoJ2R1cicpXG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihwZXJjZW50ID4gZHVyKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0aWNsZSA9IG5ldyBFeHBsb2RpbmdQYXJ0aWNsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnJldHJhY3QocGFydGljbGVzLCBlbmRpbmcpXG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpO1xuICAgIH1cblxuICAgIHZhciBjbGVhckRhdGEgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXRyYWN0U3RhcnQgPSBudWxsXG4gICAgICAgIGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJylcbiAgICAgICAgcGFydGljbGVDdHguY2xlYXJSZWN0KDAsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgICBlbmRpbmcgPSBbXVxuICAgICAgICBwYXJ0aWNsZXMgPSBbXVxuICAgIH1cblxuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgd2lkdGggPSBzaXppbmcoJ2ltZycpXG4gICAgICAgIHZhciBoZWlnaHQgPSB3aWR0aDtcbiAgICAgICAgaW1nQ2FudmFzKHdpZHRoLGhlaWdodCx0aGlzLHJ1bkV2ZW50cylcbiAgICAgICAgXG4gICAgfVxuICAgIGltZy5zcmMgPSAnaW1hZ2VzL2Rlc2lnbi1pbWcucG5nJ1xuXG4gICAgZnVuY3Rpb24gcnVuRXZlbnRzKGltZ0NhbnZhcyl7XG4gICAgICAgIHZhciBmb3JlaWduT2JqZWN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmRlc2lnbiAuaXRlbS1jYW52YXMnKVxuICAgICBcbiAgICAgICAgbGV0IGltYWdlTGVmdCA9IHBhcnNlSW50KGZvcmVpZ25PYmplY3QuZ2V0QXR0cmlidXRlKCd4JykgKTtcbiAgICAgICAgbGV0IGltYWdlVG9wID0gcGFyc2VJbnQoZm9yZWlnbk9iamVjdC5nZXRBdHRyaWJ1dGUoJ3knKSApO1xuICAgICAgICAvLyBsZXQgcmVkdWN0aW9uRmFjdG9yID0gd2luZG93LndpZHRoIDw9IDQwMCA/IDE1IDogTWF0aC5yb3VuZChpbWdDYW52YXMud2lkdGggLyAxNSlcbiAgICAgICAgaWYod2luZG93LmlubmVyV2lkdGggPCA2MDApXG4gICAgICAgICAgICB2YXIgcmVkdWN0aW9uRmFjdG9yID0gMTVcbiAgICAgICAgaWYod2luZG93LmlubmVyV2lkdGggPj02MDApIFxuICAgICAgICAgICAgdmFyIHJlZHVjdGlvbkZhY3RvciA9IDIyXG4gICAgICAgIGlmKHdpbmRvdy5pbm5lcldpZHRoID49IDEyMDApXG4gICAgICAgICAgICB2YXIgcmVkdWN0aW9uRmFjdG9yID0gMzNcbiAgICAgICAgXG4gICAgICAgIC8vUmVtb3ZlcyBjYW52YXMgd2l0aCBwYXJ0aWNsZXMgbWFkZSBmcm9tIHdoZW4gY2xvc2luZyBzdmcgcGFnZVxuICAgICAgICBfKCdjbG9zZS1idG4nKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsZWFyRGF0YSlcblxuICAgICAgICBpbWdDYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIGlmKGUudGFyZ2V0LnN0eWxlLm9wYWNpdHkgKXtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyRGF0YSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgICAvL3dpZHRoIGZpcnN0IG9uZSBwaXhlbCwgdGhlbiBhbGwgb2YgaGVpZ2h0IHBpeGVscywgd2lkdGggYW5vdGhlciBwaXhlbCB0aGVuIGFsbCBvZiBoZWlnaHQgcGl4ZWxzIFxuICAgICAgICAgICAgbGV0IHJnYmFEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KS5kYXRhO1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvcihsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4Kyspe1xuICAgICAgICAgICAgICAgIGZvcihsZXQgeSA9IDA7IHkgPCB0aGlzLmhlaWdodDsgeSsrKXtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoY291bnQgJSByZWR1Y3Rpb25GYWN0b3IgPT09IDApIHtcbiAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9ICh5ICogdGhpcy53aWR0aCArIHgpICogNDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJnYmFDb2xvckFyciA9IHJnYmFEYXRhLnNsaWNlKGluZGV4LCBpbmRleCArIDQpO1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBsZXQgZ2xvYmFsWCA9IGltYWdlTGVmdCArIHg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBnbG9iYWxZID0gaW1hZ2VUb3AgKyB5O1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVQYXJ0aWNsZUF0UG9pbnQoZ2xvYmFsWCwgZ2xvYmFsWSwgcmdiYUNvbG9yQXJyKVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnQrK1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZSgpXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkltYWdlU2hhdHRlcigpO1xuXG5cblxuZnVuY3Rpb24gU3RhcnJ5TmlnaHQoKXtcbiAgICAgICBcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJyeU5pZ2h0Jyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBkYXRhID0gW11cbiAgICB2YXIgdHJhaWxEYXRhID0gW11cbiAgICB2YXIgcmdiID0gIHRyYWlsRGF0YS5sZW5ndGggPiAxICYmIDE1MCAvIHRyYWlsRGF0YS5sZW5ndGhcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGhvdXNlV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OCA/IDM4MCA6IDYwMDtcbiAgICB2YXIgaG91c2VIZWlnaHQgPSBuZXdTaXplKCd3aWR0aCcsIGhvdXNlV2lkdGgpLmhlaWdodDtcbiAgICB0aGlzLndpZHRoID0gY2FudmFzLndpZHRoID0gXygnc3ZnLXBhZ2UnKS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgdGhpcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ID0gXygnc3ZnLXBhZ2UnKS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICAgIHRoaXMudG9nZ2xlID0gdHJ1ZTtcblxuICAgIHRoaXMuaW1hZ2VzID0gW11cblxuICAgIC8vTWVuIERhdGFcbiAgICB2YXIgbWVuRGF0YSA9IHtcbiAgICAgICAgaGVhZEFyYzogd2luZG93LmlubmVyV2lkdGggPCA3NjggPyA0IDogNixcbiAgICAgICAgc3RlcERvd246IHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4ID8gMTIgOiAxNyxcbiAgICAgICAgcm90YXRlZFBvczogMCxcbiAgICAgICAgcm90YXRlRGVncmVlOiAxNCxcbiAgICAgICAgajogMCwgLy9FYWNoIHBvaW50IG9mIGFuaW1hdGlvbiwgd2Fsaywgc3RhbmQgc3RpbGwsIHJvdGF0ZSAsZmFsbGluZ1xuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgYmVnaW46IDAsXG4gICAgICAgIGxhc3RQb3NYOiA5MCxcbiAgICAgICAgbGFzdFBvc1k6IHVuZGVmaW5lZCxcbiAgICAgICAgYXJjU3RhcnRYOiB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OCA/IDcgOiAxMCxcbiAgICAgICAgYXJjU3RhcnRZOiA1XG4gICAgfVxuXG4gICAgLy9Ib3VzZSBhbmltYXRpb24gRGF0YVxuICAgIHRoaXMuaG91c2UgPSB7XG4gICAgICAgIGhvdXNlSW1nOiB1bmRlZmluZWQsXG4gICAgICAgIHRvZ2dsZTogdW5kZWZpbmVkLFxuICAgICAgICBjdXJyZW50WTogdW5kZWZpbmVkLFxuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgcmlnaHQ6IHRoaXMud2lkdGggLSBob3VzZVdpZHRoLFxuICAgICAgICBib3R0b206IHRoaXMuaGVpZ2h0IC0gaG91c2VIZWlnaHQsXG4gICAgICAgIHN0YXJ0WTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdHRvbSArIGhvdXNlV2lkdGggLyAyLjRcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRYOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgYmVnaW46IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBtZW5EYXRhLmxhc3RQb3NZID0gKGhvdXNlSGVpZ2h0IC8gMi4yNCkgLSBzdGFycnlOaWdodC5pbWFnZXNbMF0uaGVpZ2h0XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuaG91c2VJbWcsIHRoaXMuc3RhcnRYKCksIHRoaXMuc3RhcnRZKCksIGhvdXNlV2lkdGgsIGhvdXNlSGVpZ2h0IClcbiAgICAgICAgfSxcbiAgICAgICAgcmlzZTogdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICBtb3ZlTGVmdDogd2luZG93LmlubmVyV2lkdGggPCA1MDAgPyB0aGlzLndpZHRoIC8gMjAgOiB0aGlzLndpZHRoIC8gOFxuICAgIH1cblxuICAgIC8vU3RhciBUcmFpbCBEYXRhXG4gICAgdmFyIGxhc3RQb3NpdGlvbiA9IGZ1bmN0aW9uKHhQb3MsIHlQb3MsIHJhZGl1cywgYWxwaGEpe1xuICAgICAgICB0cmFpbERhdGEucHVzaCh7XG4gICAgICAgICAgICB4OiB4UG9zLFxuICAgICAgICAgICAgeTogeVBvcyxcbiAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgICAgYWxwaGE6IGFscGhhXG4gICAgICAgIH0pXG4gICAgICAgIGlmKHRyYWlsRGF0YS5sZW5ndGggPiAyNSkgdHJhaWxEYXRhLnNoaWZ0KClcbiAgICB9XG5cbiAgICB0aGlzLnJhbmRvbU1heCA9IGZ1bmN0aW9uKG1pbiwgbWF4KXtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbiApXG4gICAgfVxuXG4gICAgLy9BZGRzIGRhdGEgZm9yIFNob290aW5nIHN0YXJcbiAgICB0aGlzLmFkZERhdGEgPSBmdW5jdGlvbigpe1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgODsgaSsrKXtcbiAgICAgICAgICAgIHZhciBtZWFzdXJlbWVudHMgPSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnRzIHJhbmRvbWx5IG9uIHRoZSB4IGF4aXNcbiAgICAgICAgICAgICAgICBkZWxheTogaSA9PT0gMCA/IDAgOiB0aGlzLnJhbmRvbU1heCgxLCAyKSxcbiAgICAgICAgICAgICAgICB4OiB0aGlzLnJhbmRvbU1heCgwLCB0aGlzLndpZHRoLzIpLFxuICAgICAgICAgICAgICAgIHk6IHRoaXMucmFuZG9tTWF4KDIwMCwgdGhpcy5oZWlnaHQpLFxuICAgICAgICAgICAgICAgIHJhZGl1czogd2luZG93LmlubmVyV2lkdGggPCA3NjggPyB0aGlzLnJhbmRvbU1heCg1LCAxMykgOiB0aGlzLnJhbmRvbU1heCg4LCAxNiksXG4gICAgICAgICAgICAgICAgZGlzdGFuY2U6IHRoaXMud2lkdGggKyAxMDAsXG4gICAgICAgICAgICAgICAgZ2xvYkFscGhhOiAxLFxuICAgICAgICAgICAgICAgIG9wYWM6IDEsXG4gICAgICAgICAgICAgICAgZW5kUG9zOiB0aGlzLnJhbmRvbU1heCgxMDAsIHRoaXMud2lkdGgpLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICAgICAgZXhwbG9kZVN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgIGV4cGxvZGVTaXplOiB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OCA/IDIwIDogMzVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEucHVzaChtZWFzdXJlbWVudHMpXG4gICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpXG5cbiAgICAvL1doZW4gcHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlIHRoaXMgYXV0b21hdGljYWxseSBnZXRzIHJhbiB0byBiZSBhYmxlIHRvIHJ1biBhbmltYXRpb24gYWdhaW5cbiAgICB0aGlzLnJlc3RvcmVEYXRhID0gZnVuY3Rpb24oKXtcbiAgICAgICAgZGF0YSA9IFtdXG4gICAgICAgIHRyYWlsRGF0YSA9IFtdXG4gICAgICAgIGogPSAwXG4gICAgICAgIHRoaXMuYWRkRGF0YSgpXG4gICAgICAgIG1lbkRhdGEuYmVnaW4gPSBudWxsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd0hvdXNlKGltYWdlLHRpbWVzdGFtcCl7XG4gICAgICAgIGlmKCFpbWFnZS5zdGFydCkgaW1hZ2Uuc3RhcnQgPSB0aW1lc3RhbXBcbiAgICAgICAgdmFyIHJ1bnRpbWUgPSB0aW1lc3RhbXAgLSBpbWFnZS5zdGFydFxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBydW50aW1lIC8gMjAwMFxuXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGltYWdlLnJpc2UgKiBwcm9ncmVzc1xuICAgICAgICBcbiAgICAgICAgLy9GbG9hdGluZyBpbiBwbGFjZVxuICAgICAgICBpZihpbWFnZS5jdXJyZW50WSl7XG5cbiAgICAgICAgICAgIGltYWdlLnRvZ2dsZSA/IGltYWdlLnggPSBpbWFnZS5jdXJyZW50WCAtIGRpc3RhbmNlICA6IGltYWdlLnggPSBpbWFnZS5jdXJyZW50WCArIGRpc3RhbmNlXG4gICAgICAgICAgICBpbWFnZS50b2dnbGUgPyBpbWFnZS55ID0gaW1hZ2UuY3VycmVudFkgKyBkaXN0YW5jZSAgOiBpbWFnZS55ID0gaW1hZ2UuY3VycmVudFkgLSBkaXN0YW5jZVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihkaXN0YW5jZSA+PSBpbWFnZS5yaXNlKXtcbiAgICAgICAgICAgIC8vTWFrZXMgY3VycmVudFkgdHJ1ZSBhbmQgdXBkYXRlcyBwb3N0aW9uIG9mIHRoZSBpbWFnZVxuICAgICAgICAgICAgaW1hZ2UuY3VycmVudFkgPSBpbWFnZS55XG4gICAgICAgICAgICBpbWFnZS5jdXJyZW50WCA9IGltYWdlLnhcbiAgICAgICAgICAgIGltYWdlLnRvZ2dsZSA/IGltYWdlLnRvZ2dsZSA9IGZhbHNlIDogaW1hZ2UudG9nZ2xlID0gdHJ1ZVxuICAgICAgICAgICAgaW1hZ2Uuc3RhcnQgPSAwXG4gICAgICAgICAgICBpbWFnZS5yaXNlID0gNTBcblxuICAgICAgICB9XG4gICAgICAgIC8vRW5kcyB0aGUgZmlyc3QgcmlzZSBvZiB0aGUgaW1hZ2VcbiAgICAgICAgaWYoIWltYWdlLmN1cnJlbnRZKSB7XG4gICAgICAgICAgICBpbWFnZS54ID0gaW1hZ2Uuc3RhcnRYKCkgLSAoaW1hZ2UubW92ZUxlZnQgKiBwcm9ncmVzcylcbiAgICAgICAgICAgIGltYWdlLnkgPSBpbWFnZS5zdGFydFkoKSAtIChpbWFnZS5yaXNlICogcHJvZ3Jlc3MpXG4gICAgICAgIH1cblxuICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLmhvdXNlSW1nLCBpbWFnZS54LCBpbWFnZS55LCBob3VzZVdpZHRoLCBob3VzZUhlaWdodCApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd1N0YXJzKGNpcil7XG4gICAgICAgIGN0eC5zYXZlKClcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gY2lyLmFscGhhXG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguYXJjKGNpci54UG9zLCBjaXIueVBvcywgY2lyLnJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMjU1LCAyNTUsIDczLCAnICsgY2lyLm9wYWNpdHkgKyAnKSdcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKVxuICAgICAgICBsYXN0UG9zaXRpb24oY2lyLnhQb3MsIGNpci55UG9zLCBjaXIucmFkaXVzLCBjaXIuYWxwaGEpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd1RyYWlsKHRyYWlsKXtcbiAgICAgICAgY3R4LnNhdmUoKVxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguYXJjKHRyYWlsLngsIHRyYWlsLnksIHRyYWlsLnJhZCwgMCwgMiAqIE1hdGguUEksIHRydWUpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMjM4LCcrdHJhaWwuY29sb3IrJywgNiwgJyArIHRyYWlsLmZhZGUgKyAnKSdcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKVxuICAgIH1cbiAgICBmdW5jdGlvbiBkcmF3RXhwbG9zaW9uKGNpcmNsZSwgdGltZXN0YW1wKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgaWYoIWNpcmNsZS5leHBsb2RlU3RhcnQpIGNpcmNsZS5leHBsb2RlU3RhcnQgPSB0aW1lc3RhbXBcbiAgICAgICAgdmFyIHJ1bnRpbWUgPSB0aW1lc3RhbXAgLSBjaXJjbGUuZXhwbG9kZVN0YXJ0XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IHJ1bnRpbWUgLyA0MDBcbiAgICAgICAgdmFyIGVhc2UgPSBlYXNlT3V0KHByb2dyZXNzKVxuICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgY3R4LmFyYyhjaXJjbGUueFBvcywgY2lyY2xlLnlQb3MsIDAgKyAoY2lyY2xlLmV4cGxvZGVTaXplICogZWFzZSksIDAsIDIgKiBNYXRoLlBJLCB0cnVlKVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMjQ5LCAyNTUsIDAsICcgKyAoMSAtICguOSAqIHByb2dyZXNzKSApICsgJyknXG4gICAgICAgIGN0eC5maWxsKClcbiAgICAgICAgICAgIFxuICAgIH1cbiAgICBmdW5jdGlvbiBkcmF3TWVuKG1lbil7XG5cbiAgICAgICAgaWYobWVuRGF0YS5qID49IDQgJiYgbWVuRGF0YS5qIDw9IDUpe1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShtZW4udHJhbnNsYXRlWCwgbWVuLnRyYW5zbGF0ZVkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShtZW4ucm90YXRlICogTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKG1lbi5pbWcsIC1tZW4ud2lkdGgvMiwgLW1lbi5oZWlnaHQsIG1lbi53aWR0aCwgbWVuLmhlaWdodClcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApXG4gICAgICAgIH1lbHNleyBcbiAgICAgICAgICAgIGN0eC5zYXZlKClcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG1lbi5vcGFjXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguYXJjKG1lbi5hcmNYLCBtZW4uYXJjWSwgbWVuLmFyY1JhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzAwMFwiXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShtZW4uaW1nLCBtZW4ueCwgbWVuLnksIG1lbi53aWR0aCwgbWVuLmhlaWdodClcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkcmF3ID0gZnVuY3Rpb24odGltZXN0YW1wKXtcbiAgICAgICAgaWYoIVN0YXJyeU5pZ2h0LnByb3RvdHlwZS50b2dnbGUpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdG9yZURhdGEoKVxuICAgICAgICB9IFxuXG4gICAgICAgIC8vSG91c2VcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5ob3VzZVxuXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgICAgIFxuICAgICAgICAvL01lbiBydW5uaW5nIHN0YXJ0ICwgU3RhcnMgc3RhcnQgYWZ0ZXIgaG91c2UgZ2V0cyB0byB0b3AuIFxuICAgICAgICBpZihpbWFnZS5jdXJyZW50WSl7XG5cbiAgICAgICAgICAgIC8vKiogIFNUQVJUIE9GIFNUQVJTICAqKi9cblxuICAgICAgICAgICAgLy8gRHJhd3MgdGhlIHRyYWlsIG9wYWNpdHkgIFxuICAgICAgICAgICAgaWYobWVuRGF0YS5qID49IDEpe1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0cmFpbERhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhaWwgPSB0cmFpbERhdGFbaV1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhZGVTaXplID0gIGkgLyB0cmFpbERhdGEubGVuZ3RoXG5cbiAgICAgICAgICAgICAgICAgICAgLy9UcmFpbCB0YXBlcnMgYXMgaXQgZ29lcy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhZGl1c1RhcGVyID0gICAodHJhaWwucmFkaXVzLTIpIC8gdHJhaWxEYXRhLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB0cmFpbC5jb2xvciA9IDI0MCAtIChpK2opXG4gICAgICAgICAgICAgICAgICAgIHRyYWlsLmZhZGUgPSBpIC8gdHJhaWxEYXRhLmxlbmd0aFxuXG4gICAgICAgICAgICAgICAgICAgIC8vVGFwZXJzIGRvd24gdGhlIHJhaWR1cyBvZiB0aGUgdHJhaWxcbiAgICAgICAgICAgICAgICAgICAgdHJhaWwucmFkID0gKHRyYWlsLnJhZGl1cyA9IHRyYWlsLnJhZGl1cyAtIHJhZGl1c1RhcGVyIClcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhaWwucmFkID0gdHJhaWwucmFkaXVzXG4gICAgICAgICAgICAgICAgICAgIGRyYXdUcmFpbCh0cmFpbClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL0RyYXdzIHN0YXJzXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2lyY2xlID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKCBqID49IGkgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWNpcmNsZS5zdGFydCkgY2lyY2xlLnN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcnVudGltZSA9IHRpbWVzdGFtcCAtIGNpcmNsZS5zdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByb2dyZXNzID0gcnVudGltZSAvIDIwMDBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlYXNlID0gZWFzZU91dChwcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS50aW1lID0gKGNpcmNsZS5kZWxheSAtIGVhc2UpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgdGhlIGN1cnJlbnQgY2lyY2xlIGRlbGF5ID0gcHJvZ3Jlc3MgZHJhd3MgbmV4dCBjaXJjbGUsIChyYW5kb20gZHJhd2luZyBsb29rKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2lyY2xlLnRpbWUgPD0gMCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2N1cnJlbnQgY2lyY2xlIHNldCB0byB1bmRlZmluZWQga2VlcCBmcm9tIHJ1bm5pbmcgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUuZGVsYXkgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKytcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5hbHBoYSA9IGNpcmNsZS5nbG9iQWxwaGEgLSAoMSpwcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5vcGFjaXR5ID0gY2lyY2xlLm9wYWMgLSAgKC45KnByb2dyZXNzKSBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNpcmNsZS5kdXJhdGlvbiA9IGVhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaiUzICE9PTAgJiYgbWVuRGF0YS5qID49IDEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS54UG9zID0gY2lyY2xlLnggKyAoY2lyY2xlLmVuZFBvcyAqIGVhc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lyY2xlLnlQb3MgPSAwICsgKGNpcmNsZS55ICogZWFzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW92ZXInXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lyY2xlLnhQb3MgPSBjaXJjbGUueCArIChjaXJjbGUuZW5kUG9zICogZWFzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUueVBvcyA9IDAgKyAoY2lyY2xlLnkgKiBwcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdTdGFycyhjaXJjbGUpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vRXhwbG9zaW9uIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjaXJjbGUueFBvcyA+IGltYWdlLnggJiYgY2lyY2xlLnlQb3MgPiBpbWFnZS55KXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdFeHBsb3Npb24oY2lyY2xlLCB0aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihqID09PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxEYXRhID0gW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZERhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8qKiAgU1RBUlQgT0YgTUVOICAqKi9cbiAgICAgICAgICAgIHZhciBtZW5MZW5ndGggPSBzdGFycnlOaWdodC5pbWFnZXMubGVuZ3RoLTFcblxuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG1lbkxlbmd0aDsgaSsrKXsgXG4gICAgICAgICAgICAgICAgdmFyIG1lbiA9IHN0YXJyeU5pZ2h0LmltYWdlc1tpXVxuICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoIW1lbkRhdGEuYmVnaW4pIG1lbkRhdGEuYmVnaW4gPSB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICB2YXIgcnVudGltZSA9IHRpbWVzdGFtcCAtIG1lbkRhdGEuYmVnaW5cbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBNYXRoLm1pbihydW50aW1lIC8gMjAwMCwgMSlcblxuICAgICAgICAgICAgICAgIC8vRmlyc3Qgd2FsayBvdXRcbiAgICAgICAgICAgICAgICBpZihtZW5EYXRhLmogPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5zdGFydCA9IHBhcnNlSW50KCAoIHByb2dyZXNzICogMTUpLnRvRml4ZWQoMCkgKTtcbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5kaXN0YW5jZVggPSB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OCA/IDk1IDogMjA1XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL1NlY29uZCBXYWxrIHN0YW5kcyBzdGlsbFxuICAgICAgICAgICAgICAgIGlmKG1lbkRhdGEuaiA9PT0gMSl7XG4gICAgICAgICAgICAgICAgICAgIC8vU3RhcnRzIGFuZCBlbmRzIHdpdGggbGFzdCBkdWRlXG4gICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuc3RhcnQgPSAxNVxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwaW5nIGNvdW50IGF0IGxhc3QgbWFuIGluc3RlYWQgb2YgY291bnRpbmcgdGhyb3VnaCB0aGVtIHRvIGFuaW1hdGVcbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5kaXN0YW5jZVggPSAwXG4gICAgICAgICAgICAgICAgfSBcblxuICAgICAgICAgICAgICAgIC8vVGhpcmQgd2FsayBkb3duIGFuZCB0byB0aGUgZW5kXG4gICAgICAgICAgICAgICAgaWYobWVuRGF0YS5qID09PSAyKXtcbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5zdGFydCA9IHBhcnNlSW50KCAoIHByb2dyZXNzICogMTUpLnRvRml4ZWQoMCkgKTtcbiAgICAgICAgICAgICAgICAgICAgbWVuLndhbGtEb3duID0gTWF0aC5taW4oICggcHJvZ3Jlc3MgKiA2KSwgMSApICogbWVuRGF0YS5zdGVwRG93blxuICAgICAgICAgICAgICAgICAgICAvLyBtZW5EYXRhLmRpc3RhbmNlWCA9IDI1MFxuICAgICAgICAgICAgICAgICAgICBtZW5EYXRhLmRpc3RhbmNlWCA9IHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4ID8gMTU5IDogMjUwXG4gICAgICAgICAgICAgICAgfSBcblxuICAgICAgICAgICAgICAgIC8vTG9va3MgZG93blxuICAgICAgICAgICAgICAgIGlmKG1lbkRhdGEuaiA9PT0gMyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkSXRlcmF0ZSA9IE1hdGgubWluKHJ1bnRpbWUgLyAxMDAwLCAxKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlcyBtZW4ud2Fsa2Rvd24gdGhhdCBnZXRzIHJhbiBiZWZvcmUgYmFjayB0byAwXG4gICAgICAgICAgICAgICAgICAgIG1lbi53YWxrRG93biA9IDBcbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5zdGFydCA9IDE2XG4gICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuZGlzdGFuY2VYID0gMFxuICAgICAgICAgICAgICAgICAgICBtZW4uYXJjWCA9IChpbWFnZS54ICsgKCBtZW5EYXRhLmxhc3RQb3NYICsgKG1lbi53aWR0aC8yKzIpICkpICsgKCBtZW5EYXRhLmFyY1N0YXJ0WCAqIGhlYWRJdGVyYXRlIClcbiAgICAgICAgICAgICAgICAgICAgbWVuLmFyY1kgPSBpbWFnZS55ICsgKCBtZW5EYXRhLmxhc3RQb3NZKyA0KSArICggbWVuRGF0YS5hcmNTdGFydFkgKiBoZWFkSXRlcmF0ZSApXG4gICAgICAgICAgICAgICAgICAgIG1lbi5hcmNSYWRpdXMgPSBtZW5EYXRhLmhlYWRBcmMgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vUm90YXRlcyBiYWNrIGFuZCBmb3J0aFxuICAgICAgICAgICAgICAgIGlmKG1lbkRhdGEuaiA9PT0gNCl7XG4gICAgICAgICAgICAgICAgICAgIC8vMm5kIHJvdGF0ZWQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1JvdGF0ZWRQb3MgPSBtZW5EYXRhLnJvdGF0ZWRQb3MgLSAoIChtZW5EYXRhLnJvdGF0ZURlZ3JlZSAqIGl0ZXJhdGUgKSAtIG1lbkRhdGEucm90YXRlZFBvcylcbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5zdGFydCA9IDE0XG5cbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5kaXN0YW5jZVggPSAwXG5cbiAgICAgICAgICAgICAgICAgICAgbWVuLnRyYW5zbGF0ZVggPSBpbWFnZS54ICsgKG1lbkRhdGEubGFzdFBvc1ggKyBtZW4ud2lkdGgvMS44KVxuICAgICAgICAgICAgICAgICAgICBtZW4udHJhbnNsYXRlWSA9IGltYWdlLnkgKyAobWVuRGF0YS5sYXN0UG9zWSArIG1lbi5oZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRlID0gTWF0aC5taW4oICggcHJvZ3Jlc3MgKiAzKSwgMyApXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZihtZW5EYXRhLnJvdGF0ZWRQb3MgPD0gbWVuRGF0YS5yb3RhdGVEZWdyZWUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5yb3RhdGVkUG9zID0gKG1lbkRhdGEucm90YXRlRGVncmVlICogaXRlcmF0ZSkgXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW4ucm90YXRlICA9ICBtZW5EYXRhLnJvdGF0ZWRQb3NcblxuICAgICAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1JvdGF0ZSBiYWNrIGFuZCBmb3J0aFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobmV3Um90YXRlZFBvcyA+PSAwKSBtZW4ucm90YXRlID0gbmV3Um90YXRlZFBvc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobmV3Um90YXRlZFBvcyA8PSAwKSBtZW4ucm90YXRlID0gLW5ld1JvdGF0ZWRQb3M7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy91cGRhdGVzIHJvYXRlZFBvcyBmb3IgbWVuZGF0YS5qcyA9IDUgdG8gYmUgdXNlZCBiZWxvd1xuICAgICAgICAgICAgICAgICAgICBpZihwcm9ncmVzcyA9PT0gMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZW4uYXJjUmFkaXVzID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5yb2F0ZWRQb3MgPSBtZW4ucm90YXRlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9GYWxscyBEb3duXG4gICAgICAgICAgICAgICAgaWYobWVuRGF0YS5qID09PSA1KXtcbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5zdGFydCA9IHBhcnNlSW50KCAoIHByb2dyZXNzICogMTApLnRvRml4ZWQoMCkgKTtcblxuICAgICAgICAgICAgICAgICAgICBtZW4udHJhbnNsYXRlWCA9IGltYWdlLnggKyAobWVuRGF0YS5sYXN0UG9zWCArIG1lbi53aWR0aCAvIDIpICsgKCAodGhpcy53aWR0aCAvIDYgKSAqIHByb2dyZXNzIClcbiAgICAgICAgICAgICAgICAgICAgbWVuLnRyYW5zbGF0ZVkgPSBpbWFnZS55ICsgKG1lbkRhdGEubGFzdFBvc1kgKyBtZW4uaGVpZ2h0KSAgKyAoICh0aGlzLmhlaWdodCAvIDIpICogcHJvZ3Jlc3MgKVxuICAgICAgICAgICAgICAgICAgICBtZW4ucm90YXRlID0gbWVuRGF0YS5yb2F0ZWRQb3MgKyAoMTgwICogcHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuZGlzdGFuY2VYID0gMFxuICAgICAgICAgICAgICAgICAgICBpZihwcm9ncmVzcyA9PT0gMSkgbWVuLm9wYWNpdHkgPSAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKG1lbkRhdGEuaiA9PT0gNil7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBtZW4ub3BhYyA9IG1lbi5vcGFjaXR5ICsgKDEgKiBwcm9ncmVzcylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYobWVuLnN0YXJ0UG9zID09PSBtZW5EYXRhLnN0YXJ0KXsgXG5cbiAgICAgICAgICAgICAgICAgICAgLy9Db25zdGFuYXRseSB1cGRhdGVzIG1lbiBsb2NhdGlvbiBvbiB0aGUgSG91c2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RYID0gbWVuRGF0YS5sYXN0UG9zWCArICggbWVuRGF0YS5kaXN0YW5jZVggKiBwcm9ncmVzcyApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFkgPSBtZW5EYXRhLmxhc3RQb3NZICsgKCBtZW4ud2Fsa0Rvd24gfHwgMCApXG5cbiAgICAgICAgICAgICAgICAgICAgbWVuLnggPSBpbWFnZS54ICsgKG1lbkRhdGEubGFzdFBvc1ggKyAoIG1lbkRhdGEuZGlzdGFuY2VYICogcHJvZ3Jlc3MpIClcbiAgICAgICAgICAgICAgICAgICAgbWVuLnkgPSBpbWFnZS55ICArIChtZW5EYXRhLmxhc3RQb3NZICsgKG1lbi53YWxrRG93biB8fCAwKSApXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGRyYXdNZW4obWVuKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKHByb2dyZXNzIDwgMSl7XG5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vUmVzZXRzIG9yIHVwZGF0ZXMgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW5EYXRhLmxhc3RQb3NYID0gbGFzdFhcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbkRhdGEubGFzdFBvc1kgPSBsYXN0WVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5qKytcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuYmVnaW4gPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW5EYXRhLnN0YXJ0PTBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZHJhd0hvdXNlKGltYWdlLHRpbWVzdGFtcClcblxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhdylcblxuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hbmltYXRpb25zIC5zdGFydC1jYW52YXMnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgU3RhcnJ5TmlnaHQucHJvdG90eXBlLnRvZ2dsZSA9IHRydWVcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXcpXG5cbiAgICB9LmJpbmQodGhpcykpXG5cbiAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFuaW1hdGlvbnMgLnN0b3AtY2FudmFzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuXG4gICAgICAgIFN0YXJyeU5pZ2h0LnByb3RvdHlwZS50b2dnbGUgPSBmYWxzZVxuICAgIH0pXG59XG5cblN0YXJyeU5pZ2h0LnByb3RvdHlwZS5sb2FkSW1hZ2VzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgaGVpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggPCA3NjggPyA2MCA6IDgwXG4gICAgdmFyIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGggPCA3NjggPyA0OCA6IDY0XG4gICAgdmFyICR0aGlzID0gdGhpc1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGltYWdlcyA9IFtdXG4gICAgdmFyIGV4dCA9IGlzRmlyZWZveCA/IFwicG5nXCIgOiBcInN2Z1wiO1xuIFxuICAgIHZhciBtZW4gPSBbICAgICAgICAgXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi96ZXJvLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi9vbmUuXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL3R3by5cIitleHQsIGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGh9LFxuICAgICAgICB7c3JjOiBcImltYWdlcy9tZW4vdGhyZWUuXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL2ZvdXIuXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL2ZpdmUuXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL3NpeC5cIitleHQsIGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGh9LFxuICAgICAgICB7c3JjOiBcImltYWdlcy9tZW4vc2V2ZW4uXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL2VpZ2h0LlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi9uaW5lLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi90ZW4uXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL2VsZXZlbi5cIitleHQsIGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGh9LFxuICAgICAgICB7c3JjOiBcImltYWdlcy9tZW4vdHdlbHZlLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi90aGlydGVlbi5cIitleHQsIGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGh9LFxuICAgICAgICB7c3JjOiBcImltYWdlcy9tZW4vZm91cnRlZW4uXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL2ZpZnRlZW4uXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL2hlYWRsZXNzLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi9ob3VzZS1mbG9hdGluZy5cIitleHR9XG4gICAgXTtcblxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBtZW4ubGVuZ3RoOyBpKyspe1xuICAgICAgICBcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgdGhyb3cgaVxuICAgICAgICB9Y2F0Y2goaSl7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgIFxuICAgICAgICAgICAgICAgIGltYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaW1nOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG1lbltpXS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBtZW5baV0ud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFBvczogaVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCsrY291bnQgPT09IG1lbi5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9Tb3J0cyB0aGUgbWVuIGFycmF5IGluIG9yZGVyIGR1ZSB0byBsb2FkaW5nIGltYWdlcyBkaWZmZXJlbnRseVxuICAgICAgICAgICAgICAgICAgICBpbWFnZXMuc29ydChmdW5jdGlvbihhLGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnRQb3MgLSBiLnN0YXJ0UG9zO1xuICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXJyeU5pZ2h0LmltYWdlcyA9IGltYWdlcztcbiAgICAgICAgICAgICAgICAgICAgLy91cGRhdGVzIHRoZSB1bmRlZmluZWQgaG91c2UgcHJvcGVydHkgd2l0aCB0aGlzIGltZ1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5ob3VzZS5ob3VzZUltZyA9IGltZztcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYWRkRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmhvdXNlLmJlZ2luKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbWcuc3JjID0gbWVuW2ldLnNyY1xuICAgICAgICB9XG4gICAgfVxufTtcblxuXG52YXIgVGVjaG5vbG9naWVzID0gZnVuY3Rpb24oKSB7IFxuICAgIHZhciBzdmdQYWdlV2lkdGggPSAgXygnc3ZnLXBhZ2UnKS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJylcbiAgICB2YXIgc3ZnUGFnZUhlaWdodCA9IF8oJ3N2Zy1wYWdlJykuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKVxuICAgIHZhciB3aWR0aCA9IHN2Z1BhZ2VXaWR0aCA8IDk3MCAgfHwgc3ZnUGFnZUhlaWdodCA8IDgwMDtcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZWNoSWNvbnMnKTtcbiAgICBcbiAgICB0aGlzLmN0eCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgdGhpcy53aWR0aCA9IHRoaXMuY2FudmFzLndpZHRoID0gc3ZnUGFnZVdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gc3ZnUGFnZUhlaWdodDtcbiAgICB0aGlzLnN0YXJ0ID0gMDtcbiAgICB0aGlzLnN0YXJ0O1xuICAgIHRoaXMuYm9keURhdGEgPSBbXVxuICAgIHRoaXMuaWNvbnM7XG4gICAgdGhpcy5qID0gMFxuICAgIHZhciBuZXdUZWNobm9sb2dpZXMgPSB0aGlzXG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgICBhZGRCb2R5RGF0YTogIGZ1bmN0aW9uKCl7XG4gICAgXG4gICAgICAgICAgICBpZih3aWR0aCl7XG4gICAgICAgICAgICAgICAgLy9Cb2R5IGxvY2F0aW9uIFggYW5kIFlcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4IDogbmV3VGVjaG5vbG9naWVzLndpZHRoLzIgIC0gKG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS53aWR0aCAvIDIuMiksXG4gICAgICAgICAgICAgICAgICAgIHkgOiAobmV3VGVjaG5vbG9naWVzLmhlaWdodCAtIG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS5oZWlnaHQpICxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogbmV3VGVjaG5vbG9naWVzLndpZHRoLzIgLSAobmV3VGVjaG5vbG9naWVzLmJvZHlEYXRhWzNdLndpZHRoLzIpKzYwLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiAobmV3VGVjaG5vbG9naWVzLmhlaWdodCAtIG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS5oZWlnaHQpICs3MCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZFg6IG5ld1RlY2hub2xvZ2llcy53aWR0aC8yICAtIChuZXdUZWNobm9sb2dpZXMuYm9keURhdGFbMV0ud2lkdGggLyAyLjIpICsgNDEsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRZOiAobmV3VGVjaG5vbG9naWVzLmhlaWdodCAtIG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS5oZWlnaHQpIC0gNjFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4IDogbmV3VGVjaG5vbG9naWVzLndpZHRoLzIgIC0gKG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS53aWR0aCAvIDIuMiksXG4gICAgICAgICAgICAgICAgICAgIHkgOiAobmV3VGVjaG5vbG9naWVzLmhlaWdodCAtIG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS5oZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICAvL1RyYW5zbGF0ZSBoZWFkIHJvdGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVg6IG5ld1RlY2hub2xvZ2llcy53aWR0aC8yIC0gKG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVszXS53aWR0aC8yKSs4NSxcbiAgICAgICAgICAgICAgICAgICAgLy9UcmFuc2xhdGUgaGVhZCByb3RhdGlvblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiAobmV3VGVjaG5vbG9naWVzLmhlaWdodCAtIG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS5oZWlnaHQpICsgMTAwLFxuICAgICAgICAgICAgICAgICAgICBoZWFkWDogbmV3VGVjaG5vbG9naWVzLndpZHRoLzIgIC0gKG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS53aWR0aCAvIDIuMikgKyA1NyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZFk6IChuZXdUZWNobm9sb2dpZXMuaGVpZ2h0IC0gbmV3VGVjaG5vbG9naWVzLmJvZHlEYXRhWzFdLmhlaWdodCkgLSA4N1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcm90YXRlOiAtMTQwLFxuICAgICAgICBqOiAwLFxuICAgICAgICBib29rSGVpZ2h0OiAyMDBcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zcHJpdGVzID0gW11cbiAgICAgICBcbiAgICAgICAgdmFyIGV4dCA9IGlzRmlyZWZveCA/IFwicG5nXCIgOiBcInN2Z1wiO1xuXG4gICAgICAgIHZhciBib2R5V2lkdGggPSB3aWR0aCA/IDEuMyA6IDEuODtcbiAgICAgICAgdmFyIGJvZHlIZWlnaHQgPSB3aWR0aCA/IDEuMyA6IDEuODtcbiAgICAgICAgdmFyIHNyYyA9IFtcImltYWdlcy90b3AtaGVhZC5cIitleHQsIFwiaW1hZ2VzL2ZhY2UtYm9keS5cIitleHQsIFwiaW1hZ2VzL2Jvb2suXCIrZXh0LCBcImltYWdlcy9mdWxsLWJvZHkuXCIrZXh0XVxuXG4gICAgICAgIGlmKHdpZHRoKXtcblxuICAgICAgICAgICAgdmFyIGltZ1dpZHRoID0gWzI4NC41ICw0MDAsIDMyMC45NiwgNDAwXVxuICAgICAgICAgICAgdmFyIGltZ0hlaWdodCA9IFsxNzAuOSwgNDgzLjcsIDIyNi44LCA1NjQuNjZdXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdmFyIGltZ1dpZHRoID0gWzU1My41LCA3NzguMiwgNjI5LjksIDc3OF1cbiAgICAgICAgICAgIHZhciBpbWdIZWlnaHQgPSBbMzMyLjQ5LCA5NDEsIDQ0My4yNywgMTA5OC45XVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIHRoaXMuaW1nSWNvbnMgPSBbXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvYWRvYmUtNTAtNTAuXCIrZXh0LCB3aWR0aDogNDAsIGhlaWdodDogNDB9LFxuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL2FmdGVyLWVmZmVjdHMtNTItNTIuXCIrZXh0LCB3aWR0aDogNDAsIGhlaWdodDogNDB9LFxuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL2FydGlzdGljLTUyLTU0LlwiK2V4dCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQyfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9ib290c3RyYXAtNTAtNTAuXCIrZXh0LCB3aWR0aDogNDAsIGhlaWdodDogNDB9LFxuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL2NhbWVyYS01Mi01Mi5cIitleHQsIHdpZHRoOiA0MCwgaGVpZ2h0OiA0MH0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvY2xvdWQtNjQtNDkuNS5cIitleHQsIHdpZHRoOiA0MiwgaGVpZ2h0OiAzMi41fSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9jb2RlLTYwLTUzLlwiK2V4dCwgd2lkdGg6IDQzLCBoZWlnaHQ6IDM4fSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9jc3MtNTUtNTIuXCIrZXh0LCB3aWR0aDogNDIsIGhlaWdodDogMzkuOH0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvZGVzaWduLTUyLTUyLlwiK2V4dCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQwfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9naXQtaHViLTU1LTU1LlwiK2V4dCwgd2lkdGg6IDQzLCBoZWlnaHQ6IDQzfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9nb29nbGUtZHJpdmUtNzItNjQuXCIrZXh0LCB3aWR0aDogNDYsIGhlaWdodDogNDAuOH0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvaWxsdXN0cmF0b3ItNTItNTIuXCIrZXh0LCB3aWR0aDogNDAsIGhlaWdodDogNDB9LFxuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL2pzLTU1LTU2LlwiK2V4dCwgd2lkdGg6IDQxLCBoZWlnaHQ6IDQyfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9ub2RlLTUwLTUwLlwiK2V4dCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQwfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9ub2RlanMtNjAuNS0zNy5cIitleHQsIHdpZHRoOiA1NSwgaGVpZ2h0OiAzMy42fSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9ucG0tNzAtMjcuMi5cIitleHQsIHdpZHRoOiA2NSwgaGVpZ2h0OiAyNS4yfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9waG90b3Nob3AtNTItNTIuXCIrZXh0LCB3aWR0aDogNDAsIGhlaWdodDogNDB9LFxuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL3BocC02NS0zNS5cIitleHQsIHdpZHRoOiA0NSwgaGVpZ2h0OiAyNC4yfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9weXRob24tNTctNTguXCIrZXh0LCB3aWR0aDogNDAsIGhlaWdodDogNDAuN30sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvcmVhY3QtNTktNTIuXCIrZXh0LCB3aWR0aDogNDIsIGhlaWdodDogMzd9LFxuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL3NlcnZlci01NS01OC5cIitleHQsIHdpZHRoOiA0MCwgaGVpZ2h0OiA0MH1cbiAgICAgICAgXVxuXG4gICAgdGhpcy5sb29wSW1ncyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBsb2FkID0gW11cblxuICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgNDsgaisrKXtcbiAgICAgICAgICAgIGxvYWQucHVzaCh7XG4gICAgICAgICAgICAgICAgc3JjOiBzcmNbal0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IGltZ1dpZHRoW2pdIC8gYm9keVdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogaW1nSGVpZ2h0W2pdIC8gYm9keUhlaWdodFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICB2YXIgaWNvbnMgPSB0aGlzLmltZ0ljb25zXG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGljb25zLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHZhciB3ID0gIXdpZHRoID8gaWNvbnNbaV0uc3JjLnJlcGxhY2UoL14oW2EtelxcL10rKVxcLyhbYS16LT9dKyktKFxcZFxcZCkoLispL2lnLFwiJDNcIikgOiBpY29uc1tpXS53aWR0aFxuICAgICAgICAgICAgdmFyIGggPSAhd2lkdGggPyBpY29uc1tpXS5zcmMucmVwbGFjZSgvXiguKykoXFxkezJ9KSguKykvaWcsXCIkMlwiKSA6IGljb25zW2ldLmhlaWdodFxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2codyxoLCBpKTtcbiAgICAgICAgICAgIGxvYWQucHVzaCh7XG4gICAgICAgICAgICAgICAgc3JjOiBpY29uc1tpXS5zcmMsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHBhcnNlSW50KHcpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyc2VJbnQoaClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvYWRcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCl7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAgKG1heCAtIG1pbiApICsgbWluKVxuICAgIH07XG4gICAgdGhpcy5hZGREYXRhID0gZnVuY3Rpb24obil7XG4gICAgICAgIHZhciBpY29ucyA9IHRoaXMuaWNvbnNcbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IG47IGkrKyApe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnNwcml0ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgLy9FYWNoIGljb24gZHJhd3MgZm9yIGV2ZXIgMzAgbWlsIHNlY1xuICAgICAgICAgICAgICAgIHRpbWluZzogIDMwLFxuICAgICAgICAgICAgICAgIGVuZFg6IHJhbmRvbSgwLCB0aGlzLndpZHRoLzIgKSxcbiAgICAgICAgICAgICAgICBlbmRZOiByYW5kb20oMCwgdGhpcy5oZWlnaHQgLSAodGhpcy5ib2R5RGF0YVsxXS5oZWlnaHQgKyA1MCkgKSxcbiAgICAgICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgICAgICBzcGVlZDogcmFuZG9tKDQwMDAsIDkwMDApLFxuICAgICAgICAgICAgICAgIHg6IHRoaXMud2lkdGggLyAyLFxuICAgICAgICAgICAgICAgIHk6IHRoaXMuZGF0YS5hZGRCb2R5RGF0YSgpLnkgKyAxNSwgLy8gcGx1cyAxMDAgdGhlIHNwcml0ZSBzaXplXG4gICAgICAgICAgICAgICAgaW1nOiB0aGlzLmljb25zW2klaWNvbnMubGVuZ3RoXS5pbWcsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuaWNvbnNbaSVpY29ucy5sZW5ndGhdLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5pY29uc1tpJWljb25zLmxlbmd0aF0uaGVpZ2h0LFxuICAgICAgICAgICAgICAgIFg6IDAsXG4gICAgICAgICAgICAgICAgWTogMCxcbiAgICAgICAgICAgICAgICBzdGF0aWNTcGVlZDogMCxcbiAgICAgICAgICAgICAgICByb3RhdGU6IHJhbmRvbSgxODAsIDE0NDApXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5UZWNobm9sb2dpZXMucHJvdG90eXBlLnJvdGF0ZUhlYWQgPSBmdW5jdGlvbihyb3RhdGUsIHBvcyl7XG5cbiAgICB2YXIgaW1nID0gdGhpcy5ib2R5RGF0YVxuICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLDAsdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodClcbiAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1nWzFdLmltZywgIHBvcy54LCBwb3MueSwgaW1nWzFdLndpZHRoLCBpbWdbMV0uaGVpZ2h0KSAvL0ZhY2UgYm9keVxuICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSggIHBvcy50cmFuc2xhdGVYLCBwb3MudHJhbnNsYXRlWSk7IC8vIFRyYW5zbGF0ZSBcbiAgICB0aGlzLmN0eC5yb3RhdGUocm90YXRlICogTWF0aC5QSS8xODApXG4gICAgdGhpcy5jdHgudHJhbnNsYXRlKCAtcG9zLnRyYW5zbGF0ZVgsLXBvcy50cmFuc2xhdGVZICk7IC8vIFRyYW5zbGF0ZSBiYWNrXG4gICAgdGhpcy5jdHguZHJhd0ltYWdlKGltZ1swXS5pbWcsICBwb3MuaGVhZFggLCAgcG9zLmhlYWRZLCBpbWdbMF0ud2lkdGgsIGltZ1swXS5oZWlnaHQpICAvL0hlYWQgZHJhdyBpbiB0cmFuc2xhdGVkIGNhbnZlc1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbn07XG5cblRlY2hub2xvZ2llcy5wcm90b3R5cGUuZHJhd0Jvb2sgPSBmdW5jdGlvbihkYXRhLCBwb3Mpe1xuICAgIHZhciBpbWcgPSB0aGlzLmJvZHlEYXRhXG4gICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsMCx0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KVxuICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdmVyJ1xuICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWdbMV0uaW1nLCAgcG9zLngsIHBvcy55LCBpbWdbMV0ud2lkdGgsIGltZ1sxXS5oZWlnaHQpIC8vRmFjZSBib2R5XG4gICAgdGhpcy5jdHgudHJhbnNsYXRlKCAgcG9zLnRyYW5zbGF0ZVgsIHBvcy50cmFuc2xhdGVZKTsgLy8gVHJhbnNsYXRlIFxuICAgIHRoaXMuY3R4LnJvdGF0ZSgtMTQwICogTWF0aC5QSS8xODApXG4gICAgdGhpcy5jdHgudHJhbnNsYXRlKCAtcG9zLnRyYW5zbGF0ZVgsLXBvcy50cmFuc2xhdGVZICk7IC8vIFRyYW5zbGF0ZSBiYWNrXG4gICAgdGhpcy5jdHguZHJhd0ltYWdlKGltZ1swXS5pbWcsICBwb3MuaGVhZFggLCAgcG9zLmhlYWRZLCBpbWdbMF0ud2lkdGgsIGltZ1swXS5oZWlnaHQpICAvL0hlYWQgZHJhdyBpbiB0cmFuc2xhdGVkIGNhbnZlc1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCk7XG5cbiAgICB0aGlzLmN0eC50cmFuc2xhdGUoICBwb3MudHJhbnNsYXRlWCArIGltZ1syXS53aWR0aCAvIDIsIHBvcy50cmFuc2xhdGVZKTsgLy8gVHJhbnNsYXRlICBcbiAgICB0aGlzLmN0eC5zY2FsZShkYXRhLnNjYWxlLCBkYXRhLnNjYWxlKTsgLy9TY2FsZXMgYm9va1xuICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSggLXBvcy50cmFuc2xhdGVYIC0gaW1nWzJdLndpZHRoIC8gMiAsLXBvcy50cmFuc2xhdGVZICk7IC8vIFRyYW5zbGF0ZSBiYWNrIGZvclxuICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWdbMl0uaW1nLCBkYXRhLmJvb2tYLCBkYXRhLmJvb2tZLCBpbWdbMl0ud2lkdGgsIGltZ1syXS5oZWlnaHQpIC8vYm9vayBpbWFnZVxuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCk7XG59O1xuXG5UZWNobm9sb2dpZXMucHJvdG90eXBlLmRyYXdCb2R5ID0gZnVuY3Rpb24oZGF0YSwgcG9zICl7XG4gICAgdmFyIGltZyA9IHRoaXMuYm9keURhdGFcblxuICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWdbMV0uaW1nLCAgcG9zLngsIHBvcy55LCBpbWdbMV0ud2lkdGgsIGltZ1sxXS5oZWlnaHQpIC8vRmFjZSBib2R5XG4gICAgdGhpcy5jdHgudHJhbnNsYXRlKCAgcG9zLnRyYW5zbGF0ZVgsIHBvcy50cmFuc2xhdGVZKTsgLy8gVHJhbnNsYXRlIFxuICAgIHRoaXMuY3R4LnJvdGF0ZSgtMTQwICogTWF0aC5QSS8xODApXG4gICAgdGhpcy5jdHgudHJhbnNsYXRlKCAtcG9zLnRyYW5zbGF0ZVgsLXBvcy50cmFuc2xhdGVZICk7IC8vIFRyYW5zbGF0ZSBiYWNrXG4gICAgdGhpcy5jdHguZHJhd0ltYWdlKGltZ1swXS5pbWcsICBwb3MuaGVhZFggLCAgcG9zLmhlYWRZLCBpbWdbMF0ud2lkdGgsIGltZ1swXS5oZWlnaHQpICAvL0hlYWQgZHJhdyBpbiB0cmFuc2xhdGVkIGNhbnZlc1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCk7XG4gICAgdGhpcy5jdHgudHJhbnNsYXRlKCAgcG9zLnRyYW5zbGF0ZVggKyBpbWdbMl0ud2lkdGggLyAyLCBwb3MudHJhbnNsYXRlWSk7IC8vIFRyYW5zbGF0ZSAgXG4gICAgdGhpcy5jdHguc2NhbGUoMS4wNSwgMS4wNSk7XG4gICAgdGhpcy5jdHgudHJhbnNsYXRlKCAtcG9zLnRyYW5zbGF0ZVggLSBpbWdbMl0ud2lkdGggLyAyICwtcG9zLnRyYW5zbGF0ZVkgKTsgLy8gVHJhbnNsYXRlIGJhY2tcbiAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1nWzJdLmltZywgZGF0YS5ib29rWCwgZGF0YS5ib29rWSwgaW1nWzJdLndpZHRoLCBpbWdbMl0uaGVpZ2h0KSAvL2Jvb2sgaW1hZ2VcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApO1xufTtcblxuVGVjaG5vbG9naWVzLnByb3RvdHlwZS5kcmF3SWNvbnMgPSBmdW5jdGlvbihzcHIpe1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLCBzcHIuWCwgc3ByLlkpO1xuICAgIHRoaXMuY3R4LnJvdGF0ZShzcHIudHVybiAqIE1hdGguUEkvMTgwKVxuICAgIHRoaXMuY3R4LmRyYXdJbWFnZShzcHIuaW1nLC1zcHIud2lkdGgvMiwgLXNwci5oZWlnaHQvMiwgc3ByLndpZHRoLCBzcHIuaGVpZ2h0ICk7XG4gICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKVxufTtcblxuVGVjaG5vbG9naWVzLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24odGltZXN0YW1wKXtcbiAgICBpZighdGhpcy50b2dnbGUpIHJldHVyblxuICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGggPCA5NzAgIHx8IHRoaXMuaGVpZ2h0IDwgODAwXG4gICAgdmFyIGltZyA9IHRoaXMuYm9keURhdGFcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgcG9zID0gZGF0YS5hZGRCb2R5RGF0YSgpO1xuICAgIFxuICBcbiAgICBpZighdGhpcy5zdGFydClcbiAgICAgICAgdGhpcy5zdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICB2YXIgcnVudGltZSA9IHRpbWVzdGFtcCAtIHRoaXMuc3RhcnRcbiAgICAgICAgdmFyIHByb2dyZXNzID0gTWF0aC5taW4ocnVudGltZSAvIDEwMDAsIDEpXG5cbiAgICAgICAgaWYocHJvZ3Jlc3MgPCAxICYmIGRhdGEuaiA8PSAxKXtcbiAgICAgIFxuICAgICAgICAgICAgaWYod2lkdGgpe1xuICAgICAgICAgICAgICAgIC8vVXBkYXRlcyB4IGxvYWN0aW9ucyBhbmQgeSBsb2NhdGlvbiBvZiBib29rXG4gICAgICAgICAgICAgICAgZGF0YS5ib29rWCA9ICgocG9zLnRyYW5zbGF0ZVgpLTQwKSAtICgwKVxuICAgICAgICAgICAgICAgIGRhdGEuYm9va1kgPSAoKHBvcy50cmFuc2xhdGVZKS0xMTApIC0gKDYwKnByb2dyZXNzKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIC8vVXBkYXRlcyB4IGxvYWN0aW9ucyBhbmQgeSBsb2NhdGlvbiBvZiBib29rXG4gICAgICAgICAgICAgICAgZGF0YS5ib29rWCA9ICgocG9zLnRyYW5zbGF0ZVgpLTYwKSAtICgwKTtcbiAgICAgICAgICAgICAgICBkYXRhLmJvb2tZID0gKChwb3MudHJhbnNsYXRlWSktMTgwKSAtICg2MCpwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1JvdGF0ZSBoZWFkXG4gICAgICAgICAgICBpZihkYXRhLmogPT09IDApe1xuXG4gICAgICAgICAgICAgICAgdmFyIHJvdGF0ZSA9IGRhdGEucm90YXRlKnByb2dyZXNzO1xuICAgICAgICAgICAgICAgIHRoaXMucm90YXRlSGVhZChyb3RhdGUscG9zKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9QVXNoIHVwIGJvb2tcbiAgICAgICAgICAgIGlmKGRhdGEuaiA9PT0gMSl7XG5cbiAgICAgICAgICAgICAgICBkYXRhLnNjYWxlID0gLjUgKyAoLjU1ICogcHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3Qm9vayhkYXRhLHBvcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG5cbiAgICAgICAgICAgIC8vRHJhdyBJY29uc1xuICAgICAgICAgICAgaWYoZGF0YS5qID09PSAyKXtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLDAsdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodClcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdCb2R5KGRhdGEsIHBvcylcblxuICAgICAgICAgICAgICAgIHZhciBzcHJpdGVzID0gdGhpcy5zcHJpdGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNwcml0ZXM7IGkrKyApe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwciA9IHRoaXMuc3ByaXRlc1tpXVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoaSA8PSB0aGlzLmope1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByLnN0YXRpY1NwZWVkKytcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighc3ByLnN0YXJ0KSBzcHIuc3RhcnQgPSB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydW4gPSB0aW1lc3RhbXAgLSBzcHIuc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9nID0gcnVuIC8gc3ByLnNwZWVkXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpJTIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbGVmdCB1cFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwci5YID0gc3ByLnggLSAoc3ByLmVuZFggKiBwcm9nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwci5ZID0gc3ByLnkgLSAoc3ByLmVuZFkgKiBwcm9nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwci50dXJuID0gLXNwci5yb3RhdGUgKiBwcm9nXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmlnaHQgdXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByLlggPSBzcHIueCArIChzcHIuZW5kWCAqIHByb2cpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByLlkgPSBzcHIueSAtIChzcHIuZW5kWSAqIHByb2cpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByLnR1cm4gPSBzcHIucm90YXRlICogcHJvZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByLnRvdGFsWCA9IHNwci5YXG4gICAgICAgICAgICAgICAgICAgICAgICBzcHIudG90YWxZID0gc3ByLllcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIChzcHIudG90YWxYK3Nwci53aWR0aCkgPD0gMCB8fCAoc3ByLnRvdGFsWStzcHIuaGVpZ2h0KSA8PSAwIHx8IHNwci50b3RhbFggPiB0aGlzLndpZHRoK3Nwci53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vUmVzZXRzIHZhbHVlcywgZm9yIHNhbWUgaWNvbiB0byBydW4gYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0uc3RhcnQgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdJY29ucyhzcHIpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzcHIuc3RhdGljU3BlZWQgPT09IHNwci50aW1pbmcpIHRoaXMuaisrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0gMFxuICAgICAgICAgICAgICAgIGRhdGEuaisrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuZHJhdy5iaW5kKHRoaXMpKVxufTtcblxuXG5UZWNobm9sb2dpZXMucHJvdG90eXBlLmxvYWRJbWFnZXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHZhciBsb2FkZWRJbWFnZXMgPSAwO1xuICAgIHZhciBpbWdzID0gW107XG4gICAgXG4gICAgdGhpcy5sb29wSW1ncygpLmZvckVhY2goZnVuY3Rpb24oaW1hZ2UsIGkpe1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKVxuXG4gICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAvL1dpZHRoIG9yIGhlaWdodCBkb2Vzbid0IGV4aXN0IHVwZGF0ZXMgMCBmb3IgaXRcbiAgICAgICAgICAgIGltZ3MucHVzaCh7aW1nOiB0aGlzLCBpLCB3aWR0aDogaW1hZ2Uud2lkdGggLCBoZWlnaHQ6IGltYWdlLmhlaWdodCB9KVxuXG4gICAgICAgICAgICBpZigrK2xvYWRlZEltYWdlcyA+PSBjb3VudGVyKXsgICAgIFxuICAgICAgICAgICAgICAgIGltZ3Muc29ydChmdW5jdGlvbihhLGIpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5pIC0gYi5pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvL1doZW4gSWNvbnMgbG9hZCBmdWxsIGJvZHkgaW1hZ2UgZ2V0cyBhZGRlZFxuICAgICAgICAgICAgICAgICR0aGlzLmN0eC5kcmF3SW1hZ2UoaW1nc1szXS5pbWcsICgkdGhpcy53aWR0aC8yKSAtIGltZ3NbMV0ud2lkdGggLyAyLjIsICgkdGhpcy5oZWlnaHQpIC0gaW1nc1szXS5oZWlnaHQsIGltZ3NbM10ud2lkdGgsIGltZ3NbM10uaGVpZ2h0KSAvL0Z1bGwtYm9keSBpbWFnZVxuICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgYm9keUltZ3MgPSBpbWdzLnNwbGljZSgwLDQpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJHRoaXMuYm9keURhdGEgPSBib2R5SW1nc1xuICAgICAgICAgICAgICAgICR0aGlzLmljb25zID0gaW1nc1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9JY29uIGRhdGFcbiAgICAgICAgICAgICAgICAkdGhpcy5hZGREYXRhKGltZ3MubGVuZ3RoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGltZy5zcmMgPSBpbWFnZS5zcmM7XG4gICAgfSlcbn07XG5cblxuZnVuY3Rpb24gU3ZnUGFnZSgpe1xuICAgIHZhciBzdmdDbG9zZUJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Nsb3NlLWJ0biBzdmctYnV0dG9uJylbMF1cbiAgICB2YXIgc3ZnQ2lyY2xlID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc3ZnLWNpcmNsZScpWzBdXG4gICAgdmFyIHRvZ2dsZSwgYnRuT3BlbiwgZXZlbnQ7XG4gICAgdmFyIGhvdmVybWFwID0gaG92ZXJNYXAoKVxuICAgIFxuICAgIHZhciByZW1vdmVHb29leSA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICBzZXRUaW1lb3V0KCAoKSA9PiB7XG4gICAgICAgICAgICBob3Zlcm1hcFsxXShlKVxuICAgICAgICB9LDE0MDApXG4gICAgICAgIFxuICAgICAgICAvLyAgICBjb25zb2xlLmxvZyggaG92ZXJtYXBbMV0pXG4gICAgICAgIC8vICAgICB2YXIgZGlzdCA9IGhvdmVybWFwWzFdKGUpWzBdOyAvLyBQb3NpdGlvbiBkaXN0YW5jZSBvZiBzaG93LWljb24gZ29vZXlcbiAgICAgICAgLy8gICAgIGhvdmVybWFwWzBdKCBkaXN0LCB0cnVlICkgIC8vIGhhbmRsZXIoZSkgZnVuY3Rpb25cblxuICAgIH1cbiAgICB0aGlzLnN0YXJ0O1xuICAgIC8vUGFnZSBhbmltYXRlZCBkb3duIHJlbW92ZXMgY2lyY2xlIHRvIGJlIGFuaW1hdGVkIGFnYWluXG4gICAgdGhpcy5hbmltYXRlRW5kID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoZXkgeW91JylcbiAgICAgICAgIF8oJ2ludGVyYWN0aXZlLWNvbnRhaW5lcicpLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYXV0bycgXG5cbiAgICAgICAgaWYodG9nZ2xlKXtcbiAgICAgICAgICAgIC8vU2FmYXJpIG9ubHlcbiAgICAgICAgICAgIF8oJ3N2Zy1wYWdlJykuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nXG4gICAgICAgICAgICBzdmdDaXJjbGUuY2xhc3NMaXN0LnJlbW92ZSgnY2lyY2xlLWFuaW1hdGUnKTtcblxuICAgICAgICAgICAgXyhidG5PcGVuKVswXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdnLicrYnRuT3BlbisnIC5pdGVtcycpLmNsYXNzTGlzdC5yZW1vdmUoJ2l0ZW1zLWFjdGl2ZScpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRvZ2dsZSA9IGZhbHNlXG4gICAgICAgIH0gICBcbiAgICB9XG5cbiAgICB0aGlzLmFuaW1hdGVDaXJjbGUgPSBmdW5jdGlvbih0aW1lc3RhbXAsIGVsZW0pe1xuICAgICAgICBcbiAgICAgICAgaWYoIXRoaXMuc3RhcnQpIHRoaXMuc3RhcnQgPSB0aW1lc3RhbXA7XG5cbiAgICAgICAgICAgIHZhciBydW50aW1lID0gdGltZXN0YW1wIC0gdGhpcy5zdGFydDtcbiAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IE1hdGgubWluKHJ1bnRpbWUgLyB0aGlzLnNwZWVkLCAxKVxuICAgICAgICAgICAgaXNGaXJlZm94ID8gc3ZnQ2lyY2xlLnNldEF0dHJpYnV0ZSgncicsIDE1MDAgKiBwcm9ncmVzcykgOiBzdmdDaXJjbGUuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKCcrICgwICsgKDEqcHJvZ3Jlc3MpICkrICcpJ1xuICAgICAgIFxuICAgICAgICBpZihwcm9ncmVzcyA8IDEpIHtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbih0aW1lc3RhbXApe1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZUNpcmNsZSh0aW1lc3RhbXAsIGVsZW0pXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgIC8vQ2FudmFzIGZhZGVzIGluIGFmdGVyIHBhZ2UgaXMgYW5pbWF0ZWQgb3BlblxuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZy4nK2VsZW0rJyAuaXRlbXMnKS5jbGFzc0xpc3QuYWRkKCdpdGVtcy1hY3RpdmUnKVxuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShlbGVtKVsxXS5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Nob3dDYW52YXMnKVxuICAgICAgICAgICAgdGhpcy5zdGFydCA9IG51bGw7XG4gICAgICAgIH0gXG4gICAgfVxuICAgIHZhciBjbG9zZUJ1dHRvblNob3cgPSBmdW5jdGlvbihudW0pe1xuICAgICAgICB2YXIgb3Bwb3NpdGUgPSAhbnVtID8gLTU2IDogMFxuICAgICAgICAgXygneC1jaXJjbGUnKS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWCgnKyBudW0gKydweCknXG4gICAgICAgICBfKCdsaW5lJylbMF0uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVgoJysgb3Bwb3NpdGUgKydweCkgcm90YXRlKC00NWRlZyknXG4gICAgICAgICBfKCdsaW5lJylbMV0uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVgoJysgb3Bwb3NpdGUgKydweCkgcm90YXRlKDQ1ZGVnKSdcbiAgICB9XG5cbiAgICAvLyBPcGVuIHBhZ2UgZnVuY3Rpb25cbiAgICB0aGlzLm9wZW5Nb2RhbHMgPSBmdW5jdGlvbihlKXtcblxuICAgICAgICB0cnl7XG4gICAgICAgICAgICBidG5PcGVuID0gZS50YXJnZXQuaWRcbiAgICAgICAgfWNhdGNoKGVycil7XG4gICAgICAgICAgICBidG5PcGVuID0gZVxuICAgICAgICB9XG4gIFxuICAgICAgICBfKCdpbnRlcmFjdGl2ZS1jb250YWluZXInKS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnIFxuICAgICAgICBldmVudCA9IGVcbiAgICAgICAgXyhidG5PcGVuKVswXS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICBjbG9zZUJ1dHRvblNob3coLTU2KVxuICAgICAgICAvL0dvb2dsZSAnRG8gSHllb24nIGZvbnQgYnVnLCBmdW5jdGlvbiBoYXMgdG8gYmUgcmFuIGFnYWluIGluIHZpZXdcbiAgICAgICAgaWYoYnRuT3BlbiA9PT0gJ3Bob3RvJykgc2xvdE1hY2hpbmUoKVxuICAgICAgICAvL1Rocm9iYmluZyBGaW5nZXIgaW1hZ2UgaWNvblxuICAgICAgICBpZihidG5PcGVuID09PSAnZGVzaWduJykgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZpbmdlcicpLmNsYXNzTGlzdC5hZGQoJ2Zpbmdlci1zY2FsZScpXG5cbiAgICAgICAgaWYoaXNTYWZhcmkpe1xuXG4gICAgICAgICAgICB0b2dnbGUgPSB0cnVlO1xuICAgICAgICAgICAgIF8oJ3N2Zy1wYWdlJykuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiXG4gICAgICAgICAgICBzdmdDaXJjbGUuY2xhc3NMaXN0LmFkZCgnY2lyY2xlLWFuaW1hdGUnKVxuXG4gICAgICAgICAgICBzdmdDaXJjbGUub25hbmltYXRpb25lbmQgPSBmdW5jdGlvbigpe1xuICAgICAgXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZy4nK2J0bk9wZW4rJyAuaXRlbXMnKS5jbGFzc0xpc3QuYWRkKCdpdGVtcy1hY3RpdmUnKVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYnRuT3BlbilbMV0ucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzaG93Q2FudmFzJylcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL0Nsb3NlcyB0aGUgcGFnZSBhbmltYXRlZCBkb3duXG4gICAgICAgICAgICBzdmdDbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdG9nZ2xlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIC8vQXV0b21hdGljYWxseSBzdG9wcyBjYW52YXMgXG4gICAgICAgICAgICAgICAgU3RyZXRjaC5wcm90b3R5cGUudG9nZ2xlID0gZmFsc2VcbiAgICAgICAgICAgICAgICBzbG90TWFjaGluZS5wcm90b3R5cGUudG9nZ2xlID0gZmFsc2VcbiAgICAgICAgICAgICAgICBTdGFycnlOaWdodC5wcm90b3R5cGUudG9nZ2xlID0gZmFsc2VcbiAgICAgICAgICAgICAgICBUZWNobm9sb2dpZXMucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vQ2FudmFzIC8gSXRlbXMgZmFkZXMgb3V0XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShidG5PcGVuKVsxXS5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3dDYW52YXMnKVxuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0b2dnbGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKHRpbWVzdGFtcCl7XG4gICAgICAgICAgICAgICAgdGhpcy5zcGVlZCA9IDYwMDtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGVDaXJjbGUodGltZXN0YW1wLCBidG5PcGVuKVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuXG4gICAgICAgICAgICBzdmdDbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgIGNsb3NlQnV0dG9uU2hvdygwKVxuICAgICAgICAgICAgICAgIFN0cmV0Y2gucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgc2xvdE1hY2hpbmUucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgU3RhcnJ5TmlnaHQucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgVGVjaG5vbG9naWVzLnByb3RvdHlwZS50b2dnbGUgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYnRuT3BlbilbMV0ucGFyZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Q2FudmFzJylcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJlZm94ID8gXygnc3ZnLWNpcmNsZScpLnNldEF0dHJpYnV0ZSgncicsIDApIDogXygnc3ZnLWNpcmNsZScpLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgwKSdcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9DdXJyZW50IFNWRyBlbGVtZW50IGhpZGVzXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYnRuT3BlbilbMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdnLicrYnRuT3BlbisnIC5pdGVtcycpLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3dDYW52YXMnKVxuICAgICAgICAgICAgICAgICAgICAvLyBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGJ0bk9wZW4pWzFdLnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnc2hvd0NhbnZhcycpXG4gICAgICAgICAgICAgICAgfSwxOTAwKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB2YXIgcG9wVXBDYXJkcyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCBvcGVuX21vZGFscyA9IHRoaXMub3Blbk1vZGFsc1xuXG4gICAgICAgIGxldCBwb3BVcGNhcmRzID0gXygnY2FyZC1wb3B1cHMnKVxuICAgICAgICBmb3IobGV0IGNhcmRzIG9mIHBvcFVwY2FyZHMpe1xuICAgICAgICAgICAgY2FyZHMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICByZW1vdmVHb29leShlKVxuICAgICAgICAgICAgICAgIG9wZW5fbW9kYWxzKHRoaXMuYXR0cmlidXRlc1szXS52YWx1ZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcylcbiAgICBpZih3VyA8IDc2OCkgcG9wVXBDYXJkcygpXG4gICAgXG4gICAgXygnY2lyY2xlLXRodW1ibmFpbHMnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgICAgICBpZih3VyA8IDc2OCl7XG4gICAgICAgICAgICBob3Zlcm1hcFsxXShlKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJlbW92ZUdvb2V5KGUpXG4gICAgICAgICAgICB0aGlzLm9wZW5Nb2RhbHMoZSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgIFxuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuLy9BZGQgdG8gd2luZG93IG9iamVjdCB0byBiZSB1c2VkIGZvciBodG1sIHBhZ2Ugb25lbmQgZnVuY3Rpb25cbndpbmRvdy5zdmdQYWdlID0gbmV3IFN2Z1BhZ2UoKTtcblxuIFxuXG5mdW5jdGlvbiBnZXRQb3MoZWxlKXtcbiAgICAgICAgXG4gICAgdmFyIGVsZW1SZWN0ID0gZWxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBtYWluU3ZnID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc3ZnLXBhZ2UnKVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgZWxlbUxlZnQgPSAobWFpblN2Zy53aWR0aCAtICggcGFyc2VJbnQoZWxlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSApIHx8IGVsZW1SZWN0LndpZHRoKSApIC8gMlxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGVsZW1SZWN0LndpZHRoLFxuICAgICAgICBtYWluU3ZnOiBtYWluU3ZnLFxuICAgICAgICBsZWZ0OiBlbGVtUmVjdC5sZWZ0LFxuICAgICAgICB0b3A6IGVsZW1SZWN0LnRvcCxcbiAgICAgICAgaGVpZ2h0OiBlbGVtUmVjdC5oZWlnaHQsXG4gICAgICAgIC8vUGxhY2VzIGltYWdlJ3MgcHJvcGVydHkgbGVmdCB0byB0aGUgY2VudGVyIG9mIGl0J3MgY29udGFpbmVyIChjZW50ZXIgb2YgcGFnZSlcbiAgICAgICAgY2VudGVyZWRMZWZ0OiBlbGVtTGVmdFxuICAgIH1cbn07XG5cblxuLy9EaWZmZXJlbnQgc2NyZWVuIHNpemluZyAsIGVsZW1lbnRzIGFkanVzdCB0byBpdFxuZnVuY3Rpb24gYWRqdXN0RWxlbWVudHMoKXtcbiAgICB2YXIgcGF0aEQ3NjggPSBcIk01NjUuMSwwdjkwMEgwYzAsMCwwLTc1LjMsMC0xOTIuNGMwLTIxMS43LDAtMzAzLjcsMC01MzMuMUMwLDUwLjUsMCwwLDAsMEg1NjUuMXpcIjtcbiAgICB2YXIgcGF0aEQ0MDAgPSBcIk0zOTAsODAwSDBjMCwwLDAtODcuMywwLTE2MS4zUzAsODQsMCw0Ny4zUzAsMCwwLDBoMzkwVjgwMHpcIjtcbiAgICB2YXIgc21hbGxTcGxpbmVzID0gXCIuNDIgMCAxIDE7LjQyIDAgMSAxOy40MiAwIDEgMTsuNDIgMCAxIDE7XCJcbiAgICB2YXIgc21hbGxLZXlUaW1lcyA9IFwiMDsgMC4yMDsgMC40NTsgMVwiXG4gICAgdmFyIHN2ZyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3N2Zy1wYWdlJylbMF1cbiAgICBcbiAgICAvL1NldHMgc2l6aW5nIGZvciBvcGVuaW5nIGNsb3Npbmcgc3ZnLXBhZ2Ugd2F2ZVxuICAgIGlmKHdIIDwgODQwICYmIHdXKXtcbiAgICAgICAgdmFyIHN2Z1dpZHRoID0gd1cgPCA1MDAgPyB3VyAtIDIwIDogd1cgLSA1MDtcbiAgICAgICAgdmFyIHN2Z0hlaWdodCA9IHdIIDwgNjgwID8gd0ggLSAxNSA6IHdIIC0gNTA7XG4gICAgfWVsc2V7XG4gICAgICAgIHZhciBzdmdXaWR0aCA9IHdXIDwgNTAwID8gd1cgLSAyMCA6IHdXIC0gNTA7XG4gICAgICAgIHZhciBzdmdIZWlnaHQgPSA4NDBcbiAgICB9XG5cbiAgICBpZih3VyA8PSA2MTUpe1xuICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhdGgnKS5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoRDc2OClcbiAgICAgICAgXygncGF0aCcpLnNldEF0dHJpYnV0ZSgndmFsdWVzJywgYW5pbWF0ZTc2OClcbiAgICAgICAgXygncGF0aCcpLnNldEF0dHJpYnV0ZSgna2V5VGltZXMnLCBzbWFsbEtleVRpbWVzKVxuICAgICAgICBfKCdwYXRoJykuc2V0QXR0cmlidXRlKCdrZXlTcGxpbmVzJywgc21hbGxTcGxpbmVzKVxuICAgIH1cblxuICAgIGlmKHdXIDw9IDQwMCl7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXRoJykuc2V0QXR0cmlidXRlKCdkJywgcGF0aEQ0MDApXG4gICAgICAgIF8oJ3BhdGgnKS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsIGFuaW1hdGU0MDApXG4gICAgfVxuXG4gICAgaWYod1cgPj0gOTcwICYmIHdIKXtcblxuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHN2Z0hlaWdodClcbiAgICAgICAgICAgIFxuICAgIH1lbHNlIHtcbiAgICAgICAgaWYod0ggPiA4NDApe1xuICAgICAgXG4gICAgICAgICAgICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBcIjAgMCBcIisgXCIgXCIrc3ZnV2lkdGggKyBcIiBcIiArIHN2Z0hlaWdodCk7IFxuICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHN2Z1dpZHRoKVxuICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBzdmdIZWlnaHQpXG5cbiAgICAgICAgfVxuICAgICAgICBpZih3SCA8IDg0MCl7IFxuICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgXCIwIDAgXCIrIFwiIFwiK3N2Z1dpZHRoICsgXCIgXCIgKyBzdmdIZWlnaHQpOyBcbiAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBzdmdXaWR0aClcbiAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgc3ZnSGVpZ2h0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYod1cgJiYgd0gpe1xuICAgICAgIFxuICAgICAgICAvL0FkZCB0byBlbGVtZW50IHdoZW4gbW9yZSBjYW52YXNlcyBhcmUgYWRkZWQgdG8gSFRNTFxuICAgICAgICB2YXIgZWxlbWVudEcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdnLnBob3RvLCBnLmRldmVsb3BlciwgZy5kZXNpZ24sIGcuYW5pbWF0aW9ucywgZy50ZWNobm9sb2dpZXMnKVxuXG4gICAgICAgIGVsZW1lbnRHLmZvckVhY2goZnVuY3Rpb24oZWwsIGkpe1xuICAgICAgICAgICAgdmFyIGdyb3VwTmFtZSA9IGVsLmNsYXNzTGlzdFswXTtcbiAgICAgIFxuICAgICAgICAgICAgaWYoZ3JvdXBOYW1lID09PSAncGhvdG8nKXtcbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Nsb3QtbWFjaGluZScpO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW52YXMtYXJlYScpLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKDE1NywgMCknKTtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChlbC5jaGlsZHJlbixmdW5jdGlvbihlbGVtLCBpKXtcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9DYW1lcmEgU1ZHXG4gICAgICAgICAgICAgICAgICAgIGlmKGkgPT09IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3SGVpZ2h0ID0gbmV3U2l6ZSgnd2lkdGgnLCA3MDAsIGVsZW0pLmhlaWdodFxuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd3aWR0aCcsIDcwMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBuZXdIZWlnaHQpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSBnZXRQb3MoIGVsZW0gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZXRBdHRyaWJ1dGVZID0gcG9zLm1haW5TdmcuaGVpZ2h0IC0gbmV3SGVpZ2h0IC0gNVxuICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3gnLCBwb3MuY2VudGVyZWRMZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCBzZXRBdHRyaWJ1dGVZKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih3VyA8PSA1MDAgfHwgd0ggPD0gODAwKXtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL0ZvcmVpZ25PYmplY3QgaG9sZHMgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIGlmKGkgPT09IDIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih3VyA8IDk3MCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhbnZhc0FyZWEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzLWFyZWEnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gZ2V0UG9zKCBjYW52YXNBcmVhIClcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdIIDwgNjQwICYmIHdXIDwgODAwKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgneScsIDI0MClcbiAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9maXJlZm94XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpc0ZpcmVmb3ggPyBlbGVtLnNldEF0dHJpYnV0ZSgneScsIHN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIC0gcG9zLmhlaWdodCAtIDE2KSA6IChzdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpIC8gMikgLSAzOTcuNiAvIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd5Jywgc3ZnLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgLSAzOTcuNiAtIDE2KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCAyNTApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAzNjApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDM2MClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNGaXJlZm94ID8gZWxlbS5zZXRBdHRyaWJ1dGUoJ3gnLCBwb3MubGVmdCAtNikgOiBlbGVtLnNldEF0dHJpYnV0ZSgneCcsIChzdmcuZ2V0QXR0cmlidXRlKCd3aWR0aCcpIC8gMikgLSAzOTcuNiAvIDIgKyAyMCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCBzdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSAtIHBvcy5oZWlnaHQgLSAxNilcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zSGVpZ2h0ID0gZ2V0UG9zKCBlbGVtIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgd2lkdGggPSBwYXJzZUludCggZWxlbS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlbGVtTGVmdCA9IChwb3NIZWlnaHQubWFpblN2Zy53aWR0aCAtIHdpZHRoKSAtIDE1O1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd5JywgNjApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3gnLCBlbGVtTGVmdClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYod1cgPD0gNTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHRoaXNQb3MgPSBnZXRQb3MoIGVsZW0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd4JywgdGhpc1Bvcy5jZW50ZXJlZExlZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYod0ggPCA2MjApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgneScsIDIwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vSXRlbXNcbiAgICAgICAgICAgICAgICAgICAgaWYoaSA9PT0gMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gZ2V0UG9zKCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzLWFyZWEnKSApXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jaGlsZE5vZGVzWzFdLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCA0MDApXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAyMzUpICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoJ3gnLCAyMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdXIDwgOTcwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKCd5JywgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoJ3knLCAxMDApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih3aW5kb3cuaW5uZXJXaWR0aCA8PSA1MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKCd3aWR0aCcsIDMzNSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKCd4JywgMTApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNQb3MgPSBnZXRQb3MoIGVsZW0uY2hpbGROb2Rlc1sxXSApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmKGdyb3VwTmFtZSA9PT0gJ2RldmVsb3Blcicpe1xuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWwuY2hpbGRyZW4sIGZ1bmN0aW9uKGVsZW0sIGkpe1xuICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL2ZvcmVpZ25PYmplY3QgaG9sZHMgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgIGlmKGkgPT09IDEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYod1cgPCA5NzApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd3aWR0aCcsNDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMzc1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSBnZXRQb3MoZWwuY2hpbGRyZW5bMF0pXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgneScsIDIwMClcbiAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdpbmRvdy5pbm5lcldpZHRoIDw9IDg1MCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYod0ggPCA2OTApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgneScsIDI1IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3gnLCA1IClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3gnLCA1MClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCA3NSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih3aW5kb3cuaW5uZXJXaWR0aCA8IDUwNSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYod0ggPCA2OTApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgneScsIDUwIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3gnLCAwIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jaGlsZE5vZGVzWzFdLnNldEF0dHJpYnV0ZSgnd2lkdGgnLDM2MCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDM3NSk7XG4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRoaXNQb3MgPSBnZXRQb3MoZWxlbS5jaGlsZE5vZGVzWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd5JywgNTAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd4JywgNSApXG4gICAgICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vaXRlbXNcbiAgICAgICAgICAgICAgICAgICAgaWYoaSA9PT0gMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih3aW5kb3cuaW5uZXJXaWR0aCA8IDUwNSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jaGlsZE5vZGVzWzFdLnNldEF0dHJpYnV0ZSgneCcsIDEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoJ3knLCA0MjQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jaGlsZE5vZGVzWzFdLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAzNzApXG4gICAgICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYod1cgPiA1MDUgJiYgd1cgPCA4NTAgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih3SCA8IDY5MCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoJ3knLCA0MjUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMzcwKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2UgZWxlbS5jaGlsZE5vZGVzWzFdLnNldEF0dHJpYnV0ZSgneScsIDQ2MClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZ3JvdXBOYW1lID09PSAnZGVzaWduJyl7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1zID0gZWwuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF1cbiAgICAgICAgICAgICAgICB2YXIgY2FudmFzQXJlYSA9IGVsLmNoaWxkcmVuWzFdXG4gICAgICAgXG4gICAgICAgICAgICAgICAgaWYod0ggJiYgd1cgPiA5NzApe1xuXG4gICAgICAgICAgICAgICAgICAgIGlmKCBjYW52YXNBcmVhICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZih3VyA+IDEyMDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc0FyZWEuc2V0QXR0cmlidXRlKCd3aWR0aCcsIDU4MClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNBcmVhLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgNTgwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ3knLCA4MClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiggaXRlbXMgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgneScsIDIwMClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgXG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoIHdXID4gNzUwICYmIHdXIDwgOTcwKXtcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoIGNhbnZhc0FyZWEgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vRm9yIFNhZmFyaSBvdmVyZmxvdyBub3Qgd29ya2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgd1cgPCA4MTAgPyBjYW52YXNBcmVhLnNldEF0dHJpYnV0ZSgneCcsIDIxMCkgOiBjYW52YXNBcmVhLnNldEF0dHJpYnV0ZSgneCcsIDI1NSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc0FyZWEuc2V0QXR0cmlidXRlKCd5JywgMTYwKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYod0ggPCA3MDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL0ZvciBTYWZhcmkgb3ZlcmZsb3cgbm90IHdvcmtpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNBcmVhLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgNDUwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmKCBpdGVtcyApe1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMuc2V0QXR0cmlidXRlKCd5JywgMClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMuc2V0QXR0cmlidXRlKCd5JywgMClcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMuc2V0QXR0cmlidXRlKCd4JywgMTApXG4gICAgICAgICAgICAgICAgICAgIHdIIDwgNzAwID8gaXRlbXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAyNTApICA6ICBpdGVtcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDI2MClcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIDM0MClcblxuICAgICAgICAgICAgICAgICAgICB2YXIgaGVpZ2h0ID0gaXRlbXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKVxuICAgICAgICAgICAgICAgICAgICBjYW52YXNBcmVhLnNldEF0dHJpYnV0ZSgneScsIGhlaWdodClcblxuICAgICAgICAgICAgICAgICAgICB3VyA8IDYwMCA/IGNhbnZhc0FyZWEuc2V0QXR0cmlidXRlKCd3aWR0aCcsIDQwMCkgOiBjYW52YXNBcmVhLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCA1MDApXG4gICAgICAgICAgICAgICAgICAgIHdXIDwgNjAwID8gY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDQwMCkgOiBjYW52YXNBcmVhLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgNTAwKVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXNQb3MgPSBnZXRQb3MoY2FudmFzQXJlYSlcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ3gnLCBjYW52YXNQb3MuY2VudGVyZWRMZWZ0KVxuICAgICAgICAgICAgICAgICAgICAvL0ZvciBzYWZhcmksIHNvIHBob3RvIGRvZXNuJ3Qgc2hvdyB0aGUgb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIC0gaXRlbXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSlcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoZ3JvdXBOYW1lID09PSAnYW5pbWF0aW9ucycpe1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IGVsLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdXG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhc0FyZWEgPSBlbC5jaGlsZHJlblsxXVxuICAgICAgICAgICAgICAgIHZhciBzdmdQYWdlSGVpZ2h0ID0gc3ZnLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JylcblxuICAgICAgICAgICAgICAgIGlmKHdIICYmIHdXID4gOTcwKXtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHN2Z1BhZ2VIZWlnaHQpXG4gICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHdXIDwgNzY4KXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJvdHRvbSA9ICggc3ZnLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgLSAzMTAgKSAvIDJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMuc2V0QXR0cmlidXRlKCd4JywgMTUpXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgneScsIGJvdHRvbSlcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAzMjApXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAzNzApXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0FyZWEuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzdmdQYWdlSGVpZ2h0KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGdyb3VwTmFtZSA9PT0gJ3RlY2hub2xvZ2llcycpe1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IGVsLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdXG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhc0FyZWEgPSBlbC5jaGlsZHJlblsxXVxuXG4gICAgICAgICAgICAgICAgaWYod1cgPCA2NTAgJiYgd0ggPCA2NTUpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgYm90dG9tID0gKCBzdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSAtIDM3MCApIC8gMlxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5zZXRBdHRyaWJ1dGUoJ3knLCBib3R0b20pXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgneCcsIDUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0gIFxufTtcblxuXG5pZih3VyA8IDk3MCB8fCB3SCA8IDgwMCl7XG4gICAgYWRqdXN0RWxlbWVudHMoKTtcbn1lbHNlIHtcbiAgICAvL0FkZHMgbWFyZ2luIGJldHdlZW4gZnVsbCBoZWlnaHQgdGhyZXNoaG9sZCBmb3Igc3ZnLXBhZ2VcbiAgICBpZih3SCA8IDg0MCl7XG4gICAgICAgXygnc3ZnLXBhZ2UnKS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHdIIC0gNDApIFxuICAgIH1cbiAgICBpZih3VyA8IDEwMDApe1xuICAgICAgICBfKCdzdmctcGFnZScpLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3VyAtIDQwKSBcbiAgICB9XG4gICB2YXIgZGVzaWduQ2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmRlc2lnbiAuaXRlbS1jYW52YXMnKVxuICAgZGVzaWduQ2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCA1ODApXG4gICBkZXNpZ25DYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCA1ODApXG59XG5cbi8vTW92ZXMgY2xvc2UgYnV0dG9uIHRvIHJpZ2h0IG9mIHN2Zy1wYWdlXG5mdW5jdGlvbiBwbGFjZUNsb3NlQnV0dG9uKCl7XG4gICAgXG4gICAgdmFyIGJ0blBvcyA9IGdldFBvcyggXygnY2xvc2UtYnRuJykgKVxuICAgIF8oJ2Nsb3NlLWJ0bicpLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKCcrIChidG5Qb3MubWFpblN2Zy53aWR0aCAtIDU2ICkrJ3B4KSdcbn1cbnBsYWNlQ2xvc2VCdXR0b24oKTtcblxuXG5mdW5jdGlvbiBob3Zlck1hcCgpe1xuICAgIHZhciBidG5XcmFwID0gXygnYnV0dG9uLXdyYXAnKVxuICAgIHZhciBkaXN0O1xuICAgIHZhciBsYXN0RGlzdDtcbiAgICB2YXIgY3VycmVudFBhdGg7IC8vUGF0aCB0byBiZSByZW1vdmVkIHdoZW4gbW91c2VvdXRcbiAgXG4gICAgdmFyIG1vdXNlT3V0ID0gZnVuY3Rpb24oZGlzdCl7XG4gICAgICAgIC8vIGRpc3QgZnJvbSBvcGVuaW5nIHBvcHVwcyB0byByZW1vdmUgcG9pbnRlclxuICAgICAgICB2YXIgcG9pbnRlckRpc3QgPSB0eXBlb2YgZGlzdCA9PT0gJ251bWJlcicgPyBkaXN0IDogbGFzdERpc3RcbiAgXG4gICAgICAgIF8oJ292YWwtcG9pbnRlcicpLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTgwcHgsIDBweCApJ1xuICAgICAgICBcbiAgICAgICAgaWYoaXNGaXJlZm94KXtcbiAgICAgICAgICBcbiAgICAgICAgICAgIF8oJ3Nob3ctaWNvbicpLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTI0cHgsJyArIHBvaW50ZXJEaXN0ICsgJ3B4ICknIFxuICAgICAgICAgXG4gICAgICAgIH1lbHNlIGlmKGlzU2FmYXJpKXtcblxuICAgICAgICAgICAgIF8oJ3Nob3ctaWNvbicpLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTI0cHgsJyArIHBvaW50ZXJEaXN0ICsgJ3B4ICknXG5cbiAgICAgICAgfWVsc2V7XG5cbiAgICAgICAgICAgICBfKCdzaG93LWljb24nKS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKC0yMnB4LCcgKyBwb2ludGVyRGlzdCArICdweCApJ1xuXG4gICAgICAgIH0gIFxuICAgIH07XG5cbiAgICBpZih3VyA+IDc2OCkgYnRuV3JhcC5vbm1vdXNlb3ZlciA9IGhhbmRsZXI7XG4gICAgICAgIFxuICAgIGZ1bmN0aW9uIGhhbmRsZXIoZSl7XG4gICAgICAgIGRpc3QgPSBnZXREaXN0YW5jZShlLnRhcmdldC5jbGFzc05hbWUsIGUudGFyZ2V0LmlkKSBcblxuICAgICAgICBmdW5jdGlvbiBnZXREaXN0YW5jZShlbCxpZCkge1xuICAgICAgICAgICAgdmFyIHRvdGFsRGlzdCA9IGZ1bmN0aW9uKG4pe1xuICAgICAgICAgICAgICAgIHJldHVybiBuICogMzdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBub2RlbGlzdCA9IF8oZWwpXG4gICAgICAgICAgICB2YXIgZWxBcnJheSA9IFtdLnNsaWNlLmNhbGwobm9kZWxpc3QpXG4gICAgICAgICBcbiAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGVsQXJyYXkubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgIGlmKGVsQXJyYXlbaV0uaWQgPT0gaWQpIHJldHVybiB0b3RhbERpc3QoaSk7XG4gICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgIFxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFBhdGhFbGVtZW50KGVsLCBtYXBfcGF0aHMpe1xuICAgICAgICAgICAgdmFyIG5ld1BhdGhBcnJheSA9IFtdXG4gICAgICAgICAgICB2YXIgcGF0aEFycmF5ID0gW10uc2xpY2UuY2FsbCggbWFwX3BhdGhzIClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9QdXRzIGVsZW1lbnRzIGluIGNvcnJlY3Qgb3JkZXJcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IHBhdGhBcnJheS5sZW5ndGggLTE7IGkgPj0gMDsgaS0tKXtcbiAgICAgICAgICAgICAgICBuZXdQYXRoQXJyYXkucHVzaChwYXRoQXJyYXlbaV0pXG4gICAgICAgICAgICB9XG4gXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWwpXG4gICAgICAgICAgICB2YXIgdGFyZ2V0QXJyYXkgPSBbXS5zbGljZS5jYWxsKCBfKHRhcmdldC5jbGFzc05hbWUpICkgIFxuXG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGFyZ2V0QXJyYXkubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgaWYodGFyZ2V0QXJyYXlbaV0gPT09IHRhcmdldCkgcmV0dXJuIG5ld1BhdGhBcnJheVtpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgYW5pbWF0ZUdvb2V5ID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCAhXygnc2hvdy1pY29uJykuY2xhc3NMaXN0LmNvbnRhaW5zKCdpY29uLXRyYW5zaXRpb24nKSApe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIHRyYW5zZm9ybXMgb25seSB1cCBhbmQgZG93biBiZWZvcmUgb3V0LlxuICAgICAgICAgICAgICAgIF8oJ3Nob3ctaWNvbicpLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTIycHgsJyArIGRpc3QgKyAncHggKSdcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICBfKCdzaG93LWljb24nKS5jbGFzc0xpc3QuYWRkKCdpY29uLXRyYW5zaXRpb24nKVxuICAgICAgICAgICAgICAgICAgICBfKCdzaG93LWljb24nKS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKC0xNXB4LCcgKyBkaXN0ICsgJ3B4ICknXG4gICAgICAgICAgICAgICAgICAgIF8oJ292YWwtcG9pbnRlcicpLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMHB4LCAwcHggKSdcbiAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSwxMDApXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBfKCdzaG93LWljb24nKS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKC0xNXB4LCcgKyBkaXN0ICsgJ3B4ICknXG4gICAgICAgICAgICAgICAgXygnb3ZhbC1wb2ludGVyJykuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwcHgsIDBweCApJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGFuaW1hdGVQYXRoTGluZXMgPSBmdW5jdGlvbihwYXRoLCBtYXBfcGF0aHMpe1xuICAgICAgICAgICAgdmFyIGNsYXNzSWQgPSBwYXRoLmlkLnJlcGxhY2UoLy1zbSQvaWcsIFwiXCIpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcF9wYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAvL1JlbW92ZXMgYWxsIGNsYXNzZXMgYmVmb3JlIHRhcmdldCBlbGVtZW50IGNsYXNzIGdldHMgYWRkZWRcbiAgICAgICAgICAgICAgICBpZihtYXBfcGF0aHNbaV0uY2xhc3NMaXN0Lmxlbmd0aCA9PT0gMil7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IG1hcF9wYXRoc1tpXS5jbGFzc0xpc3RbMV1cbiAgICAgICAgICAgICAgICAgICAgbWFwX3BhdGhzW2ldLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhdGguY2xhc3NMaXN0LmFkZChjbGFzc0lkKVxuICAgICAgICAgICAgcmV0dXJuIGNsYXNzSWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVtb3ZlQ2FyZHNDbGFzcyA9IGZ1bmN0aW9uKHRhcmdldCl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGNhcmQgPSBfKCdjYXJkLWljb24nKVxuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IGNhcmQubGVuZ3RoXG5cbiAgICAgICAgICAgIHdoaWxlKGxlbmd0aC0tKXtcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVUcmFuc2Zvcm0gPSArY2FyZFtsZW5ndGhdLnN0eWxlLnRyYW5zZm9ybS5yZXBsYWNlKC8oW14tXFxkXSkvaWcsICcnKVxuICAgICAgICAgICAgICAgIGlmKHN0eWxlVHJhbnNmb3JtICE9PSAwKSBjYXJkW2xlbmd0aF0uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVkoMHB4KSdcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBhbmltYXRlQ2FyZHNVcCA9IGZ1bmN0aW9uKHBhdGgpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBjYXJkID0gXygnY2FyZC1pY29uJylcbiAgICAgICAgICAgIGxldCByZWdFeCA9IC8tLiskL2lnXG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gcGF0aC5pZC5yZXBsYWNlKHJlZ0V4LCAnJylcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSBjYXJkLmxlbmd0aFxuXG4gICAgICAgICAgICAvL0lmIHRhcmdldCBhbHNvIGhhcyAyIGNsYXNzTGlzdCwgcmVtb3ZlIHRoYXQgY2xhc3MgYW5kIGFkZCBwMG9wdXBjYXJkXG4gICAgICAgICAgICB3aGlsZShsZW5ndGgtLSl7XG4gICAgICAgICAgICAgICAgbGV0IGNhcmRQYXJlbnQgPSBjYXJkW2xlbmd0aF0ucGFyZW50Tm9kZVxuICAgICAgICAgICAgICAgIGxldCBzdHlsZVRyYW5zZm9ybSA9ICtjYXJkW2xlbmd0aF0uc3R5bGUudHJhbnNmb3JtLnJlcGxhY2UoLyhbXi1cXGRdKS9pZywgJycpXG5cbiAgICAgICAgICAgICAgICBpZih0YXJnZXQgPT09IGNhcmRQYXJlbnQuaWQucmVwbGFjZShyZWdFeCwgJycpICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYXJkW2xlbmd0aF0uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVkoLTE0MHB4KSdcbiAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FyZFtsZW5ndGhdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVZKC0xNDBweCknXG4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfWVsc2UgaWYoc3R5bGVUcmFuc2Zvcm0gIT09IDApe1xuICAgICAgICAgICAgICAgICAgICBjYXJkW2xlbmd0aF0uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVkoMHB4KSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBBbmltYXRlQ2lyY2xlcyhwYXRoLCBtYXBfcGF0aHMpe1xuICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgY2lyY2xlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNwdWxzZS1jaXJjbGVzIGNpcmNsZScpXG4gICAgICAgICAgICB2YXIgcGF0aHMgPSBbXVxuICAgICAgICAgICAgLy9SZW1vdmVzIGFsbCBjbGFzc2VzIGJlZm9yZSB0YXJnZXQgZWxlbWVudHMgY2xhc3NlcyBnZXRzIGFkZGVkXG4gICAgICAgICAgICBmb3IobGV0IGNpciBvZiBjaXJjbGVzKXtcbiAgICAgICAgICAgICAgICBpZihjaXIuY2xhc3NMaXN0Lmxlbmd0aCA+IDEpe1xuICAgICAgICAgICAgICAgICAgICBjaXIuY2xhc3NMaXN0LnJlbW92ZShjaXIuY2xhc3NMaXN0WzFdKVxuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1N0b3BzIGJlZm9yZSBlcnJvciB3aGVuIG5vdCBwYXNzaW5nIGFyZ3VtZW50cyBmcm9tIGNsaWNrIGhhbmRsZXJcbiAgICAgICAgICAgIGlmKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgICAgIC8vUGFpcnMgY2lyY2xlcyBhbmQgcmV0dXJucyB0aGUgcGFpcnMgc28gY2xhc3NlcyBjYW4gYmUgYWRkZWRcbiAgICAgICAgICAgIHZhciBwYWlyQ2lyY2xlcyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdmFyIGNpciA9IFtdXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaXJjbGVzLmxlbmd0aDsgais9Mikge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY2lyLnB1c2goIFtjaXJjbGVzW2pdLCBjaXJjbGVzW2orMV1dIClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNpclxuICAgICAgICAgICAgfVxuICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwX3BhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcGF0aHMudW5zaGlmdCggbWFwX3BhdGhzW2ldLmlkKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYXRocy5pbmRleE9mKHBhdGguaWQpXG4gICAgICAgICAgICB2YXIgY2lyUGFpcnMgPSBwYWlyQ2lyY2xlcygpW2luZGV4XVxuXG4gICAgICAgICAgICBjaXJQYWlyc1swXS5jbGFzc0xpc3QuYWRkKCdtaWRkbGUtcHVsc2UnKVxuICAgICAgICAgICAgY2lyUGFpcnNbMV0uY2xhc3NMaXN0LmFkZCgncmluZy1wdWxzZScpIFxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciByZW1vdmVDaXJjbGVzID0gZnVuY3Rpb24oc3RyaW5nKXtcbiAgICAgICAgICAgIHZhciBhY3RpdmVDaXJjbGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1pZGRsZS1wdWxzZSwgLnJpbmctcHVsc2UnKVxuXG4gICAgICAgICAgICBmb3IobGV0IGNpciBvZiBhY3RpdmVDaXJjbGVzKXtcbiAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjaXIuYWRkRXZlbnRMaXN0ZW5lcignYW5pbWF0aW9uZW5kJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZS50YXJnZXQuY2xhc3NMaXN0LnJlbW92ZShlLnRhcmdldC5jbGFzc0xpc3RbMV0pXG4gICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlQWxsKHN0cmluZyl7XG4gICAgICAgICAgICByZW1vdmVDaXJjbGVzKHN0cmluZylcbiAgICAgICAgICAgIG1vdXNlT3V0KGRpc3QpXG4gICAgICAgICAgICByZW1vdmVDYXJkc0NsYXNzKClcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICAvL1BhdGggdG8gYmUgcmVtb3ZlZCB3aGVuIG1vdXNlb3V0XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY3VycmVudFBhdGgpLmNsYXNzTGlzdC5yZW1vdmUoY3VycmVudFBhdGgpXG4gICAgICAgICAgICB9Y2F0Y2goZXJyKXtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZU1hcChlKXtcbiAgICAgICAgICAgbGV0IHRhcmdldCA9IGUudGFyZ2V0LmNsYXNzTGlzdC52YWx1ZVxuICAgICBcbiAgICAgICAgICAgLy9JZiBjbGljayBjb21lcyBmcm9tIG9wZW5pbmcgc3ZnIG1vZGFsc1xuICAgICAgICAgICAgaWYodGFyZ2V0ID09PSAnY2FyZC1jb2xvci1zdDM5JyB8fCB3VyA+IDc2OCAmJiBlLnR5cGUgPT09ICdjbGljaycpe1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICByZW1vdmVBbGwocGF0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbW91c2Ugb3ZlclxuICAgICAgICAgICAgaWYoZS50YXJnZXQuaWQpe1xuICAgICAgICAgICAgICAgIC8vU3RhcnQgdGhlIHBhdGggYW5pbWF0ZWQgbGluZXNcbiAgICAgICAgICAgICAgICB2YXIgbWFwX3BhdGhzID0gd1cgPiA3NjggPyBfKCdtYXAtcGF0aHMnKSA6IF8oJ21hcC1wYXRocy1zbScpXG4gICAgICAgICAgICAgICAgdmFyIHBhdGggPSBnZXRQYXRoRWxlbWVudChlLnRhcmdldC5pZCwgbWFwX3BhdGhzKVxuXG4gICAgICAgICAgICAgICAgLy9Vc2VkIHRvIHVwZGF0ZSB0cmFuc2xhdGUgZm9yIGJ1dHRvbiBsb2NhdGlvblxuICAgICAgICAgICAgICAgIGxhc3REaXN0ID0gZGlzdFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYW5pbWF0ZUdvb2V5KClcbiAgICAgICAgICAgICAgICBjdXJyZW50UGF0aCA9IGFuaW1hdGVQYXRoTGluZXMocGF0aCwgbWFwX3BhdGhzKVxuICAgICAgICAgICAgICAgIEFuaW1hdGVDaXJjbGVzKHBhdGgsIG1hcF9wYXRocylcbiAgICAgICAgICAgICAgICBhbmltYXRlQ2FyZHNVcChwYXRoKVxuICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9Pbmx5IHJ1bnMgYWZ0ZXIgbW91c2VvdmVyIGVsZW1lbnRzIHJ1biBmaXJzdCwgdGhlbiBpbml0aWF0ZWQuIFxuICAgICAgICAgICAgICAgIF8oJ2ludGVyYWN0aXZlLWNvbnRhaW5lcicpLm9ubW91c2VvdmVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBpZihlLnRhcmdldC5jbGFzc05hbWUgIT09ICdvcGVuLWNhbnZhcy1wYWdlJyAmJiB3VyA+IDc2OCl7XG4gXG4gICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVBbGwoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBcbiAgICAgICAgaWYgKGUudHlwZSA9PSAnbW91c2VvdmVyJyAmJiB3VyA+IDc2OCkge1xuICAgICAgICAgICAgaGFuZGxlTWFwKGUpXG4gICAgICAgIH1lbHNlIGlmKGUudHlwZSA9PT0gJ2NsaWNrJyl7XG4gICAgXG4gICAgICAgICAgICBoYW5kbGVNYXAoZSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2Rpc3RdXG4gICAgfVxuICAgIHJldHVybiBbbW91c2VPdXQsIGhhbmRsZXJdIC8vIFRvIGJlIGFibGUgdG8gdXNlIG1vdXNlT3V0IGZ1bmN0aW9uIGFuZCBoYW5kbGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBkaXN0IHRvIHVzZSBmb3IgbW91c2VPdXQgRnVuY1xufTtcblxudmFyIHRvZ2dsZVN0YXJzID0ge1xuICAgIHRvZ2dsZTogZmFsc2Vcbn1cblxudmFyIHJvYm90U2VjdGlvbiA9IGZ1bmN0aW9uKGUpe1xuXG4gICAgY29uc3Qgc3RhcnMgPSBbXVxuICAgIHZhciBhbmltYXRlU3RhcnMgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgXG4gICAgICAgIGxldCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3Rhci1jYW52YXMnKTtcbiAgICAgICAgbGV0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICBsZXQgd2lkdGggPSBjYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgbGV0IGhlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5cbiAgICAgICAgbGV0IHJhbmRvbVdpZHRoID0gKCkgPT4ge1xuICAgICAgICAgICAgLy9tYXggYW5kIG1pblxuICAgICAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAod2lkdGgvMiAtIHdpZHRoLzkpICsgd2lkdGgvOVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIE5pZ2h0U3RhcnMgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgcmFuZG9tU3RhcnQgPSByYW5kb21XaWR0aCgpXG5cbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24gPSAyMDAwIC8vdXNlZCB0byBkZWxheSBzdGFyc1xuICAgICAgICAgICAgdGhpcy5yYWRpdXMgPSAxMyArIE1hdGgucmFuZG9tKCkgKiA1IC8vc2l6ZSBvZiBzdGFyc1xuXG4gICAgICAgICAgICB0aGlzLmkgPSAwIC8veCBhbmQgeSBzcGVlZFxuICAgICAgICAgICAgdGhpcy5rID0gMCAvL29wYWNpdHkgc3BlZWRcblxuICAgICAgICAgICAgdGhpcy5zdGFydCA9IHtcbiAgICAgICAgICAgICAgICB5OiBNYXRoLnJhbmRvbSgpICogaGVpZ2h0XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuRmxpY2tlciA9IChpbmNyZW50bWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoTWF0aC5jb3MoaW5jcmVudG1lbnQgLSBNYXRoLlBJLzE4MCkgKiAuMiApIFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnJhZFNpemUgPSAoaW5jcmVudG1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKE1hdGguc2luKGluY3JlbnRtZW50IC0gTWF0aC5QSS8xODApICogNylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy54ID0gKGluY3JlbnRtZW50LCBzdGFyU2l6ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vZnVsbCBzY3JlZW4gYW5pbWF0ZSBjaGFuZ2UgdGhpcy5yYW5kb21XaWR0aCBiYWNrIHRvIHdpZHRoIC8gMlxuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLmNvcyhpbmNyZW50bWVudCAtIE1hdGguUEkvMTgwKSAqIChyYW5kb21TdGFydCArIHN0YXJTaXplIClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy55ID0gKGluY3JlbnRtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguc2luKC1pbmNyZW50bWVudCAtIE1hdGguUEkvMTgwKSAqIDE2MFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRyYXcgPSAoY3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IHMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxldCBvcGFjU3BlZWQgPSBzLmsgKz0gLjNcbiAgICAgICAgICAgICAgICBsZXQgc3BlZWQgPSBzLmkgKz0gcy5yYW5kb21TcGVlZFxuXG4gICAgICAgICAgICAgICAgbGV0IHJhZFNpemUgPSBzLnJhZFNpemUoc3BlZWQpXG4gICAgICAgICAgICAgICAgbGV0IGZsaWNrZXIgPSBzLkZsaWNrZXIob3BhY1NwZWVkKVxuXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBzLnkoc3BlZWQpXG4gICAgICAgICAgICAgICAgbGV0IHggPSBzLngoc3BlZWQsIHMucmFkaXVzKVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLzIsIHMuc3RhcnQueSlcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoeCAseSAsLjQsIHggLHkgLDE0KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJ0xpZ2h0U2t5Qmx1ZScpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCguOSwgJ0RvZGdlckJsdWUnKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJ1JveWFsQmx1ZScpO1xuXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgY3R4LmFyYyh4LCAgeSwgKHMucmFkaXVzIC0gcmFkU2l6ZSkgLSBmbGlja2VyLCAwLCBNYXRoLlBJKjIpXG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGdyYWRpZW50XG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgICBcbiAgICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC13aWR0aC8yLCAtIHMuc3RhcnQueSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVN0YXJzKHN0YXJDb3VudCx1cGRhdGUpe1xuICAgICAgICAgICAgbGV0IGRlbGF5ID0gMFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXJDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVsYXkgKz0gTWF0aC5yYW5kb20oKSAqIHdpZHRoXG5cbiAgICAgICAgICAgICAgICBsZXQgbmlnaHRTdGFycyA9IG5ldyBOaWdodFN0YXJzKClcbiAgICAgICAgICAgICAgICBuaWdodFN0YXJzLnJhbmRvbVNwZWVkID0gLjAwMSArIE1hdGgucmFuZG9tKCkgKiAuMDA2XG4gICAgICAgICAgICAgICAgbmlnaHRTdGFycy5zdGFydFRpbWUgPSBEYXRlLm5vdygpXG4gICAgICAgICAgICAgICAgbmlnaHRTdGFycy5kdXJhdGlvbiArPSBkZWxheSAgIC8vc2V0cyBhIHJhbmRvbSBkZWxheSBmb3Igc3RhcnMgdG8gc3RhcnRcbiAgICAgICAgICAgICAgICBzdGFycy5wdXNoKG5pZ2h0U3RhcnMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGUoKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiB1cGRhdGUoKXtcbiAgICAgICAgICAgIC8vU3RvcHBpbmcgc3RhcnNcbiAgICAgICAgICAgIGlmKHRvZ2dsZVN0YXJzLnRvZ2dsZSl7XG4gICAgICAgICAgICAgICAgc3RhcnMubGVuZ3RoID0gMFxuICAgICAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgYWxsID0gc3RhcnMubGVuZ3RoXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLy8gbGV0IHBlcmNlbnQgPSBNYXRoLm1pbiggKCBEYXRlLm5vdygpIC0gc3RhcnNbaV0uc3RhcnRUaW1lICkgLyBzdGFyc1tpXS5kdXJhdGlvbiwgMSApICAvL0RlbGF5IHRvIHN0YXJ0IHN0YXJzXG4gICAgICAgICAgICAgICAgbGV0IHBlcmNlbnQgPSBNYXRoLm1pbiggKCBEYXRlLm5vdygpIC0gc3RhcnNbaV0uc3RhcnRUaW1lICksIDEgKSAgLy8gTm8gZGVsYXlcblxuICAgICAgICAgICAgICAgIGlmKHBlcmNlbnQgPT09IDEpe1xuICAgICAgICAgICAgICAgICAgICBzdGFyc1tpXS5kcmF3KGN0eClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNyZWF0ZVN0YXJzLFxuICAgICAgICAgICAgdXBkYXRlXG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuXG4gICAgdmFyIHVwZGF0ZVRleHQgPSAoZnVuY3Rpb24oKXtcbiBcbiAgICAgICAgdmFyIHRvZ2dsZSA9IHRydWVcbiAgICAgICAgdmFyIHRleHRGaWVsZCA9IF8oJ3RleHQtZmllbGQnKVxuXG4gICAgICAgIGZ1bmN0aW9uIGNoYW5nZVRvZ2dsZShib29sZWFuKXtcbiAgICAgICAgICAgIHRvZ2dsZSA9IGJvb2xlYW5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9nZ2xlRmFsc2U6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgY2hhbmdlVG9nZ2xlKGZhbHNlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZUltZ1RleHQ6IGZ1bmN0aW9uKGltZyl7XG5cbiAgICAgICAgICAgICAgICBjaGFuZ2VUb2dnbGUodHJ1ZSlcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgaW1nVGV4dCA9IGltZy5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGFyZ2V0JylcbiAgICAgICAgICAgICAgICB2YXIgdGV4dExlbmd0aCA9IGltZ1RleHQubGVuZ3RoXG5cbiAgICAgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGV4dExlbmd0aDsgaSsrKXtcblxuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24oaSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZighdG9nZ2xlKSByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRGaWVsZC50ZXh0Q29udGVudCArPSBpbWdUZXh0W2ldXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwxMDAgKiBpKVxuICAgICAgICAgICAgICAgICAgICB9KShpKTsgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKCk7XG4gICAgXG5cbiAgICBmdW5jdGlvbiBlbGVjdHJpY0JveCgpe1xuICAgICAgICB2YXIgcmFuZG9tQ2lyID0gWzAsMSwyLDMsNCw1XVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFJhbmRvbShudW0pe1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1hdGguZmxvb3IobnVtKSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZmluZE51bShpdGVtKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIG5ld051bSA9IHJhbmRvbUNpci5zcGxpY2UoaXRlbSwxKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBfKCdyb2JvdC1zdDM0JylbbmV3TnVtXS5jbGFzc0xpc3QuYWRkKCdibGluaycpXG4gICAgICAgICAgICBpZihyYW5kb21DaXIubGVuZ3RoKXtcbiAgICAgICAgICAgICAgIHJlbGF5KHJhbmRvbUNpcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZWxheShlbCl7XG4gICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gZ2V0UmFuZG9tKGVsLmxlbmd0aC0xKVxuICAgICAgICAgICAgICAgIGZpbmROdW0oaXRlbSlcbiAgICAgICAgICAgIH0sODApXG4gICAgICAgIH1cbiAgICAgICAgcmVsYXkocmFuZG9tQ2lyKVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjaGVja0ZvckNsYXNzZXMoKXtcbiAgICAgICAgdmFyIGNpcmNsZXMgPSBfKCdyb2JvdC1zdDM0JykubGVuZ3RoXG4gICAgICAgXG4gICAgICAgIC8vIEFkZCBibGlua2luZyBsaWdodCBjbGFzc2VzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2lyY2xlczsgaSsrKSB7XG4gICAgICAgICAgICBpZiggXygncm9ib3Qtc3QzNCcpW2ldLmNsYXNzTGlzdC5jb250YWlucygnYmxpbmsnKSApe1xuXG4gICAgICAgICAgICAgICAgXygncm9ib3Qtc3QzNCcpW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2JsaW5rJylcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbGVjdHJpY0JveCgpXG4gICAgfTtcblxuICAgIC8vIEFkZCBlbGVjdHJpY2l0eSBmb3Igcm9ib3QgYm94IHN0b21hY2hcbiAgICBmdW5jdGlvbiBhZGRFbGVjdHJpY2l0eSgpe1xuICAgICAgICB2YXIgcGF0aExlbmd0aCA9IF8oJ2VsZWN0cmljLXBhdGgnKS5sZW5ndGhcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIF8oJ2VsZWN0cmljLXBhdGgnKVtpXS5zdHlsZS5zdHJva2VEYXNoYXJyYXkgPSAyMFxuICAgICAgICAgICAgXygnZWxlY3RyaWMtcGF0aCcpW2ldLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSAyODBcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSAwO1xuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXcodGltZXN0YW1wKXtcbiAgICAgICAgICAgIGlmKCFzdGFydCkgc3RhcnQgPSB0aW1lc3RhbXBcbiAgICAgICAgICAgIHZhciBydW50aW1lID0gdGltZXN0YW1wIC0gc3RhcnRcbiAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IE1hdGgubWluKHJ1bnRpbWUgLyAxMjAwLCAxKVxuICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBfKCdlbGVjdHJpYy1wYXRoJylbaV0uc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IDI4MCArICgyODAgKiBwcm9ncmVzcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYocHJvZ3Jlc3MgPCAxKXtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhdylcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF8oJ2VsZWN0cmljLXBhdGgnKVtpXS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJycpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhdylcbiAgICB9O1xuICAgIFxuXG4gICAgLyoqIE91dHRlciBmdW5jdGlvbiBzY29wZSB2YXJpYWJsZXMgKiovXG4gICAgdmFyIGRlc2lnbkltYWdlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Rlc2lnbkltYWdlcycpO1xuICAgIHZhciBpbWdfY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnaW1hZ2UtY29udGFpbmVyJylbMF07XG5cbiAgICB2YXIgYW5pbWF0ZVNsaWRlciA9IHtcbiAgICAgICAgdGFyZ2V0OiBudWxsLFxuICAgICAgICBwYXJ0aWFsRGlzdDogMCxcbiAgICAgICAgajogMCxcbiAgICAgICAgZGlzdDogMCxcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGltYWdlczogW10sXG4gICAgICAgIGltZ1N0YXJ0OiAwLFxuICAgICAgICBuZXdTdGFydDogZnVuY3Rpb24obnVtKXtcblxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KCB0aGlzLmltYWdlc1tudW1dLnN0eWxlLnRyYW5zZm9ybS5yZXBsYWNlKC9eKFtcXHddKilcXCh8KHB4LiopJC9pZywgJycpIClcblxuICAgICAgICB9LFxuICAgICAgICBjb250YWluZXJXaWR0aDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCggaW1nX2NvbnRhaW5lci5zdHlsZS53aWR0aC5yZXBsYWNlKC9weC9pZywgJycpIClcbiAgICAgICAgfSxcbiAgICAgICAgY2xvbmVJbWFnZTogZnVuY3Rpb24oaW1nKXtcbiAgICAgICAgICAgIGNvbnN0IGNsb25lZEltZyA9IGltZy5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgICAgIGNsb25lZEltZy5jbGFzc05hbWUgPSAnJ1xuICAgICAgICAgICAgY2xvbmVkSW1nLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKVxuICAgICAgICAgICAgaW1nSW5sYXJnZS5jaGVja0ZvckR1cGxpY2F0ZXMoJ2Rlc2lnblZpc2libGUnKVxuICAgICAgICAgICAgaW1nSW5sYXJnZS5tb3ZlRWxlbWVudChjbG9uZWRJbWcsICdkZXNpZ25WaXNpYmxlJylcbiAgICAgICAgfSxcbiAgICAgICAgZHJhdzogZnVuY3Rpb24odGltZXN0YW1wKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIXRoaXMuc3RhcnQpIHRoaXMuc3RhcnQgPSB0aW1lc3RhbXBcblxuICAgICAgICAgICAgdmFyIHJ1bnRpbWUgPSB0aW1lc3RhbXAgLSB0aGlzLnN0YXJ0XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBNYXRoLm1pbihydW50aW1lIC8gNzAwLCAxKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmltYWdlc1swXS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcrICh0aGlzLmltZ1N0YXJ0IC0gKHRoaXMuZGlzdCpwcm9ncmVzcykgKSsncHgsIC01MCUpJ1xuICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHByb2dyZXNzID09PSAxKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL1NlY29uZCBwaG90byBmb2xsb3dpbmcgdGhlIGZpcnN0IHRvIGJlIGFuaW1hdGVkIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgICAgICBpZih0aGlzLmogPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tzIGlmIGxlZnQgb3IgcmlnaHQgYnV0dG9uIGNsaWNrIHdpdGggYSBuZWdhdGl2ZSBsZWZ0IG9yIHBvc2l0aXZlIHJpZ2h0IGFuZCB1cGRhdGVzIGltZ1N0YXJ0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW1nU3RhcnQgPSB0aGlzLmRpc3QgPCAwID8gLXRoaXMuY29udGFpbmVyV2lkdGgoKSA6IHRoaXMuY29udGFpbmVyV2lkdGgoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3QgPSB0aGlzLmRpc3QgPCAwID8gLXRoaXMuY29udGFpbmVyV2lkdGgoKSA6IHRoaXMuY29udGFpbmVyV2lkdGgoKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0gMFxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHRoaXMuaW1hZ2VzLnNoaWZ0KClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWFnZXMucHVzaChpdGVtKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmogPSAwXG4gICAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL1VzZXIgZG91YmxlIGNsaWNrcyBzYW1lIGJ1dHRvbiB3aGVuIDJuZCBpbWFnZSBpc24ndCBmaW5pc2hlZCBpdCBkcmF3cyBhZ2FpblxuICAgICAgICAgICAgICAgICAgICBpZih0aGlzLmltZ1N0YXJ0ICE9PSB0aGlzLmRpc3QgKXtcbiAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhdygpXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1N0b3BzIHR5cGVkIHRleHQgZnJvbSBydW5uaW5nIG9ubHkgd2hlbiBwaG90byBzdG9wcyBpbnRvIHBsYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICBfKCd0ZXh0LWZpZWxkJykudGV4dENvbnRlbnQgPSAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGV4dC51cGRhdGVJbWdUZXh0KHRoaXMuaW1hZ2VzWzBdKSAvL1N0YXJ0cyB0aGUgdHlwZWQgdGV4dCBmdW5jdGlvblxuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb25lSW1hZ2UodGhpcy5pbWFnZXNbMF0pIFxuICAgICAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5qKytcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZVNsaWRlci5kcmF3LmJpbmQodGhpcykpO1xuICAgICAgICB9LFxuICAgICAgICBhbmltYXRlRGF0YTogZnVuY3Rpb24oZSl7ICAgXG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gdGhpcy50YXJnZXQuaW5uZXJUZXh0XG4gICAgICAgICAgICB2YXIgbmV3U3RhcnQgPSB0aGlzLm5ld1N0YXJ0KDApXG4gICAgICAgICAgICB0aGlzLnBhcnRpYWxEaXN0ID0gbmV3U3RhcnRcblxuICAgICAgICAgICAgLy9JZiB1c2VyIGNsaWNrcyBiZWZvcmUgaW1hZ2UgZG9uZSBhbmltYXRpbmcsIHVwZGF0ZXMgY3VycmVudCBsb2NhdGlvbiBhbmQgc3RhcnRzIGFnYWluXG4gICAgICAgICAgICBpZihuZXdTdGFydCAhPT0gMCAmJiAhaXNOYU4obmV3U3RhcnQpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih0YXJnZXQgPT09ICc8Jyl7XG4gICAgICAgICAgICAgICAgICAgIC8vSWYgdXNlciBkb3VibGUgY2xpY2tzIHNhbWUgYnV0dG9uIHJpZ2h0IGF3YXlcbiAgICAgICAgICAgICAgICAgICAgaWYobmV3U3RhcnQgPCAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1nU3RhcnQgPSBuZXdTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0ID0gdGhpcy5jb250YWluZXJXaWR0aCgpICsgbmV3U3RhcnRcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmogPSAwICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3QgPSBuZXdTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWdTdGFydCA9IG5ld1N0YXJ0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYodGFyZ2V0ID09PSAnPicpe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYobmV3U3RhcnQgPCAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaiA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1nU3RhcnQgPSBuZXdTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0ID0gbmV3U3RhcnRcbiAgICAgICAgICAgICAgICAgICAgLy9JZiB1c2VyIGRvdWJsZSBjbGlja3Mgc2FtZSBidXR0b24gcmlnaHQgYXdheVxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1nU3RhcnQgPSBuZXdTdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0ID0gLXRoaXMuY29udGFpbmVyV2lkdGgoKSArIG5ld1N0YXJ0XG4gICAgICAgICAgICAgICAgICAgIH0gICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydCA9IDBcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQgPSAwXG5cbiAgICAgICAgICAgICAgICBpZih0YXJnZXQgPT09ICc8Jyl7XG4gICAgICAgICAgICAgICAgICAgIC8vZmlyc3QgY2xpY2sgc3RhcnRzIGltYWdlIG91dHNpZGUgdGhlIGhlYWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5qID49IDEgPyB0aGlzLmltZ1N0YXJ0ID0gMCA6IHRoaXMuaW1nU3RhcnQgPSB0aGlzLmNvbnRhaW5lcldpZHRoKClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0ID0gdGhpcy5jb250YWluZXJXaWR0aCgpXG4gICAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL2ZpcnN0IGNsaWNrIHN0YXJ0cyBpbWFnZSBvdXRzaWRlIHRoZSBoZWFkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaiA+PSAxID8gdGhpcy5pbWdTdGFydCA9IDAgOiB0aGlzLmltZ1N0YXJ0ID0gLXRoaXMuY29udGFpbmVyV2lkdGgoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3QgPSAtdGhpcy5jb250YWluZXJXaWR0aCgpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gbG9hZCBpbWFnZXMgaW50byBhcnJheSB0byBiZSB1c2VkIGZvciBzbGlkZXJcbiAgICAgICAgbG9hZEltYWdlczogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVzaWduSW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkZXNpZ25JbWFnZXNbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5pbWFnZXMucHVzaChlbGVtZW50KVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEtlZXBzIGZyb20gcmVzaXplIGV2ZW50IGxvYWRpbmcgY2xpY2sgaGFuZGxlclxuICAgIGlmKGUudHlwZSAhPT0gJ3Jlc2l6ZScgJiYgZS50eXBlICE9PSAnc2Nyb2xsJyl7XG4gICAgICAgIFxuICAgICAgICBfKCdidG5Db250YWluZXInKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgICAgICAgYW5pbWF0ZVNsaWRlci50YXJnZXQgPSBlLnRhcmdldFxuICAgICAgICAgICAgYW5pbWF0ZVNsaWRlci5hbmltYXRlRGF0YShlKVxuXG4gICAgICAgICAgICBjaGVja0ZvckNsYXNzZXMoKVxuICAgICAgICAgICAgYWRkRWxlY3RyaWNpdHkoKVxuICAgICAgICAgICAgdXBkYXRlVGV4dC50b2dnbGVGYWxzZSgpXG4gICAgICAgICAgICBfKCd0ZXh0LWZpZWxkJykudGV4dENvbnRlbnQgPSAnJ1xuICAgICAgICAgICAgXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gW2FuaW1hdGVTbGlkZXIsIGFuaW1hdGVTdGFyc10gLy8gVG8gYmUgdXNlZCBpbiB0aGUgd2luZG93Lm9ubG9hZCBzZWN0aW9uXG59O1xuXG5cbmZ1bmN0aW9uIERlc2lnblNsaWRlcigpIHtcbiAgICB2YXIgaW1nX2NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2ltYWdlLWNvbnRhaW5lcicpWzBdXG4gICAgdmFyIGltZ19jb250YWluZXJfcmVjdCA9IGltZ19jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICB0aGlzLmVsbGlwc2UgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjbGlwLWVsbGlwc2UnKVswXVxuICAgIHRoaXMucmVjID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc2NyZWVuLXBhdGgnKVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIHRoaXMuc2VjdGlvbkNvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3NlY3Rpb24tdGhyZWUtcm9ib3QnKVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgdmFyIGFjdHVhbFRvcCA9IHRoaXMucmVjLnRvcCAtIHRoaXMuc2VjdGlvbkNvbnRhaW5lci50b3AgLy93aGVuIHBhZ2Ugbm90IGZ1bGx5IHNjcm9sbGVkIGludG8gdmlldyBpdCdzIHRoZSBhY3R1YWwgdG9wXG4gICBcbiAgICB0aGlzLnNldEVsbGlwc2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy5lbGxpcHNlLnNldEF0dHJpYnV0ZSgncngnLCB0aGlzLnJlYy53aWR0aC8yKVxuICAgICAgICB0aGlzLmVsbGlwc2Uuc2V0QXR0cmlidXRlKCdyeScsIHRoaXMucmVjLmhlaWdodC8yKVxuICAgICAgICB0aGlzLmVsbGlwc2Uuc2V0QXR0cmlidXRlKCdjeCcsIHRoaXMucmVjLmxlZnQgKyB0aGlzLnJlYy53aWR0aC8yIC0gNSlcbiAgICAgICAgdGhpcy5lbGxpcHNlLnNldEF0dHJpYnV0ZSgnY3knLCBhY3R1YWxUb3AgKyB0aGlzLnJlYy5oZWlnaHQvMiApXG4gICAgfVxuICAgIHRoaXMuc2V0SW1nQ29udGFpbmVyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIGNvbnRhaW5lcl9XaWR0aCA9IHRoaXMucmVjLndpZHRoIC8gOSArIHRoaXMucmVjLndpZHRoXG4gICAgICAgIHZhciBpbWdfY29udGFpbmVyWSA9IGFjdHVhbFRvcCAtIChpbWdfY29udGFpbmVyX3JlY3QuaGVpZ2h0IC0gdGhpcy5yZWMuaGVpZ2h0KSAvIDJcbiAgICAgICAgaW1nX2NvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKC01MCUsJyArIGltZ19jb250YWluZXJZICsgJ3B4KScgIC8vLTQ4JSB0byBtYWtlIHVwIGZvciA1MyUgcm9ib3Qtc3ZnIG9mZnNldFxuICAgICAgICBpbWdfY29udGFpbmVyLnN0eWxlLndpZHRoID0gY29udGFpbmVyX1dpZHRoICsgJ3B4J1xuICAgIH1cbiAgICB0aGlzLnNldEJ1dHRvbkxvY2F0aW9uID0gZnVuY3Rpb24oKXtcblxuICAgICAgICB2YXIgYWRkZWRXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4ID8gNzAgOiAyMDAgIC8vRGlzdGFuY2UgYmlnZ2VyIHRoYW4gcm9ib3QgaGVhZFxuXG4gICAgICAgIHZhciB4ID0gICggd2luZG93LmlubmVyV2lkdGggLSAodGhpcy5yZWMud2lkdGggKyBhZGRlZFdpZHRoKSApIC8gMlxuICAgICAgICB2YXIgeSA9IHdpbmRvdy5pbm5lcldpZHRoID4gNzY4ID8gYWN0dWFsVG9wICsgKCB0aGlzLnJlYy5oZWlnaHQgLyAyICkgLSAyNSA6IHRoaXMucmVjLmJvdHRvbSAtIHRoaXMuc2VjdGlvbkNvbnRhaW5lci50b3AgLy8gLSAyNSBmb3IgdGhlIGJ0bkNvbnRhaW5lciBoZWlnaHQgLyAyXG5cbiAgICAgICAgXygnYnRuQ29udGFpbmVyJykuc3R5bGUud2lkdGggPSB0aGlzLnJlYy53aWR0aCArIGFkZGVkV2lkdGggKydweCdcbiAgICAgICAgXygnYnRuQ29udGFpbmVyJykuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnKyB4ICsgJ3B4LCcgKyB5ICsgJ3B4KSdcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgcmV0dXJuIFt0aGlzLnNldEVsbGlwc2VBdHRyaWJ1dGVzKCksdGhpcy5zZXRJbWdDb250YWluZXIoKSx0aGlzLnNldEJ1dHRvbkxvY2F0aW9uKCldXG5cbiAgICB9LmJpbmQodGhpcylcbn1cblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsZnVuY3Rpb24oZSl7XG5cbiAgICB2YXIgdXBkYXRlUm9ib3QgPSByb2JvdFNlY3Rpb24oZSlcblxuICAgIHZhciBkZXNpZ25TbGlkZXIgPSBuZXcgRGVzaWduU2xpZGVyKClcbiAgICBkZXNpZ25TbGlkZXIoKSAgLy91cGRhdGVzIGNhbnZhcyBzaXplXG4gICAgdXBkYXRlUm9ib3RbMV0oKSAgLy91cGRhdGVzIGJ1dHRvbiwgaW1hZ2UgbG9jYXRpb24gLCBhdHRyaWJ1dGVzIG9mIHJvYm90XG59KTtcblxuLy8gKioqKiBBU1NFTUJMWSBMSU5FIFNFQ1RJT04gKioqKlxuXG5jbGFzcyBBc3NlbWJseUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMubWFpblNWRyA9IF8oJ2Fzc2VtYmx5LWxpbmUtc3ZnJylcbiAgICAgICAgdGhpcy5zbGlkZXJzID0gXygncm9sbGVyX3VuaXQnKVxuICAgICAgICB0aGlzLmNvZGVDb250YWluZXJzID0gXygnY29kZS1jb250YWluZXInKVxuICAgIH1cbiAgICBcbiAgICBnZXRSZWN0KGVsKXtcbiAgICAgICAgbGV0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICBsZXQgYkJveCA9IGVsLmdldEJCb3goKVxuICAgICAgICByZXR1cm4ge3JlY3QsIGJCb3h9XG4gICAgfVxuICAgIFxuICAgIGdldEVsZW1WYWx1ZShwb3MpIHtcbiAgICAgICAgY29uc3QgW3NpemVdID0gL1sxLTldLiovLmV4ZWMoIHRoaXMubWFpblNWRy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKSApXG4gICAgICAgIGNvbnN0IHJlZ0V4ID0gL14oXFxkezR9KVxccyhcXGR7M30pJC9pZztcbiAgICAgICAgY29uc3QgdmFsdWVzID0gW11cbiAgICAgICAgdmFsdWVzLmxlbmd0aCA9IDAgIFxuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5zbGlkZXJzLmxlbmd0aDtcbiAgICAgICAgY29uc3Qgcm9sbGVyVW5pdCA9IHRoaXMuc2xpZGVyc1xuICAgICAgICBjb25zdCBjb2RlRWxlbWVudHMgPSB0aGlzLmNvZGVDb250YWluZXJzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJvbGxlckVsZW0gPSByb2xsZXJVbml0W2ldXG4gICAgICAgICAgICBjb25zdCBjb2RlRWxlbSA9IGNvZGVFbGVtZW50c1tpXVxuICAgICAgICBcbiAgICAgICAgICAgIHN3aXRjaCAocG9zKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29udGFpbmVyJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNsaWRlcnNDb250YWluZXJcbiAgICAgICAgICAgICAgICBjYXNlICd2aWV3Qm94V2lkdGgnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZS5yZXBsYWNlKHJlZ0V4LCAnJDEnKVxuICAgICAgICAgICAgICAgIGNhc2UgJ3ZpZXdCb3hIZWlnaHQnOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2l6ZS5yZXBsYWNlKHJlZ0V4LCAnJDInKVxuICAgICAgICAgICAgICAgIGNhc2UgJ2VsJzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2gocm9sbGVyRWxlbSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVjdFgnOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCggdGhpcy5nZXRSZWN0KCByb2xsZXJFbGVtICkucmVjdC54ICkgLy8gbm90IGluIHVzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb2RlQm94LngnOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCggdGhpcy5nZXRSZWN0KCBjb2RlRWxlbSApLnJlY3QueCApIFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb2RlYkJveC54JzogICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goIHRoaXMuZ2V0UmVjdCggY29kZUVsZW0gKS5iQm94LnggKSBcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYkJveFgnOiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCggdGhpcy5nZXRSZWN0KCByb2xsZXJFbGVtICkuYkJveC54ICkvLyBub3QgaW4gdXNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3knOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCggdGhpcy5nZXRSZWN0KCByb2xsZXJFbGVtICkuYkJveC55ICkgICBcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnd2lkdGgnOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCggdGhpcy5nZXRSZWN0KCByb2xsZXJFbGVtICkuYkJveC53aWR0aCApICAgXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hlaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCB0aGlzLmdldFJlY3QoIHJvbGxlckVsZW0gKS5iQm94LmhlaWdodCApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzXG4gICAgfVxufTtcblxuY2xhc3MgUm9sbGVyVW5pdCBleHRlbmRzIEFzc2VtYmx5TGluZSB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKVxuICAgICAgICB0aGlzLmdldFJlY3QgPSB0aGlzLmdldFJlY3RcbiAgICAgICAgdGhpcy5kcmF3ID0gdGhpcy5kcmF3LmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5iZWdpblBvcyA9IFtdXG4gICAgICAgIHRoaXMuZGlzdCA9IFtdXG4gICAgICAgIHRoaXMubGVzc1RoYW4gPSAnJ1xuICAgICAgICB0aGlzLnN0YXJ0ID0gMFxuICAgICAgICB0aGlzLnRpbWUgPSAxMDAwXG4gICAgICAgIHRoaXMuY3VycmVudCA9IHt9XG4gICAgICAgIHRoaXMuY2xpY2sgPSAwXG4gICAgICAgIHRoaXMuYmVsdENsaWNrID0gMFxuICAgICAgICB0aGlzLmZvcmVpbk9ianMgPSBfKCdhc3NlbWJseS1pbWctZm9yZWlnbk9iaicpXG4gICAgICAgIHRoaXMuZm9yZWluR3JvdXAgPSBfKCdhc3NlbWJseS1pbWctd3JhcCcpXG4gICAgICAgIHRoaXMuYmVsdHMgPSBfKCdiZWx0JylcbiAgICB9XG5cbiAgICBzdGFydFBvcyhlbGVtKXtcbiAgICAgICAgbGV0IGFyciA9IFtdXG4gICAgICAgIGxldCBlbCA9IGVsZW1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZWwubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIGVsW2ldLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKSApe1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKCBwYXJzZUludCAoIGVsW2ldLnN0eWxlLnRyYW5zZm9ybS5yZXBsYWNlKC9eKFtcXHddKilcXCgoWz8tXFxkXS4qKXB4XFwpL2lnLCBcIiQyXCIpICkgKVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goMCkgXG4gICAgICAgICAgICB9ICBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgbWluKCBzdGFydCxhY3R1YWwgPSBbXSl7XG4gICAgICAgIGxldCByZWN0ID0gTWF0aC5taW4oLi4uc3RhcnQpXG4gICAgICAgIGxldCBkaXN0ID0gTWF0aC5taW4oLi4uYWN0dWFsKVxuICAgICAgICBsZXQgaW5kZXggPSBzdGFydC5pbmRleE9mKHJlY3QpXG4gICAgICAgIHJldHVybiB7aW5kZXgsZGlzdH0gICAgICAgICBcbiAgICB9XG4gICAgbWF4KCBzdGFydCxhY3R1YWwgKXtcbiAgICAgICAgbGV0IHJlY3QgPSBNYXRoLm1heCguLi5zdGFydClcbiAgICAgICAgbGV0IGRpc3QgPSBNYXRoLm1heCguLi5hY3R1YWwpXG4gICAgICAgIGxldCBpbmRleCA9IHN0YXJ0LmluZGV4T2YocmVjdClcbiAgICAgICAgcmV0dXJuIHtpbmRleCxkaXN0fVxuICAgIH1cblxuICAgIGdldERpc3RhbmNlKCl7XG4gICAgICAgIGxldCB3aWR0aCA9IHRoaXMuZ2V0RWxlbVZhbHVlKCd3aWR0aCcpWzBdXG4gICAgICAgIGxldCBhcnIgPSBbXVxuICAgICAgICBsZXQgc3RhcnRpbmdQb2ludCA9IHRoaXMuZ2V0RWxlbVZhbHVlKCdjb2RlQm94LngnKVxuICAgICAgICBsZXQgYWN0dWFsRGlzdCA9IHRoaXMuZ2V0RWxlbVZhbHVlKCdjb2RlYkJveC54JylcbiAgICBcbiAgICAgICAgY29uc3QgbWF4RWxlbWVudCA9IHRoaXMubWF4KHN0YXJ0aW5nUG9pbnQsYWN0dWFsRGlzdClcbiAgICAgICAgY29uc3QgbWluRWxlbWVudCA9IHRoaXMubWluKHN0YXJ0aW5nUG9pbnQsYWN0dWFsRGlzdClcblxuICAgICAgICBjb25zdCBtb3ZlRW5kID0gKGspID0+IHtcbiAgICAgICAgICAgIGxldCBkaXN0ID0gdGhpcy5sZWZ0ID8gNDMxIDogLTQzMSAgLy8gbW92ZUJlZ2lubmluZyBkaXN0ICogMiAgICBcbiAgICAgICAgICAgIGFyci5wdXNoKHtkaXN0OiBkaXN0LCBpbmRleDogaywgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1vdmVCZWdpbm5pbmcgPSAoaykgPT4ge1xuICAgICAgICAgICAgbGV0IGRpc3QgPSB0aGlzLmxlZnQgPyAobWluRWxlbWVudC5kaXN0ICsgd2lkdGgpIDogLShtaW5FbGVtZW50LmRpc3QgKyB3aWR0aCkgXG4gICAgICAgICAgICBsZXQgcmlnaHRQYWdlU3RhcnQgPSB0aGlzLmxlZnQgPyBhY3R1YWxEaXN0LnJldmVyc2UoKVtrXSArIHdpZHRoIDogLWFjdHVhbERpc3Rba10gLSB3aWR0aFxuICAgICAgICBcbiAgICAgICAgICAgIHRoaXMubGVzc1RoYW4gPSBrICAvL1VwZGF0ZXMgdGhlIHNtYWxsZXN0IGRpc3RhbmNlXG4gICAgICAgICAgICBhcnIucHVzaCh7ZGlzdDogZGlzdCoyLGluZGV4OiBrLCByaWdodFBhZ2VTdGFydDogcmlnaHRQYWdlU3RhcnQsIHBhZ2VSaWdodDogdHJ1ZX0pXG4gICAgICAgIH1cblxuICAgICAgICBmb3IobGV0IGsgPSAwOyBrIDwgMzsgaysrICl7XG4gICAgXG4gICAgICAgICAgICBpZiAoIG1pbkVsZW1lbnQuaW5kZXggPT09IGsgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodCA/IG1vdmVFbmQoaykgOiBtb3ZlQmVnaW5uaW5nKGspICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfWVsc2UgaWYoIG1heEVsZW1lbnQuaW5kZXggPT09IGsgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yaWdodCA/IG1vdmVCZWdpbm5pbmcoaykgOiAgbW92ZUVuZChrKVxuXG4gICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGRpc3QgPSB0aGlzLmxlZnQgPyA0MzEgOiAtNDMxICAvLyBtb3ZlQmVnaW5uaW5nIGRpc3QgKiAyXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goe2Rpc3Q6IGRpc3QsIGluZGV4OiBrfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcnIuc29ydCA9IChhLGIpID0+IGEucGxhY2UgLSBiLnBsYWNlXG4gICAgICAgIHJldHVybiBhcnJcbiAgICB9XG5cbiAgICAvLyBBZGQgYW5kIHJlbW92ZSBmb3JlaWduT2JqZWN0cyBpbnRvIHNsaWRlclxuICAgIGZvcmVpbk9iakFycigpe1xuICAgICAgICAvLyBsZXQgbGVuZ3RoID0gIHRoaXMuZm9yZWluT2Jqcy5sZW5ndGhcbiAgICAgICAgbGV0IGxlbmd0aCA9ICB0aGlzLmZvcmVpbkdyb3VwLmxlbmd0aFxuICAgICAgICBsZXQgYXJyID0gbmV3IEFycmF5KGxlbmd0aClcblxuICAgICAgICAvLyBQdXRzIGltYWdlIGZvcmVpZ25vYmplY3RzIGludG8gYXJyYXlcbiAgICAgICAgd2hpbGUobGVuZ3RoKSB7XG4gICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgIGFycltsZW5ndGhdID0gdGhpcy5mb3JlaW5Hcm91cFtsZW5ndGhdO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHN0YXJ0aW5nUG9pbnQgPSB0aGlzLmdldEVsZW1WYWx1ZSgnY29kZUJveC54JylcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5taW4oc3RhcnRpbmdQb2ludCkuaW5kZXhcbiAgICAgICAgXG4gICAgICAgIGxldCBhZGQgPSBhcnIuc3BsaWNlKDMsMSlcbiAgICAgICAgbGV0IHJlbW92ZWQgPSBhcnIuc3BsaWNlKGluZGV4LDEpXG5cbiAgICAgICAgbGV0IHJlbW92ZWRDaGlsZCA9IHJlbW92ZWRbMF0uY2hpbGROb2Rlc1sxXVxuICAgICAgICBsZXQgYWRkQ2hpbGQgPSBhZGRbMF0uY2hpbGROb2Rlc1sxXVxuICAgICAgICBhcnIuc3BsaWNlKGluZGV4LDAsYWRkWzBdKVxuICAgICAgICBhcnIucHVzaChyZW1vdmVkWzBdKVxuXG4gICAgICAgIC8vQWRkIGFuZCByZW1vdmUganVzdCB0cmFuc2Zvcm1zIGZpcnN0XG4gICAgICAgIGxldCBzdHlsZVRyYW5zZm9ybSA9ICByZW1vdmVkWzBdLmF0dHJpYnV0ZXNbMV1cbiAgICAgICAgcmVtb3ZlZFswXS5yZW1vdmVBdHRyaWJ1dGUoIHN0eWxlVHJhbnNmb3JtLm5hbWUpIFxuICAgICAgICBhZGRbMF0uc2V0QXR0cmlidXRlKHN0eWxlVHJhbnNmb3JtLm5hbWUsIHN0eWxlVHJhbnNmb3JtLnZhbHVlKSAgICAgXG5cbiAgICAgICAgLy9TdHJpcHMgYXR0cmlidXRlcyBvZiByZW1vdmVkIGFuZCBhZGQgc2FtZSBhdHRyaWJ1dGVzIHRvIGFkZGVkIGZvcmVpZ25vYmplY3RcbiAgICAgICAgd2hpbGUoIHJlbW92ZWRDaGlsZC5hdHRyaWJ1dGVzLmxlbmd0aCA+IDEpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IGF0dHJOYW1lID0gIHJlbW92ZWRDaGlsZC5hdHRyaWJ1dGVzWzFdLm5hbWUgXG4gICAgICAgICAgICBsZXQgYXR0clZhbHVlID0gIHJlbW92ZWRDaGlsZC5hdHRyaWJ1dGVzWzFdLnZhbHVlIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBhZGRDaGlsZC5zZXRBdHRyaWJ1dGUoYXR0ck5hbWUsIGF0dHJWYWx1ZSlcbiAgICAgICAgICAgIHJlbW92ZWRDaGlsZC5yZW1vdmVBdHRyaWJ1dGUoIHJlbW92ZWRDaGlsZC5hdHRyaWJ1dGVzWzFdLm5hbWUpXG4gICAgICAgIH0gXG4gICAgICAgIFxuICAgICAgICB0aGlzLmZvcmVpbkdyb3VwID0gYXJyXG4gICAgfVxuICAgIFxuICAgIC8vIFJhbiBvbmNlIHdoZW4gcGFnZSByZWxvYWRzXG4gICAgcG9zaXRpb25Gb3JpZWduT2JqZWN0KF90aGlzKXtcbiAgICAgICAgbGV0IHNsaWRlcnMgPSB0aGlzLmNvZGVDb250YWluZXJzXG4gICAgICAgIGxldCBmb3JlaWduT2JqZWN0cyA9IHRoaXMuZm9yZWluT2Jqc1xuICAgICAgICBsZXQgbGVuZ3RoID0gc2xpZGVycy5sZW5ndGhcbiAgICBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgc2xpZGVyX3ggPSB0aGlzLmdldFJlY3QodGhpcy5jb2RlQ29udGFpbmVyc1tpXSkuYkJveC54XG4gICAgICAgICAgICBsZXQgc2xpZGVyX3kgPSB0aGlzLmdldFJlY3QodGhpcy5jb2RlQ29udGFpbmVyc1tpXSkuYkJveC55XG4gICAgICAgICAgICBsZXQgc2xpZGVyX3dpZHRoID0gdGhpcy5nZXRSZWN0KHRoaXMuY29kZUNvbnRhaW5lcnNbaV0pLmJCb3gud2lkdGhcbiAgICAgICAgICAgIGxldCBzbGlkZXJfaGVpZ2h0ID0gdGhpcy5nZXRSZWN0KHRoaXMuY29kZUNvbnRhaW5lcnNbaV0pLmJCb3guaGVpZ2h0XG4gICAgXG4gICAgICAgICAgICBmb3JlaWduT2JqZWN0c1tpXS5zZXRBdHRyaWJ1dGUoJ3gnLCBzbGlkZXJfeClcbiAgICAgICAgICAgIGZvcmVpZ25PYmplY3RzW2ldLnNldEF0dHJpYnV0ZSgneScsIHNsaWRlcl95KVxuICAgICAgICAgICAgZm9yZWlnbk9iamVjdHNbaV0uc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNsaWRlcl93aWR0aClcbiAgICAgICAgICAgIGZvcmVpZ25PYmplY3RzW2ldLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2xpZGVyX2hlaWdodClcbiAgICAgICAgfVxuICAgICAgICAvL0lucHV0cyBpbWFnZSBpbnRvIGNvbnRhaW5lclxuICAgICAgICBfdGhpcy50YXJnZXRFbGVtKClcbiAgICB9XG4gICAgXG4gICAgXG4gICAgbW9yZVRoYW5IYWxmKCBkaXN0LCBwb3NpdGl2ZUN1cnJlbnQsIHN0YXJ0RGlzdCApe1xuICAgICAgICByZXR1cm4gZGlzdCAtIChzdGFydERpc3QgLSBwb3NpdGl2ZUN1cnJlbnQpXG4gICAgfVxuICAgIFxuICAgIGxlc3NUaGFuSGFsZihjdXJyZW50LCBkaXN0LCBzdGFydERpc3Qpe1xuICAgICAgICBsZXQgZCA9IGRpc3QuZGlzdCA8IDAgPyBkaXN0LmRpc3QgKiAtMSA6IGRpc3QuZGlzdFxuXG4gICAgICAgIGlmKHN0YXJ0RGlzdCA9PT0gMCApe1xuICAgICAgICAgICAgaWYoZGlzdC5yaWdodFBhZ2VTdGFydCl7XG4gICAgICAgICAgICAgICAgbGV0IGRpZmYgPSBjdXJyZW50IC0gc3RhcnREaXN0IFxuICAgICAgICAgICAgICAgIGxldCB0b3RhbERpZmYgPSBkIC0gIChjdXJyZW50IC0gc3RhcnREaXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmICsgdG90YWxEaWZmXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZCAtIGN1cnJlbnRcbiAgICAgICAgICAgIFxuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICBpZihkaXN0LnJpZ2h0UGFnZVN0YXJ0KXtcbiAgICAgICAgICAgICAgICBsZXQgZGlmZiA9IGN1cnJlbnQgLSBzdGFydERpc3QgXG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsRGlmZiA9IGQgLSAgTWF0aC5hYnMoY3VycmVudCAtIHN0YXJ0RGlzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiArIHRvdGFsRGlmZlxuICAgICAgICAgICAgfSAgXG4gICAgICAgICAgICBsZXQgZGlmZiA9IGQgLSBNYXRoLmFicyhjdXJyZW50IC0gc3RhcnREaXN0KVxuICAgICAgICAgICAgcmV0dXJuIGRpZmZcbiAgICAgICAgfVxuICAgIH1cbiAgICBvcHBpc2l0ZURpcihjdXJyZW50LCBzdGFydERpc3Qpe1xuICAgICAgICBpZihzdGFydERpc3QgPT09IDApe1xuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgaWYoY3VycmVudCA+IHN0YXJ0RGlzdCl7IC8vIG1vcmUgdGhhbiBoYWxmXG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQgLSBzdGFydERpc3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdGFydERpc3QgLSBjdXJyZW50ICAgLy9sZXNzIHRoYW4gaGFsZiAgICBcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVSaWdodFBhZ2VTdGFydChkLHJpZ2h0UGFnZVN0YXJ0LCBwb3NDdXJyZW50LCBzdGFydERpc3Qpe1xuICAgIFxuICAgICAgICBpZihzdGFydERpc3QgPCAwKXtcbiAgICAgICAgICAgIC8vbW9yZSB0aGFuIGhhbGZcbiAgICAgICAgICAgIGlmKGQgPiBwb3NDdXJyZW50KXsgIFxuICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IHBvc0N1cnJlbnRcbiAgICAgICAgICAgICAgICByZXR1cm4ge2Rpc3RhbmNlLCBwYWdlUmlnaHQ6IGZhbHNlfSBcbiAgICAgICAgICAgIC8vbGVzcyB0aGFuIGhhbGZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBkaWZmZXJlbmNlID0gKDExNDEuMiAtIHBvc0N1cnJlbnQpIFxuICAgICAgICAgICAgbGV0IHRvdGFsRGlmID0gZCAtICgxMTQxLjIgLSBwb3NDdXJyZW50KVxuICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gZGlmZmVyZW5jZSArIHRvdGFsRGlmXG4gICAgICAgICAgICByZXR1cm4ge2Rpc3RhbmNlLCBwYWdlUmlnaHQ6IHRydWV9XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL2xlc3MgdGhhbiBoYWxmIG9ubHkgZWxlbWVudCB3aXRoIGEgcmlnaHRQYWdlU3RhcnQgb2YgMTE0MS4yXG4gICAgICAgICAgICBpZihyaWdodFBhZ2VTdGFydCA+IDExNjApeyAvLzExNjBcbiAgICAgICAgICAgICAgICBsZXQgZGlmZmVyZW5jZSA9IGQgLyAyIC0gcG9zQ3VycmVudFxuICAgICAgICAgICAgICAgIGxldCB0b3RhbERpZiA9IGQgLSAgZGlmZmVyZW5jZVxuICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IHRvdGFsRGlmICsgZGlmZmVyZW5jZVxuICAgICAgICAgICAgICAgIHJldHVybiB7ZGlzdGFuY2UsIHBhZ2VSaWdodDogdHJ1ZX1cbiAgICAgICAgICAgIC8vbW9yZSB0aGFuIGhhbGZcbiAgICAgICAgICAgIH1lbHNlIGlmKHBvc0N1cnJlbnQgPCBzdGFydERpc3QgKXsgXG4gICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gc3RhcnREaXN0IC0gcG9zQ3VycmVudCBcbiAgICAgICAgICAgICAgICByZXR1cm4ge2Rpc3RhbmNlLCBwYWdlUmlnaHQ6IGZhbHNlIH1cbiAgICAgICAgICAgIC8vbGVzcyB0aGFuIGhhbGYgXG4gICAgICAgICAgICB9ZWxzZXsgIFxuICAgICAgICAgICAgICAgIGxldCBkaWZmID0gcG9zQ3VycmVudCAtIHN0YXJ0RGlzdCBcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxEaWZmID0gZCAtICAocG9zQ3VycmVudCAtIHN0YXJ0RGlzdClcbiAgICAgICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSBkaWZmICsgdG90YWxEaWZmXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtkaXN0YW5jZSwgcGFnZVJpZ2h0OiB0cnVlfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vICoqIFJJR0hUIEJVVFRPTiBJUyBORUdBVElWRSBESVNULCBMRUZUIEJVVFRPTiBJUyBQT1NJVElWRSBESVNUKipcbiAgICBoYW5kbGVEb3VibGVDbGljayhjdXJyZW50LCBkaXN0LCBiZWdpblBvcyl7XG4gICAgICAgIC8vVXBkYXRlcyBob3cgbWFueSB0aW1lcyBiYWNrIGFuZCBmb3J0aCBiZWZvcmUgYW5pbWF0aW9uIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuY2xpY2sgKytcblxuICAgICAgICBsZXQgY3VycmVudERpcmVjdGlvbiA9IE1hdGguc2lnbiggdGhpcy5jdXJyZW50RGlzdFsxXS5kaXN0IClcbiAgICAgICAgbGV0IGRpc3REaXJlY3Rpb24gPSBNYXRoLnNpZ24oIGRpc3RbMV0uZGlzdCApXG4gICAgICAgIFxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgMzsgaSsrKXtcblxuICAgICAgICAgICAgLy9NaWRkbGUgZGlzdCBub3QgZXF1YWwgYm90aCBuZWdhdGl2ZSBvciBwb3NpdGl2ZXMgdGhlbiB1c2UgY3VycmVudCBkaXN0XG4gICAgICAgICAgICBsZXQgZGlzdF9pID0gY3VycmVudERpcmVjdGlvbiAhPT0gZGlzdERpcmVjdGlvbiA/IHRoaXMuY3VycmVudERpc3RbaV0gOiBkaXN0W2ldXG4gICAgICAgICAgICBsZXQgZCA9IGRpc3RfaS5kaXN0IDwgMCA/IGRpc3RfaS5kaXN0ICogLTEgOiBkaXN0X2kuZGlzdCAgLy9jaGFuZ2VkIHRoaXNcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9TdGFydHMgb2ZmIHdpdGggcG9zaXRpdmUgdmFyaWFibGVzXG4gICAgICAgICAgICBsZXQgcmlnaHRQYWdlU3RhcnQgPSBkaXN0X2kucmlnaHRQYWdlU3RhcnQgPCAwID8gZGlzdF9pLnJpZ2h0UGFnZVN0YXJ0ICogLTEgOiBkaXN0X2kucmlnaHRQYWdlU3RhcnRcbiAgICAgICAgICAgIGxldCBzdGFydERpc3QgPSBiZWdpblBvc1tpXSA8IDAgPyBiZWdpblBvc1tpXSAqIC0xIDogYmVnaW5Qb3NbaV1cbiAgICAgICAgICAgIGxldCBwb3NDdXJyZW50ID0gY3VycmVudFtpXSA8IDAgPyBjdXJyZW50W2ldICogLTEgOiBjdXJyZW50W2ldXG5cbiAgICAgICAgICAgIC8vIFdoZW4gY2xpY2tlZCBvcHBvc2l0ZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIGlmKCBjdXJyZW50RGlyZWN0aW9uICE9PSBkaXN0RGlyZWN0aW9uKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCByaWdodFBhZ2VTdGFydCApe1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmlnaHRTdGFydCA9IHRoaXMucmlnaHQgPyAtcmlnaHRQYWdlU3RhcnQgOiByaWdodFBhZ2VTdGFydFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1ciA9IHRoaXMuaGFuZGxlUmlnaHRQYWdlU3RhcnQoZCxyaWdodFBhZ2VTdGFydCwgcG9zQ3VycmVudCwgc3RhcnREaXN0LCB0aGlzLmN1cnJlbnREaXN0W2ldLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyRGlzdCA9IHRoaXMucmlnaHQgPyAtY3VyLmRpc3RhbmNlIDogY3VyLmRpc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYWdlUmlnaHQgPSBjdXIucGFnZVJpZ2h0XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0LnB1c2goe2Rpc3Q6IGN1ckRpc3QsIGluZGV4OiBkaXN0X2kuaW5kZXgsIHJpZ2h0UGFnZVN0YXJ0OiByaWdodFN0YXJ0LCBwYWdlUmlnaHQ6IHBhZ2VSaWdodH0pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmVnaW5Qb3MucHVzaChjdXJyZW50W2ldKVxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSB0aGlzLm9wcGlzaXRlRGlyKCBwb3NDdXJyZW50LCBzdGFydERpc3QpXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gdGhpcy5yaWdodCAmJiBkaXN0YW5jZSA+IDAgPyAtZGlzdGFuY2UgOiBkaXN0YW5jZVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdC5wdXNoKHtkaXN0OiBkaXN0LCBpbmRleDogZGlzdF9pLmluZGV4LCByaWdodFBhZ2VTdGFydDogZGlzdF9pLnJpZ2h0UGFnZVN0YXJ0LCBwYWdlUmlnaHQ6IGZhbHNlfSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpblBvcy5wdXNoKGN1cnJlbnRbaV0pXG4gICAgICAgICAgICAgICAgfSAgICAgIFxuICAgICAgICAgICAgLy9DbGlja2VkIHNhbWUgZGlyZWN0aW9uXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAvL0FmdGVyIGVsZW1lbnQgc3RhcnRzIGZyb20gaGlkZGVuIHBhcnQgb2YgcGFnZVxuICAgICAgICAgICAgICAgIGlmKCggdGhpcy5yaWdodCAmJiByaWdodFBhZ2VTdGFydCAmJiBjdXJyZW50W2ldIDwgMCkgfHwgdGhpcy5sZWZ0ICYmIGN1cnJlbnRbaV0gPiAwICYmIHJpZ2h0UGFnZVN0YXJ0ICApe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZXNzVGhhbiA9IGRpc3RfaS5pbmRleCAvL2hhdmUgdG8gdXBkYXRlIHJpZ2h0UGFnZVN0YXJ0IGFnYWluIGR1ZSB0byBydW5uaW5nIHRoaXMuZ2V0RGlzdGFuY2UoKSB0d2ljZVxuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSBkIC8gMiAtICggcmlnaHRQYWdlU3RhcnQgLSBwb3NDdXJyZW50ICkgIFxuICAgICAgICAgICAgICAgICAgICBsZXQgUG9zT3JOZWdEaXN0YW5jZSA9IHRoaXMucmlnaHQgJiYgZGlzdGFuY2UgPiAwID8gZGlzdGFuY2UgKiAtMTogZGlzdGFuY2VcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3QucHVzaCh7ZGlzdDogUG9zT3JOZWdEaXN0YW5jZSwgaW5kZXg6IGRpc3RfaS5pbmRleCwgcmlnaHRQYWdlU3RhcnQ6IGRpc3RfaS5yaWdodFBhZ2VTdGFydCwgcGFnZVJpZ2h0OiBmYWxzZX0pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmVnaW5Qb3MucHVzaChjdXJyZW50W2ldKVxuICAgICAgICAgICAgICAgIH1lbHNleyAgXG4gICAgICAgICAgICAgICAgICAgIGxldCBsZXNzVGhhbmhhbGYgPSBzdGFydERpc3QgPCBwb3NDdXJyZW50IHx8IChzdGFydERpc3QgJiYgcG9zQ3VycmVudCA8IGQpID8gdHJ1ZSA6IGZhbHNlICBcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gbGVzc1RoYW5oYWxmID8gdGhpcy5sZXNzVGhhbkhhbGYoIHBvc0N1cnJlbnQsIGRpc3RfaSwgc3RhcnREaXN0KSA6IHRoaXMubW9yZVRoYW5IYWxmKCBkLCBwb3NDdXJyZW50LCBzdGFydERpc3QgKSAgICBcbiAgICAgICAgICAgICAgICAgICAgbGV0IFBvc09yTmVnRGlzdGFuY2UgPSB0aGlzLnJpZ2h0ID8gLWRpc3RhbmNlIDogZGlzdGFuY2VcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3QucHVzaCh7ZGlzdDogUG9zT3JOZWdEaXN0YW5jZSwgaW5kZXg6IGRpc3RfaS5pbmRleCwgcmlnaHRQYWdlU3RhcnQ6IGRpc3RfaS5yaWdodFBhZ2VTdGFydCwgcGFnZVJpZ2h0OiB0cnVlfSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpblBvcy5wdXNoKGN1cnJlbnRbaV0pXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vUmVtb3ZlcyBwcmlvciB2YWx1ZXMgaW4gYXJyYXlzXG4gICAgICAgIHRoaXMuZGlzdC5zcGxpY2UoMCwzKSwgdGhpcy5iZWdpblBvcy5zcGxpY2UoMCwzKVxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmRpc3QsIHRoaXMuYmVnaW5Qb3MpXG4gICAgfVxuICAgIC8vVXBkYXRlcyBzbGlkZXJzIHBvc2l0aW9uc1xuICAgIHVwZGF0ZVBvcygpe1xuICAgICAgICAvLyBIYW5kbGVzIGJhY2sgYW5kIGZvcnRoIGNsaWNraW5nXG4gICAgICAgIGlmKHRoaXMuc3RhcnQpe1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IDBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RGlzdCA9IHRoaXMuZ2V0RGlzdGFuY2UoKVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QmVnaW5Qb3MgPSB0aGlzLnN0YXJ0UG9zKHRoaXMuc2xpZGVycylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZURvdWJsZUNsaWNrKHRoaXMuY3VycmVudCwgdGhpcy5kaXN0LCB0aGlzLmJlZ2luUG9zKVxuICAgICAgICAgICAgXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCZWx0UG9zKClcbiAgICAgICAgICAgIHRoaXMuYmVnaW5Qb3MubGVuZ3RoID0gMFxuICAgICAgICAgICAgdGhpcy5kaXN0Lmxlbmd0aCA9IDBcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSB0aGlzLmdldERpc3RhbmNlKClcbiAgICAgICAgICAgIGNvbnN0IGJlZ2luUG9zID0gdGhpcy5zdGFydFBvcyh0aGlzLnNsaWRlcnMpXG4gICAgICAgICAgICAvLyAzIGlzIGxlbmd0aCBvZiBzbGlkZXIgZWxlbWVudHNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuYmVnaW5Qb3MucHVzaChiZWdpblBvc1tpXSlcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3QucHVzaChkaXN0W2ldKVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmRyYXcpXG4gICAgICAgIH1cbiAgICB9XG4gICAgYW5pbWF0ZUJlbHRzKHRvcEdlYXJzLCBib3R0b21HZWFycyl7XG4gICAgICAgIF8oJ3RlZXRoLXdyYXBwZXItdG9wJykuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgkeyB0b3BHZWFycyB9cHgpYFxuICAgICAgICBfKCd0ZWV0aC13cmFwcGVyLWJvdHRvbScpLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHsgYm90dG9tR2VhcnMgfXB4KWBcbiAgICB9XG5cbiAgICBhbmltYXRlKHNsaWRlcnMsIGltZ0dyb3VwLCB2YWx1ZSl7XG4gICAgICAgIHNsaWRlcnMuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgkeyB2YWx1ZSB9cHgpYFxuICAgICAgICBpbWdHcm91cC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7IHZhbHVlIH1weClgXG4gICAgfVxuXG4gICAgZHJhdyh0aW1lc3RhbXApe1xuICAgICAgICBjb25zdCB0aW1lID0gdGhpcy50aW1lXG4gICAgICAgIGlmKCF0aGlzLnN0YXJ0KSB0aGlzLnN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgIHRoaXMucnVudGltZSA9IHRpbWVzdGFtcCAtIHRoaXMuc3RhcnQ7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4odGhpcy5ydW50aW1lIC8gdGltZSwgMSlcblxuICAgICAgICBsZXQgaiA9IHRoaXMubGVzc1RoYW5cbiAgICBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgXG4gICAgICAgICAgICBsZXQgbnVtID0gaSAhPT0gaiA/IGkgOiBqXG4gICAgICAgICAgICBsZXQgc2xpZGVycyA9IHRoaXMuc2xpZGVyc1tudW1dXG4gICAgXG4gICAgICAgICAgICBsZXQgaW1nR3JvdXAgPSB0aGlzLmZvcmVpbkdyb3VwW251bV1cbiAgICBcbiAgICAgICAgICAgIGxldCBiZWdpblBvcyA9IHRoaXMuYmVnaW5Qb3NbbnVtXVxuICAgICAgICAgICAgbGV0IGRpc3QgPSB0aGlzLmRpc3RbbnVtXS5kaXN0XG4gICAgICAgICAgICBsZXQgcmlnaHRTdGFydCA9IHRoaXMuZGlzdFtudW1dLnJpZ2h0UGFnZVN0YXJ0XG4gICAgICAgICAgICBsZXQgcGFnZVJpZ2h0ID0gdGhpcy5kaXN0W251bV0ucGFnZVJpZ2h0ICAgXG4gICAgICAgICAgICAvL1JpZ2h0IG9yIExlZnQgc2lkZSBlbGVtZW50IGFuaW1hdGUgdG8gb3RoZXIgc2lkZSBvZiBzY3JlZW5cbiAgICAgICAgICAgIGlmKG51bSA9PT0gaiAmJiBwYWdlUmlnaHQpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHByb2dyZXNzIDw9IC41KXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gYmVnaW5Qb3MgLSAoZGlzdCAqIHByb2dyZXNzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRbbnVtXSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZShzbGlkZXJzLCBpbWdHcm91cCwgdmFsdWUpXG4gICAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSByaWdodFN0YXJ0IC0gKCBkaXN0ICogKHByb2dyZXNzIC0gLjUpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRbbnVtXSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZShzbGlkZXJzLCBpbWdHcm91cCwgdmFsdWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBiZWdpblBvcyAtIChkaXN0ICogcHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50W251bV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZShzbGlkZXJzLCBpbWdHcm91cCwgdmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmVsdHMgQW5pbWF0aW9uXG4gICAgICAgIGxldCB0b3BHZWFycyA9IHRoaXMuYmVsdFBvcy5zdGFydFBvc1swXSArICh0aGlzLmJlbHRQb3MuZGlzdCAqIHByb2dyZXNzKSBcbiAgICAgICAgbGV0IGJvdHRvbUdlYXJzID0gdGhpcy5iZWx0UG9zLnN0YXJ0UG9zWzFdIC0gKHRoaXMuYmVsdFBvcy5kaXN0ICogcHJvZ3Jlc3MpXG4gICAgICAgIHRoaXMuYW5pbWF0ZUJlbHRzKHRvcEdlYXJzLCBib3R0b21HZWFycylcbiAgICAgICAgaWYocHJvZ3Jlc3MgPCAxKXtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmRyYXcpXG4gICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAgIHRoaXMuZm9yZWluT2JqQXJyKClcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSAwXG4gICAgICAgICAgICB0aGlzLmJlbHRDbGljayArK1xuICAgICAgICAgICAgdGhpcy5jbGljayA9IDBcbiAgICAgICAgICAgIGltZ0lubGFyZ2UudGFyZ2V0RWxlbSgpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBcbiAgICB9XG4gICAgLy9TdGFycyBnZWFycyBpbmxpbmUgbGVmdCBvciByaWdodCBkZXBlbmRpbmcgb24gbGVmdCBvciByaWdodCBjbGlja1xuICAgIGJlbHREaXJlY3Rpb25zKCl7XG4gICAgICAgIGxldCBiZWx0V2lkdGggPSBfKCdib3R0b20tbWFpbicpLmdldEJCb3goKS53aWR0aFxuXG4gICAgICAgIGlmKHRoaXMucmlnaHQpe1xuICAgICAgICAgICAgXygnYm90dG9tLXRlZXRoJykuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSggJHtiZWx0V2lkdGh9cHggKWBcbiAgICAgICAgICAgIF8oJ3RvcC10ZWV0aCcpLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoICR7LWJlbHRXaWR0aH1weCApYFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIF8oJ2JvdHRvbS10ZWV0aCcpLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoICR7LWJlbHRXaWR0aH1weCApYFxuICAgICAgICAgICAgXygndG9wLXRlZXRoJykuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSggJHtiZWx0V2lkdGh9cHggKWBcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVCZWx0UG9zKCl7XG4gICAgICAgIGxldCBiZWx0cyA9IHRoaXMuc3RhcnRQb3ModGhpcy5iZWx0cylcbiAgICAgICAgbGV0IHN0YXJ0UG9zLCBkaXN0OyBcblxuICAgICAgICAgICAgLy8gU3RhcnRzIGdlYXJzIG9uIG9uZSBzaWRlIG9mIHRoZSBwYWdlIG9yIHRoZSBvdGhlciBcbiAgICAgICAgaWYoIHRoaXMuYmVsdENsaWNrID09PSAwIHx8IHRoaXMuYmVsdENsaWNrICYmIGJlbHRzWzBdID09PSAwICkgdGhpcy5iZWx0RGlyZWN0aW9ucygpXG5cbiAgICAgICAgaWYodGhpcy5yaWdodCl7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGJlbHRzXG4gICAgICAgICAgICBkaXN0ID0gXygndG9wLXRlZXRoJykuZ2V0QkJveCgpLndpZHRoIC8gM1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMubGVmdCl7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGJlbHRzXG4gICAgICAgICAgICBkaXN0ID0gLSggXygndG9wLXRlZXRoJykuZ2V0QkJveCgpLndpZHRoIC8gMyApXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vS2VlcHMgR2VhcnMgYWx3YXlzIGxvb2tpbmcgbGlrZSB0aGVpciBuZXZlciBlbmRpbmdcbiAgICAgICAgaWYoIHRoaXMuYmVsdENsaWNrID09PSAzKXtcbiAgICAgICAgICAgIHRoaXMuYmVsdENsaWNrID0gMFxuICAgICAgICAgICAgdGhpcy5hbmltYXRlQmVsdHMoMCwgMClcbiAgICAgICAgICAgIHRoaXMuYmVsdERpcmVjdGlvbnMoKVxuICAgICAgICAgICAgc3RhcnRQb3MgPSBbMCwwXVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmVsdFBvcyA9IHtkaXN0LCBzdGFydFBvc31cbiAgICB9IFxufVxuXG5jbGFzcyBJbkxhcmdlSW1nIGV4dGVuZHMgUm9sbGVyVW5pdCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKVxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9ICBfKCdpbWctaW5sYXJnZS1jb250YWluZXInKVxuICAgICAgICB0aGlzLmFuaW1hdGVDbGlwUGF0aCA9IHRoaXMuYW5pbWF0ZUNsaXBQYXRoLmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5pbWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW5sYXJnZS1pbWctd3JhcCBpbWcnKVxuICAgICAgICB0aGlzLmltZ1dyYXAgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdpbmxhcmdlLWltZy13cmFwJylbMF1cbiAgICAgICAgdGhpcy5tb3VzZU1vdmUgPSB0aGlzLm1vdXNlTW92ZS5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIgPSB0aGlzLnJlbW92ZUxpc3RlbmVyLmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5tb3VzZVkgPSAwXG4gICAgICAgIHRoaXMuaW1hZ2VDbG9zZSA9IHRoaXMuaW1hZ2VDbG9zZS5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMudGFyZ2V0RWxlbSA9IHRoaXMudGFyZ2V0RWxlbVxuICAgICAgICB0aGlzLmNoZWNrRm9yRHVwbGljYXRlcyA9IHRoaXMuY2hlY2tGb3JEdXBsaWNhdGVzXG4gICAgICAgIHRoaXMubW92ZUVsZW1lbnQgPSB0aGlzLm1vdmVFbGVtZW50XG4gICAgICAgIHRoaXMuWSA9IDBcbiAgICB9XG4gICAgXG4gICAgYWRkQ2xpY2tMaXN0ZW5lcigpe1xuICAgICAgICBfKCdpbWctaW5sYXJnZS1jb250YWluZXInKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaW1hZ2VDbG9zZSk7IFxuICAgIH1cbiAgICByZW1vdmVDbGlja0xpc3RlbmVyKCl7XG4gICAgICAgIF8oJ2ltZy1pbmxhcmdlLWNvbnRhaW5lcicpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5pbWFnZUNsb3NlKTsgXG4gICAgfVxuICAgIGNoZWNrRm9yRHVwbGljYXRlcyhjbHNzTmFtZSl7XG4gICAgICAgIGNvbnN0IGltZ3MgPSB0aGlzLmltZ1dyYXAuY2hpbGRyZW5cbiAgICAgICAgbGV0IGxlbmd0aCA9IGltZ3MubGVuZ3RoXG4gICAgICAgIHdoaWxlKGxlbmd0aC0tKXtcbiAgICAgICAgICAgIGlmICggaW1nc1tsZW5ndGhdLmNsYXNzTmFtZSA9PT0gY2xzc05hbWUgKXtcbiAgICAgICAgICAgICAgICB0aGlzLmltZyA9IGltZ3NbbGVuZ3RoXTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUltZygpXG4gICAgICAgICAgICB9IFxuICAgICAgICB9XG4gICAgfVxuICAgIC8vUmVjdXJzaW9uXG4gICAgdGFyZ2V0RWxlbShlbGVtWCl7XG4gICAgICAgIFxuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5mb3JlaW5PYmpzLmxlbmd0aFxuICAgICAgICBsZXQgYXJyID0gW11cbiAgICAgICAgbGV0IGdyb3VwQXJyID0gW11cbiAgICAgICBcbiAgICAgICAgZm9yIChsZXQgaSA9IGxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tICl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIDFzdCBwdXNoZXMgb25seSBlbGVtZW50cyB3aXRoIHN0eWxlIGF0dHJpYnR1ZXMgb2YgeFxuICAgICAgICAgICAgaWYoIWVsZW1YICYmIHRoaXMuZm9yZWluT2Jqc1tpXS5oYXNBdHRyaWJ1dGUoJ3gnKSApe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGFyci5wdXNoKCB0aGlzLmZvcmVpbk9ianNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkueCApXG4gICAgICAgICAgICAgICAgZ3JvdXBBcnIucHVzaCh0aGlzLmZvcmVpbk9ianNbaV0ucGFyZW50Tm9kZSlcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNjYWxpbmcgaW1hZ2Ugb25seVxuICAgICAgICAgICAgaWYgKCB0aGlzLmZvcmVpbk9ianNbaV0ucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS54ID09PSBlbGVtWCAmJiB0aGlzLnRvZ2dsZU1vdmVFbGVtZW50KXtcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwID0gdGhpcy5mb3JlaW5PYmpzW2ldLnBhcmVudE5vZGVcbiAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICggdGhpcy5mb3JlaW5PYmpzW2ldLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnggPT09IGVsZW1YICl7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0ZvckR1cGxpY2F0ZXMoJ3dlYlZpc2libGUnKVxuICAgICAgICAgICAgICAgIGxldCBpbWdOb2RlID0gdGhpcy5mb3JlaW5PYmpzW2ldLmNoaWxkTm9kZXNbMV07XG4gICAgICAgICAgICAgICAgbGV0IGNsb25lZEltZyA9IGltZ05vZGUuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubW92ZUVsZW1lbnQoIGNsb25lZEltZywgJ3dlYlZpc2libGUnICkgIFxuICAgICAgICAgICAgfSBcbiAgICAgICAgfVxuICAgICAgICAvLyBNaWRkbGUgZWxlbWVudCB3aGljaCBpcyB0aGUgbWVkaWFuIG9mIHRoZSB0aHJlZSBlbGVtZW50c1xuICAgICAgICBsZXQgc29ydGVkID0gYXJyLnNvcnQoIChhLGIpID0+IGEgLSBiIClbMV1cbiAgICAgICAgdGhpcy50YXJnZXRFbGVtKHNvcnRlZClcbiAgICB9XG4gICAgaW5zZXJ0VGV4dChpbWcpe1xuICAgICAgICBsZXQgaW1nQ29udGVudCA9IF8oJ2ltZy1jb250ZW50JylcbiAgICAgICAgbGV0IHVybCA9IGltZy5hdHRyaWJ1dGVzWzJdLnZhbHVlXG4gICAgICAgIGxldCB0ZXh0ID0gaW1nLmF0dHJpYnV0ZXNbMV0udGV4dENvbnRlbnRcbiAgICAgICAgaW1nQ29udGVudC50ZXh0Q29udGVudCA9IHRleHRcbiAgICAgICAgaW1nQ29udGVudC5pbm5lckhUTUwgKz0gJzxicj4nKyc8YSBocmVmPVwiJyArIHVybCArICdcIj4gJyArIHVybCArICcgPC9hPicrJzwvYnI+J1xuICAgIH1cbiAgICBtb3ZlRWxlbWVudChlbCwgY2xzKXtcbiAgICAgICAgdGhpcy5pbWcgPSBlbCAvL3VwZGF0ZXMgaW1hZ2UgdG8gYmUgdXNlZCBlbHNld2hlcmUgXG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKVxuICAgICAgICBsZXQgaW1nX2NvbnRlbnQgPSBfKCdpbWctY29udGVudCcpXG4gICAgICAgIGxldCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZWwpXG4gICAgICAgIHRoaXMuaW1nV3JhcC5pbnNlcnRCZWZvcmUoZnJhZ21lbnQsIGltZ19jb250ZW50KTtcbiAgICAgICAgdGhpcy5pbWdXcmFwLmNsYXNzTGlzdC5hZGQoJ3Nob3ctaW1nJylcbiAgICAgICAgdGhpcy5pbWdXcmFwLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGUtaW1nJylcbiAgICB9XG5cbiAgICByZW1vdmVJbWcoZSl7XG4gICBcbiAgICAgICAgLy9Pbmx5IHJhbiB0byBleGl0IG91dCBvZiBpbWFnZSBmcm9tIGNsaWNrIGhhbmRsZXJcbiAgICAgICAgaWYoZSl7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gMFxuICAgICAgICAgICAgdGhpcy5pbWdXcmFwLmNsYXNzTGlzdC5yZXBsYWNlKCdzaG93LWltZycsICdoaWRlLWltZycpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbWdXcmFwLmNsYXNzTGlzdC5yZXBsYWNlKCdoaWRlLWltZycsICdzaG93LWltZycpXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpXG4gICAgICAgICAgICAgICAgdGhpcy5pbWcuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgfSwxMTAwKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXygnaW1nLWNvbnRlbnQnKS50ZXh0Q29udGVudCA9ICcnXG4gICAgICAgICAgICB0aGlzLmltZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuaW1nKVxuICAgICBcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmVzIGltYWdlcyBcbiAgICBpbWFnZUNsb3NlKGUpe1xuICAgICAgICB0aGlzLnJlbW92ZUNsaWNrTGlzdGVuZXIoKVxuICAgICAgICBpZihlLnRhcmdldC50YWdOYW1lICE9PSAnSU1HJyl7XG5cbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSW1nKGUpXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRGlzcGxheXMgaW1hZ2VcbiAgICBzaG93SW1hZ2UoY2xzc05hbWUpe1xuICAgICAgICB0aGlzLmltZyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xzc05hbWUpWzBdXG4gICAgICAgIHRoaXMuaW5zZXJ0VGV4dCh0aGlzLmltZylcbiAgICAgICAgdGhpcy5pbWcuc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgdGhpcy5hZGRDbGlja0xpc3RlbmVyKClcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdmbGV4J1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID0gMVxuICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gKiogIFJFTU9WRSBBTklNQVRFQ0xJUFBBVEggSUYgSSBET04nVCBSRUFMTExZIEhBVkUgVE8gVVNFIElUIEZPUiBGSVJFRk9YICoqXG4gICAgLy9GaXJlZm94IG9ubHlcbiAgICBhbmltYXRlQ2xpcFBhdGgodGltZXN0YW1wKXtcbiAgICAgICAgaWYoIXRoaXMuc3RhcnQpIHRoaXMuc3RhcnQgPSB0aW1lc3RhbXBcbiAgICAgICAgdGhpcy5ydW50aW1lID0gdGltZXN0YW1wIC0gdGhpcy5zdGFydDtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1pbih0aGlzLnJ1bnRpbWUgLyAxMDAwLCAxKVxuICAgICAgICB0aGlzLmltZ1dyYXAuc3R5bGUuY2xpcFBhdGggPSBgY2lyY2xlKCR7dGhpcy5jbGlwU3RhcnQgKyAodGhpcy5jbGlwVmFsdWUgKiBwcm9ncmVzcyl9JSlgXG4gICAgXG4gICAgICAgIGlmKHByb2dyZXNzIDwgMSl7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlQ2xpcFBhdGgpXG4gICAgICAgIH1lbHNlIHtcblxuICAgICAgICAgICAgaWYodGhpcy5jb250YWluZXIuc3R5bGUub3BhY2l0eSA9PSAwKXtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlcyBmbGV4IGFuZCBvcGFjaXR5LCBzZXRzIGJhY2sgdG8gZGlzcGxheSBub25lXG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpXG4gICAgICAgICAgICAgICAgLy8gdGhpcy5pbWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmltZylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSAwXG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VHJhbnNmb3JtKCl7XG4gICAgICAgIGxldCByZWdFeCA9IC9ec2NhbGUvZztcbiAgICAgICAgbGV0IHRyYW5zZm9ybSA9IHRoaXMuZ3JvdXAuc3R5bGUudHJhbnNmb3JtLnJlcGxhY2UoL14oXFx3KlxcKC0/XFxkKi5cXHcqXFwpKSguKikvaWcsIFwiJDFcIilcbiAgICAgICAgbGV0IGNoZWNrRm9yU2NhbGUgPSB0cmFuc2Zvcm0ubWF0Y2gocmVnRXgpXG4gICAgICAgIC8vU28gdHdvIHNjYWxlIHZhbHVlcyBkb24ndCBnZXQgYWRkZWQgdG8gZWxlbWVudCB3aGVuIHRyYW5zbGF0ZSBkb2Vzbid0IGV4aXN0XG4gICAgICAgIGlmKGNoZWNrRm9yU2NhbGUpe1xuICAgICAgICAgICAgcmV0dXJuICcnXG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNjYWxlUGhvdG8oZGlzdCwgc2NhbGUsIHRyYW5zbGF0ZSl7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzbGlkZXJfMV8nKS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWSgke2Rpc3R9cHgpYFxuICAgICAgICB0aGlzLmdyb3VwLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zbGF0ZSArIGBzY2FsZSggJHsxICsgc2NhbGV9IClgXG4gICAgfVxuICAgIFxuICAgIG1vdXNlTW92ZShlKXtcbiAgICAgICAgLy8gbXVsdGlweSBieSAxLjUgYmVjYXVzZSBvZiB0aGUgbGFnLCBzbyBJIHNwZWVkIGl0IHVwIGp1c3QgYSBiaXRcbiAgICAgICAgbGV0IGRpc3QgPSBlLmNsaWVudFkgLSB0aGlzLm1vdXNlWVxuICAgICAgICBsZXQgdmFsdWUgPSAgIGRpc3QgLyB0aGlzLllcbiAgICAgICAgbGV0IHNjYWxlID0gTWF0aC5taW4oIHZhbHVlIDwgMCA/IC12YWx1ZSA6IC12YWx1ZSwgMSlcbiAgICAgICAgbGV0IHRyYW5zbGF0ZSA9IHRoaXMuZ2V0VHJhbnNmb3JtKCkgXG4gICAgICAgIGxldCB0cmFuc2xhdGVWYWx1ZSA9ICsoIHRyYW5zbGF0ZS5yZXBsYWNlKC9bXi1cXGQuXS9pZywgXCJcIikgKVxuICBcbiAgICAgICAgLy9DaGVja3MgaWYgZWxlbWVudCBpcyBlaXRoZXIgLTQzMSBvciA0MzEgc28gdGhlIGNvcnJlY3QgdHJhbnNmb3JtIG9yaWdpbiBjYW4gYmUgYWRkZWRcbiAgICAgICAgaWYodHJhbnNsYXRlVmFsdWUgPiAyKXtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gMTY1ICsgXCJweCBcIiArIDQ1MCArIFwicHhcIlxuICAgICAgICB9ZWxzZSBpZih0cmFuc2xhdGVWYWx1ZSA8IC0xKXtcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gMTAzNCArIFwicHggXCIgKyA0NTggKyBcInB4XCJcbiAgICAgICAgfVxuICAgICAgICAvL3NjYWxlIGlzIDEgd2hlbiBjbGlja2VkIHNvbWV3aGVyZSBlbHNlXG4gICAgICAgIGlmKCBzY2FsZSA8IDEgJiYgZGlzdCA8PSA2ICkgdGhpcy5zY2FsZVBob3RvKGRpc3QsIHNjYWxlLCB0cmFuc2xhdGUpXG4gICAgfVxuXG4gICAgbW91c2VEb3duKGUpe1xuICAgICAgICBcbiAgICAgICAgXygnc2xpZGUtZ3JvdXAnKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5yZW1vdmVMaXN0ZW5lciwgdHJ1ZSlcblxuICAgICAgICB0aGlzLnRvZ2dsZU1vdmVFbGVtZW50ID0gdHJ1ZVxuICAgICAgICB0aGlzLnRhcmdldEVsZW0oKVxuICAgICAgICBsZXQgdmVyUGllY2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmVydF9waWVjZScpXG4gICAgICAgIGxldCB2ZXJ0WSA9IHZlclBpZWNlLmdldEJCb3goKS55XG4gICAgICAgIGxldCBoYW5kbGVZID0gXygnaW1nLXNjYWxlJykuZ2V0QkJveCgpLnkgICAgXG5cbiAgICAgICAgLy9HZXRzIGRpc3RhbmNlIHNsaWRlciBuZWVkcyB0byBnbyAgXG4gICAgICAgIHRoaXMuWSA9IGhhbmRsZVkgLSB2ZXJ0WVxuICAgICAgICBcbiAgICAgICAgLy9TdGFydCBwb3NpdGlvbiBmb3IgZGlzdGFuY2VcbiAgICAgICAgaWYoIXRoaXMubW91c2VZKSB0aGlzLm1vdXNlWSA9IGUuY2xpZW50WVxuICAgICAgICBfKCdzbGlkZS1ncm91cCcpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlLCB0cnVlKVxuICAgICAgIFxuICAgIH1cblxuICAgIHJlbW92ZUxpc3RlbmVyKGUpe1xuICAgICAgICBfKCdzbGlkZS1ncm91cCcpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMubW91c2VNb3ZlLCB0cnVlKVxuICAgICAgICBcbiAgICAgICAgbGV0IHRyYW5zbGF0ZSA9IHRoaXMuZ2V0VHJhbnNmb3JtKClcbiAgICAgICAgdGhpcy5zY2FsZVBob3RvKDAsMCx0cmFuc2xhdGUpXG4gICAgICAgIFxuICAgICAgICBfKCdzbGlkZS1ncm91cCcpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLnJlbW92ZUxpc3RlbmVyLCB0cnVlKVxuICAgICAgICBfKCdpbWctc2NhbGUnKS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlRG93biwgdHJ1ZSk7XG5cbiAgICAgICAgLy9VcGRhdGVzIHBvc2l0aW9uIHdoZW4gbW91c2VVcFxuICAgICAgICB0aGlzLm1vdXNlWSA9IDBcbiAgICAgICAgdGhpcy50b2dnbGVNb3ZlRWxlbWVudCA9IGZhbHNlXG4gICAgfVxufVxuXG5sZXQgcm9sbGVyVW5pdCA9IG5ldyBSb2xsZXJVbml0KCk7XG5sZXQgaW1nSW5sYXJnZSA9IG5ldyBJbkxhcmdlSW1nKCk7XG5yb2xsZXJVbml0LnBvc2l0aW9uRm9yaWVnbk9iamVjdChpbWdJbmxhcmdlKTtcblxuXygnaW1nLXNjYWxlJykuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGUpID0+IHtcbiAgICBcbiAgICBpbWdJbmxhcmdlLm1vdXNlRG93bihlKVxufSwgdHJ1ZSk7XG5cbl8oJ2J1dHRvbnMnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oZSl7XG4gICAgXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0LnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0WzBdXG5cbiAgICBpZih0YXJnZXQgPT09ICdpbWctbGVmdCcgfHwgdGFyZ2V0ID09PSAnaW1nLXJpZ2h0Jyl7XG4gICAgICAgIGlmKHJvbGxlclVuaXQuY2xpY2sgPT09IDEpIHJldHVybiAgXG4gICAgICAgIFxuICAgICAgICByb2xsZXJVbml0LmxlZnQgPSB0YXJnZXQgPT09ICdpbWctbGVmdCcgPyB0cnVlIDogZmFsc2VcbiAgICAgICAgcm9sbGVyVW5pdC5yaWdodCA9IHRhcmdldCA9PT0gJ2ltZy1yaWdodCcgPyB0cnVlIDogZmFsc2VcbiAgICAgICAgcm9sbGVyVW5pdC51cGRhdGVQb3MoKVxuXG4gICAgfWVsc2UgaWYodGFyZ2V0ID09PSAnaW1nLWlubGFyZ2UnKXtcbiAgICAgICAgaW1nSW5sYXJnZS5zaG93SW1hZ2UoJ3dlYlZpc2libGUnKVxuICAgIH1cbn0pO1xuXG5kb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYnV0dG9uLWlubGFyZ2UnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgaW1nSW5sYXJnZS5zaG93SW1hZ2UoJ2Rlc2lnblZpc2libGUnKVxufSlcblxuLy8gKioqKiBHUkFQSCBTRUNUSU9OICoqKipcblxuY29uc3QgcmFuZG9tID0gKG1pbiwgbWF4KSA9PiBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW47XG5cbmNvbnN0IHRvZ2dsZVJvYm90ID0ge1xuICAgIHRvZ2dsZTogZmFsc2UsXG4gICAgZmxpZ2h0OiBmYWxzZSwgLy9Ub2dnbGVzIHdoZW4gc2Nyb2xsZWQgb3V0IG9mIHNjcmVlbiB2aWV3XG4gICAgZGlyZWN0aW9uOiAndXAnXG59XG5cbmZ1bmN0aW9uIHN0YXJ0Um9ib3RGbGlnaHQoKXsgXG4gICAgLy8gKioqIEJ1cm5lcnMgKioqXG5cbiAgICBjb25zdCBmbGFtZXMgPSBfKCdyb2JvdC1mbGFtZScpXG4gICAgY29uc3QgbGVuZ3RoID0gZmxhbWVzLmxlbmd0aFxuXG4gICAgY29uc3QgZnJvbSA9IHt4OiAxLCB5OiAxfVxuICAgIGNvbnN0IHRvID0ge31cbiAgICBjb25zdCBkaXN0YW5jZSA9IHt9O1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhmcm9tKTtcblxuICAgIGNvbnN0IG5leHQgPSB0aW1lc3RhbXAgPT4ge1xuICAgICAgICAvL3N0YXJ0cyBhbGwgb3ZlciBmcm9tIGdldHMgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGxhc3Qgc2l6ZVxuICAgICAgICBPYmplY3QuYXNzaWduKGZyb20sIHRvKTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0ga2V5cy5sZW5ndGhcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGF4aXMgPSBrZXlzW2ldXG4gICAgICAgICAgICB0b1theGlzXSA9IHJhbmRvbSguOCwgMSk7XG4gICAgICAgICAgICBkaXN0YW5jZVtheGlzXSA9IGZyb21bYXhpc10gLSB0b1theGlzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRpbWUuc3RhcnQgPSB0aW1lc3RhbXA7XG4gICAgfTtcblxuICAgIGNvbnN0IHRpbWUgPSB7XG4gICAgICAgIHRvdGFsOiA0MFxuICAgIH07XG5cbiAgICBjb25zdCBkcmF3QnVybmVycyA9IHRpbWVzdGFtcCA9PiB7XG4gICAgICAgIGlmICh0b2dnbGVSb2JvdC5mbGlnaHQpIHJldHVyblxuICAgICAgICBpZiAodGltZS5ydW50aW1lID4gdGltZS50b3RhbCB8fCAhdG8ueCkgbmV4dCh0aW1lc3RhbXApO1xuXG4gICAgICAgIHRpbWUucnVudGltZSA9IHRpbWVzdGFtcCAtIHRpbWUuc3RhcnQ7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gdGltZS5ydW50aW1lIC8gdGltZS50b3RhbDtcbiAgICAgICAgY29uc3QgW3gsIHldID0ga2V5cy5tYXAoYXhpcyA9PiBmcm9tW2F4aXNdIC0gcHJvZ3Jlc3MgKiBkaXN0YW5jZVtheGlzXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBmbGFtZSA9IGZsYW1lc1tpXVxuICAgICAgICAgICAgZmxhbWUuc3R5bGUudHJhbnNmb3JtID0gYHNjYWxlKCR7eH0sICR7eX0pYDtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhd0J1cm5lcnMpO1xuICAgIH07XG5cblxuICAgIC8vKioqIERyYXdzIFN0YXJzICoqKlxuICAgIGxldCBncmFwaHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdncmFwaC1zdDIwJylcbiAgICBjb25zdCByZWNDbGlwID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgncmVjLWNsaXAnKVswXVxuICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGNvbnN0IHJvYm90UmVjdCA9IF8oJ2Zsb2F0aW5nX3JvYm90JykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCBncmFwaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdncmFwaC1zdmcnKVxuICAgIGNvbnN0IFtzaXplXSA9IC9bMS05XS4qLy5leGVjKCBncmFwaC5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKSApXG4gICAgXG4gICAgY29uc3QgcmVnRXggPSAvKFsxLTkuXSopXFxzKFsxLTkuXS4qKS9pZztcbiAgICBjb25zdCBncmFwaFdpZHRoID0gc2l6ZS5yZXBsYWNlKHJlZ0V4LCAnJDEnKVxuICAgIGNvbnN0IGdyYXBoSGVpZ2h0ID0gc2l6ZS5yZXBsYWNlKHJlZ0V4LCAnJDInKVxuICAgIFxuICAgIGNvbnN0IHJvYm90SGVpZ2h0ID0gcm9ib3RSZWN0LmhlaWdodDtcbiAgICBjb25zdCByb2JvdFdpZHRoID0gcm9ib3RSZWN0LndpZHRoO1xuICAgIGNvbnN0IHN0YXJ0WSA9IGdyYXBoSGVpZ2h0IC0gcm9ib3RIZWlnaHRcbiAgICBjb25zdCBzdGFydFggPSByb2JvdFJlY3QueCAtICh3aW5kb3cuaW5uZXJXaWR0aCAtIGdyYXBoV2lkdGgpIC8gMlxuXG4gICAgLy9zdGFydHMgc3RhcnMgcmFuZG9tbHlcbiAgICBjb25zdCByYW5kb21JbnRlcnZhbCA9IGZ1bmN0aW9uKGNhbGxiYWNrLGRhdGEsbWluLCBtYXgpe1xuXG4gICAgICAgIGNvbnN0IHRpbWUgPSB7XG4gICAgICAgICAgICBzdGFydDogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgICB0b3RhbDogcmFuZG9tKG1pbiwgbWF4KVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBkcmF3ID0gKHRpbWVzdGFtcCkgPT57XG4gICAgICAgICAgICBpZih0b2dnbGVSb2JvdC5mbGlnaHQpIHJldHVyblxuICAgICAgICAgICAgaWYgKHRpbWUudG90YWwgPD0gdGltZXN0YW1wIC0gdGltZS5zdGFydCkge1xuICAgICAgICAgICAgICAgIHRpbWUuc3RhcnQgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgdGltZS50b3RhbCA9IHJhbmRvbShtaW4sIG1heCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZGF0YSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3KTtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhdyk7XG4gICAgfTtcblxuICAgIGNvbnN0IGNyZWF0ZVN0YXIgPSAoY3gsIGN5LCByYWRpdXMpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsIFwiY2lyY2xlXCIpO1xuICAgICAgICBzdGFyLnNldEF0dHJpYnV0ZShcInJcIiwgcmFkaXVzKTtcbiAgICAgICAgc3Rhci5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBjeSk7XG4gICAgICAgIHN0YXIuc2V0QXR0cmlidXRlKFwiY3hcIiwgY3gpO1xuICAgICAgICBzdGFyLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ3aGl0ZVwiKTtcbiAgICAgICAgc3Rhci5zZXRBdHRyaWJ1dGUoXCJmaWxsLW9wYWNpdHlcIiwgMCk7XG4gICAgICAgIHJldHVybiBzdGFyO1xuICAgIH07XG5cbiAgICBjb25zdCBGYWxsaW5nU3RhcnMgPSBmdW5jdGlvbihkYXRhKXtcblxuICAgICAgICBsZXQgYXR0ciA9IG5ldyBkYXRhKHRvZ2dsZVJvYm90LmRpcmVjdGlvbilcblxuICAgICAgICBjb25zdCByYWRpdXMgPSBhdHRyLnJhZGl1c1xuICAgICAgICBjb25zdCBjeCA9IGF0dHIuY3hcbiAgICAgICAgY29uc3QgY3kgPSBhdHRyLmN5XG4gICAgICAgIGNvbnN0IGRpc3QgPSBhdHRyLmRpc3RcbiAgICAgICAgY29uc3Qgc3RhciA9IGNyZWF0ZVN0YXIoY3gsIGN5LCByYWRpdXMpXG4gICAgICAgXG4gICAgICAgIGNvbnN0IHRpbWUgPSB7XG4gICAgICAgICAgICBzdGFydDogcGVyZm9ybWFuY2Uubm93KCksXG4gICAgICAgICAgICB0b3RhbDogcmFuZG9tKDE5MDAsIDIwMDApXG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjb25zdCBkcmF3ID0gKHRpbWVzdGFtcCkgPT4ge1xuICAgICAgICAgIGlmKHRvZ2dsZVJvYm90LnRvZ2dsZSB8fCB0b2dnbGVSb2JvdC5mbGlnaHQpe1xuICAgICAgICAgICAgICAgIGdyYXBoLnJlbW92ZUNoaWxkKHN0YXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIHRpbWUuZWxhcHNlZCA9IHRpbWVzdGFtcCAtIHRpbWUuc3RhcnRcbiAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4odGltZS5lbGFwc2VkIC8gdGltZS50b3RhbCwgMSlcbiAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IG9wYWNpdHkgPSBwcm9ncmVzcyAqIDJcblxuICAgICAgICAgICAgc3Rhci5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBjeSArIHByb2dyZXNzICogZGlzdClcbiAgICAgICAgICAgIHN0YXIuc2V0QXR0cmlidXRlKFwiZmlsbC1vcGFjaXR5XCIsIHByb2dyZXNzIDwgLjUgPyBvcGFjaXR5IDogMiAtIG9wYWNpdHkpXG4gICAgICAgICAgICB0aW1lLmVsYXBzZWQgPCB0aW1lLnRvdGFsID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXcpOiBncmFwaC5yZW1vdmVDaGlsZChzdGFyKVxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3KVxuXG4gICAgICAgIC8vSW5zZXJ0cyBuZXcgc3RhciBiYXNlZCBvbiByYW5kb21JbnRlcnZhbCBydW5pbmcgdGhyb3VnaFN0YXJzKClcbiAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoc3RhcilcbiAgICAgICAgZ3JhcGguaW5zZXJ0QmVmb3JlKGZyYWdtZW50LCBncmFwaC5maXJzdENoaWxkKVxuXG4gICAgfTtcblxuICAgIHZhciBmbHlJbnRvUGxhY2UgPSB7XG4gICAgICAgIGJlZ2luWTogZ3JhcGhIZWlnaHQgLSByb2JvdEhlaWdodCAvIDEyLFxuICAgICAgICBoaWRkZW5YOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgbGV0IGRpZmZlcmVuY2UgPSBncmFwaFdpZHRoICAtICB3V1xuICAgICAgICAgICAgaWYoIXdXIDwgZ3JhcGhXaWR0aCl7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcm9ib3RSZWN0LndpZHRoICsgcm9ib3RSZWN0LnggKyBkaWZmZXJlbmNlIFxuICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGhpZGVSb2JvdDogZnVuY3Rpb24oc2l6ZSl7XG4gICAgICAgICAgICBpZiggc2l6ZSA9PT0gMS4zKXtcbiAgICAgICAgICAgICAgICBsZXQgYmVnaW5YID0gdGhpcy5oaWRkZW5YKCk7XG4gICAgICAgICAgICAgICAgXygnZmxvYXRpbmdfcm9ib3QnKS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7MH1weCwgLSR7dGhpcy5iZWdpbll9cHgpYFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVTdGFyczogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGxldCBhdHRyaWJ1dGVzID0gZnVuY3Rpb24oZGlyZWN0aW9uKXtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKGRpcmVjdGlvbiA9PT0gJ2Rvd24nKXtcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB0b2dnbGVSb2JvdC50b2dnbGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJhZGl1cyA9IHJhbmRvbSguNSwgMi43KVxuICAgICAgICAgICAgICAgICAgICBsZXQgY3ggPSByYW5kb20oc3RhcnRYIC0gMTAwLCBzdGFydFggKyByb2JvdFdpZHRoICsgMTAwKVxuICAgICAgICAgICAgICAgICAgICBsZXQgY3kgPSByYW5kb20oc3RhcnRZIC0gMTIwICxzdGFydFkgLSAxNzUgKVxuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IDEwMCArIHJvYm90SGVpZ2h0O1xuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJhZGl1cywgY3gsIGN5LCBkaXN0IH0gXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKGRpcmVjdGlvbiA9PT0gJ3VwJyl7XG4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGxldCByYWRpdXMgPSByYW5kb20oMS41LCAzLjcpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3ggPSByYW5kb20oMCAtIDI1LCBncmFwaFdpZHRoICsgMjUpXG4gICAgICAgICAgICAgICAgICAgIGxldCBjeSA9IHJhbmRvbShncmFwaEhlaWdodCAgLSA4MCwgZ3JhcGhIZWlnaHQgKyA1MCAgKVxuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IC1ncmFwaEhlaWdodDsgXG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcmFkaXVzLCBjeCwgY3ksIGRpc3QgfSBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL0V2ZXJ5IDgwbXMgdGhyb3VnaCAxODBtcyBvZiB0aW1lLnRvdGFsIGl0IHdpbGwgZHJhdyBhIHN0YXJcbiAgICAgICAgICAgIC8vKioqKiBTVEFSVFMgU1RBUlMgTU9WSU5HICoqKioqXG4gICAgICAgICAgICByYW5kb21JbnRlcnZhbChGYWxsaW5nU3RhcnMsIGF0dHJpYnV0ZXMsODAsIDE4MClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGdyYXBoRGF0YSA9IHtcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIHRvdGFsOiAyMDAwLFxuICAgIH1cbiAgICBjb25zdCBzdWJ0cmFjdFJheSA9ICgpID0+IHtcbiAgICAgICAgXygnbGVmdC10ZXh0LXBhbmVsJykucmVtb3ZlQXR0cmlidXRlKCdjbGlwLXBhdGgnKVxuICAgICAgICBfKCdyZWMtY2xpcCcpLnN0eWxlLnRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKDQ4NXB4LCA1MjBweClcIlxuICAgIH1cbiAgICBjb25zdCBnZXRTdHJva2VMZW5ndGggPSAoKSA9PiB7XG4gICAgICAgIGxldCBpID0gZ3JhcGhzLmxlbmd0aFxuICAgICAgICBsZXQgdmFsdWUgPSBuZXcgQXJyYXkoaSlcbiAgICAgICAgZnVuY3Rpb24gZ2V0TGVuZ3RoKCl7XG4gICAgICAgICAgICB3aGlsZShpLS0pe1xuICAgICAgICAgICAgICAgIHZhbHVlW2ldID0gZ3JhcGhzW2ldLmdldFRvdGFsTGVuZ3RoKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcnVuVmFsdWU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgZ2V0TGVuZ3RoKClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRWYWx1ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3Ryb2tlTGVuZ3RoID0gZ2V0U3Ryb2tlTGVuZ3RoKCk7XG4gICAgc3Ryb2tlTGVuZ3RoLnJ1blZhbHVlKCk7XG4gICAgXG4gICAgY29uc3QgZHJhd1BlcmNlbnRTdHJva2UgPSAocHJvZ3Jlc3MpID0+IHtcbiAgICAgICAgbGV0IHN0cm9rZSA9IHN0cm9rZUxlbmd0aC5nZXRWYWx1ZSgpXG4gICAgICAgIGxldCBpID0gZ3JhcGhzLmxlbmd0aFxuICAgICAgICB3aGlsZShpLS0pe1xuICAgICAgICAgICAgZ3JhcGhzW2ldLnN0eWxlLnN0cm9rZSA9ICd1cmwoI2Rlc2lnbi1ncmFkaWVudCknXG4gIFxuICAgICAgICAgICAgZ3JhcGhzWzBdLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSBzdHJva2VbMF0gKyAoc3Ryb2tlWzBdICogcHJvZ3Jlc3MpXG4gICAgICAgICAgICBncmFwaHNbMV0uc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IHN0cm9rZVsxXSAtIChzdHJva2VbMV0gKiBwcm9ncmVzcylcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhbmltYXRlR3JhcGggPSAodGltZXN0YW1wKSA9PiB7XG4gICAgICAgIGlmKCFncmFwaERhdGEuc3RhcnQpIGdyYXBoRGF0YS5zdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICBsZXQgcnVudGltZSA9IHRpbWVzdGFtcCAtIGdyYXBoRGF0YS5zdGFydFxuICAgICAgICBsZXQgcHJvZ3Jlc3MgPSBNYXRoLm1pbihydW50aW1lIC8gZ3JhcGhEYXRhLnRvdGFsLCAxKVxuXG4gICAgICAgIF8oJ2dyYXBoLXBlcmNlbnRhZ2UtdG9wJykudGV4dENvbnRlbnQgPSBNYXRoLnJvdW5kKCAwICsgOTAgKiBwcm9ncmVzcykgKyAnICUnXG4gICAgICAgIF8oJ2dyYXBoLXBlcmNlbnRhZ2UtYm90dG9tJykudGV4dENvbnRlbnQgPSBNYXRoLnJvdW5kKCAwICsgNzAgKiBwcm9ncmVzcykgKyAnICUnXG4gICAgICAgIF8oJ2dyYXBoLXJlY3QnKS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyAoNDEyICogcHJvZ3Jlc3MpICsgJ3B4KScgXG4gICAgICAgIGRyYXdQZXJjZW50U3Ryb2tlKHByb2dyZXNzKVxuICAgICAgICBcbiAgICAgICAgaWYocHJvZ3Jlc3MgPCAxKSBcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlR3JhcGgpXG4gICAgICAgIGVsc2UgXG4gICAgICAgICAgICByZXR1cm4gc3VidHJhY3RSYXkoKVxuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0QW5pbWF0ZUdyYXBoID0gKCkgPT57XG4gICAgICAgIHJlY0NsaXAuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwcHgsIDBweCknXG4gICAgICAgIF8oJ2dyYXBoLWNsaXBwaW5nJykuY2xhc3NMaXN0LmFkZCgnc2hvdy1ncmFwaHMnKVxuXG4gICAgICAgIC8vQW5pbWF0ZSBncmFwaHMgYWZ0ZXIgcmVjQ2xpcCB0cmFuc2Zvcm0gaXMgZG9uZVxuICAgICAgICBzZXRUaW1lb3V0KCAoKSA9PiB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZUdyYXBoKVxuICAgICAgICB9LCAyNTAwKVxuICAgICAgIFxuICAgIH1cblxuICAgIGNvbnN0IGJlZ2luID0ge1xuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgdG90YWw6IDQwMDBcbiAgICB9XG5cbiAgICBjb25zdCBmbHlJbiA9ICh0aW1lc3RhbXApID0+e1xuICAgICAgICBpZighYmVnaW4uc3RhcnQpIGJlZ2luLnN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgIGJlZ2luLnJ1bnRpbWUgPSB0aW1lc3RhbXAgLSBiZWdpbi5zdGFydFxuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWluKGJlZ2luLnJ1bnRpbWUgLyBiZWdpbi50b3RhbCwgMSlcbiAgICAgICAgY29uc3QgY3VydmUgPSA2MjQuOSAvIDJcbiAgICAgICAgY29uc3QgZWFzZSA9IGVhc2VPdXQocHJvZ3Jlc3MpXG4gICAgICAgIGNvbnN0IGluY3JlbWVudCA9IGN1cnZlICogcHJvZ3Jlc3MgLyA1MFxuICAgIFxuICAgICAgICBjb25zdCB5ID0gLWZseUludG9QbGFjZS5iZWdpblkgKyBmbHlJbnRvUGxhY2UuYmVnaW5ZICogcHJvZ3Jlc3NcbiAgICAgICAgY29uc3QgeCA9IC1NYXRoLmNvcyggaW5jcmVtZW50ICsgTWF0aC5QSS8xODApICogY3VydmUgKyBjdXJ2ZSBcbiAgICAgICAgLy8gIWJlZ2luLnRvZ2dsZVxuICAgICAgICAgXygnZmxvYXRpbmdfcm9ib3QnKS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7LXh9cHgsICR7eX1weClgXG4gICAgICAgIC8vIDogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI3NlY3Rpb24tZml2ZS13ZWIgLmNvbnRhaW5lci1sZycpLnN0eWxlLnRyYW5zZm9ybSA9IGBzY2FsZSgkezEuMyAtIC4zICogZWFzZX0pYFxuXG4gICAgICAgIGlmKHByb2dyZXNzID09PSAxKXtcbiAgICAgICAgICAgIC8vIHRvZ2dsZVJvYm90LnRvZ2dsZSA9IHRydWU7XG4gICAgICAgICAgICB0b2dnbGVSb2JvdC5kaXJlY3Rpb24gPSAnZG93bidcbiAgICAgICAgXG4gICAgICAgICAgICAvL1Jlc2l6ZXMgdGhlIHdob2xlIGNvbnRhaW5lciBzbyByb2JvdCBmaXRzIGludG8gc2NyZWVuXG4gICAgICAgICAgICBpZiggd1cgPiAxMDUwICl7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChzdGFydEFuaW1hdGVHcmFwaCwgNjAwKVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzZWN0aW9uLWZpdmUtd2ViIC5jb250YWluZXItbGcnKS5jbGFzc0xpc3QuYWRkKCdzY2FsZS1jb250YWluZXInKVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3RhcnRBbmltYXRlR3JhcGgoKVxuICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmbHlJbilcbiAgICB9XG4gICAgcmV0dXJuIHtmbHlJbiwgZmx5SW50b1BsYWNlLCBkcmF3QnVybmVyc31cbn1cblxubGV0IG5hdlRvZ2dsZSA9IHtcbiAgICB0b2dnbGU6IHRydWVcbn1cblxuY2xhc3MgTmF2aWdhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5uYXZJdGVtcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5uYXYtbGlzdCBidXR0b24nKVxuICAgICAgICB0aGlzLnNjcm9sbFRvID0gdGhpcy5zY3JvbGxUby5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMuYW5pbWF0ZVNjcm9sbCA9IHRoaXMuYW5pbWF0ZVNjcm9sbC5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMuc3RhcnQgPSAwXG4gICAgfVxuICAgIGdldERpc3RhbmNlKGVsKXtcbiAgICAgXG4gICAgICAgIGxldCB0b3AgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3BcbiAgICAgICAgbGV0IGhlaWdodCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICAgICAgICBsZXQgYm90dG9tID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tXG4gICAgICAgIHJldHVybiB7dG9wLCBoZWlnaHQsIGJvdHRvbX1cbiAgICB9XG4gICAgZ2V0U2Nyb2xsdG9FbGVtZW50KHRhcmdldCwgcmVnRXgpe1xuICAgICAgICBsZXQgc2VjdGlvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzZWN0aW9uJylcbiAgICAgICAgbGV0IGxlbmd0aCA9IHNlY3Rpb24ubGVuZ3RoXG4gICAgICAgIHdoaWxlKGxlbmd0aC0tKXtcbiAgICAgICAgICAgIGlmICggdGFyZ2V0ID09PSBzZWN0aW9uW2xlbmd0aF0uaWQucmVwbGFjZShyZWdFeCwgXCIkMVwiKSApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlbDogc2VjdGlvbltsZW5ndGhdLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogbGVuZ3RoXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG91dEV4cG8obil7XG4gICAgICAgIHJldHVybiAxID09IG4gPyBuIDogMSAtIE1hdGgucG93KDIsIC0xMCAqIG4pO1xuICAgIH07XG5cbiAgICBhbmltYXRlU2Nyb2xsKHRpbWVzdGFtcCl7XG4gICAgICAgIGlmKCF0aGlzLnN0YXJ0KSB0aGlzLnN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgIGxldCBydW50aW1lID0gIHRpbWVzdGFtcCAtIHRoaXMuc3RhcnRcbiAgICAgICAgbGV0IHByb2dyZXNzID0gdGhpcy5vdXRFeHBvKCBNYXRoLm1pbiggcnVudGltZSAvIDEyMDAsIDEgKSApXG4gICAgICAgIGxldCB5ID0gdGhpcy5zdGFydFBvcyArICh0aGlzLmVsRGlzdCAqIHByb2dyZXNzKVxuICAgICAgIFxuICAgICAgICB3aW5kb3cuc2Nyb2xsKDAsIHkpXG4gICAgICAgIGlmKHByb2dyZXNzIDwgMSl7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlU2Nyb2xsKVxuICAgICAgICB9ZWxzZSByZXR1cm4gbmF2VG9nZ2xlLnRvZ2dsZSA9IHRydWVcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgfVxuXG4gICAgdG9nZ2xlT3BlbkJ0bigpe1xuICAgICAgICBsZXQgaSA9IHRoaXMubmF2SXRlbXMubGVuZ3RoXG4gICAgICAgIHdoaWxlKGktLSl7XG4gICAgICAgICAgXG4gICAgICAgICAgICBpZih0aGlzLm5hdkl0ZW1zW2ldLnN0eWxlLnRyYW5zZm9ybSl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2codGhpcy5uYXZJdGVtc1tpXS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJykpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgc2Nyb2xsVG8oZSl7XG4gICAgICAgIHRoaXMudG9nZ2xlT3BlbkJ0bigpXG4gICAgICAgIGlmKGUudGFyZ2V0LmNsYXNzTmFtZSA9PT0gJ2NvbnRhY3QtbW9kYWwnKSByZXR1cm5cbiAgICAgICAgY29uc3QgcmVnRXggPSAvKFxcdytcXC1cXHcrKVxcLVxcdysvaWdcbiAgICAgICAgY29uc3Qgc2VjdGlvbklkID0gZS50YXJnZXQuY2xhc3NOYW1lLnJlcGxhY2UocmVnRXgsXCIkMVwiKVxuXG4gICAgICAgIGxldCBzY3JvbGxUb0VsZW0gPSB0aGlzLmdldFNjcm9sbHRvRWxlbWVudChzZWN0aW9uSWQscmVnRXgpLmVsXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuZ2V0U2Nyb2xsdG9FbGVtZW50KHNlY3Rpb25JZCxyZWdFeCkuaW5kZXhcbiAgICAgICAgbGV0IGVsRGlzdCA9IHRoaXMuZ2V0RGlzdGFuY2Uoc2Nyb2xsVG9FbGVtLCBpbmRleCkudG9wXG4gICAgICAgIHRoaXMuZWxEaXN0ID0gZWxEaXN0XG4gICAgICAgIHRoaXMuc3RhcnRQb3MgPSB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICAgICAgdGhpcy5zdGFydCA9IDBcbiAgICAgICAgXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGVTY3JvbGwpXG4gICAgfVxuICAgIHNjcm9sbFRvNzY4KGUpe1xuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGxldCB0YXJnZXRCdG4gPSBlLnRhcmdldC5wYXJlbnROb2RlLnBhcmVudE5vZGVcbiAgICAgICAgY29uc29sZS5sb2codGFyZ2V0QnRuKVxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgIGlmKHRhcmdldEJ0bi5oYXNBdHRyaWJ1dGUoJ3N0eWxlJykpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9nZ2xlT3BlbkJ0bigpXG4gICAgICAgIH0gXG4gICAgICAgIHRoaXMudG9nZ2xlT3BlbkJ0bigpXG4gICAgICAgIHRhcmdldEJ0bi5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nXG4gICAgICAgIHRhcmdldEJ0bi5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlWCgkey0xMzB9cHgpYFxuICAgXG4gICAgfVxuXG4gICAgY29udHJvbGxlcigpe1xuICAgICAgICBfKCduYXYtbGlzdCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudGFyZ2V0KVxuICAgICAgICAgICAgbmF2VG9nZ2xlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICBpZiggZS50YXJnZXQubm9kZU5hbWUgPT09IFwiQlVUVE9OXCIpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUbyhlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSBAIHNjcmVlbiBzaXplIDc2OCBhbmQgc21hbGxlclxuICAgICAgICAgICAgaWYoZS50YXJnZXQucGFyZW50Tm9kZS5jbGFzc0xpc3RbMV0gPT09ICduYXYtaWNvbicpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG83NjgoZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuY29uc3QgbmF2aWdhdGlvbiA9IG5ldyBOYXZpZ2F0aW9uKClcbm5hdmlnYXRpb24uY29udHJvbGxlcigpXG5cbmNvbnN0IHRvZ2dsZUFuaW1hdGUgPSB7XG4gICAgc3RhcnM6IHRydWUsXG4gICAgZmxpZ2h0U3RhcnM6IHRydWUsXG4gICAgY2lyY3VpdDogdHJ1ZVxufVxuLy8gY2lyY3VpdFRvZ2dsZS50b2dnbGVBbmltID0gZmFsc2VcbmNvbnN0IHJvYm90ID0gbmV3IHJvYm90U2VjdGlvbignZXZlbnQnKTtcbmNvbnN0IHJvYm90RmxpZ2h0ID0gc3RhcnRSb2JvdEZsaWdodCgpO1xuXG5cbmNvbnN0IHRyaWdnZXJTdGFycyA9IChlKSA9PiB7XG4gICAgY29uc29sZS5sb2coZS50eXBlKVxuICAgIHZhciB1cGRhdGUgPSByb2JvdFsxXShlKS51cGRhdGVcbiAgICB2YXIgc3Rhcl9jb3VudCA9IDI1XG4gICAgdmFyIG1ha2VTdGFycyA9IHJvYm90WzFdKClcbiAgICBtYWtlU3RhcnMuY3JlYXRlU3RhcnMoc3Rhcl9jb3VudCwgdXBkYXRlKVxufVxuXG5jbGFzcyBTY3JvbGxBbmltYXRlIGV4dGVuZHMgTmF2aWdhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKVxuICAgICAgICB0aGlzLnNlY3Rpb25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnNlY3Rpb24tdGhyZWUtcm9ib3QsICNzZWN0aW9uLWZpdmUtd2ViLCAjc2VjdGlvbi1vbmUtZGlnaXRhbCwgI3NlY3Rpb24tdHdvLXBvcHVwcycpXG4gICAgfVxuICAgIGNoZWNrRWxlbVRvcChlKXtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHRoaXMuc2VjdGlvbnMubGVuZ3RoXG4gICAgICAgXG4gICAgICAgIHdoaWxlKGxlbmd0aC0tKXtcbiAgICAgICAgICAgIGxldCBkaXN0ID0gdGhpcy5nZXREaXN0YW5jZSh0aGlzLnNlY3Rpb25zW2xlbmd0aF0pXG4gICAgICAgICAgICBsZXQgZWxtVG9wID0gZGlzdC50b3BcbiAgICAgICAgICAgIGxldCBlbG1IZWlnaHQgPSBkaXN0LmhlaWdodFxuICAgICAgICAgICAgbGV0IGVsbUJvdHRvbSA9IGRpc3QuYm90dG9tXG5cbiAgICAgICAgICAgIC8vRGlnaXRhbCBIYW5kXG4gICAgICAgICAgICBpZihsZW5ndGggPT09IDApe1xuXG4gICAgICAgICAgICAgICAgaWYoZWxtQm90dG9tIDwgMTAwKXRvZ2dsZUFuaW1hdGUuY2lyY3VpdCA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL01hcFxuICAgICAgICAgICAgaWYobGVuZ3RoID09PSAxKXtcbiAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJMb2NhdGlvbiA9IF8oJ292YWwtcG9pbnRlcicpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnhcblxuICAgICAgICAgICAgICAgLy9TdG9wcyBzY3JvbGwgZnJvbSBydW5uaW5nIGhvdmVybWFwIGZ1bmN0aW9uIG92ZXIgYW5kIG92ZXJcbiAgICAgICAgICAgICAgIGlmKHBvaW50ZXJMb2NhdGlvbiA+IDApe1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBob3Zlcm1hcCA9IGhvdmVyTWFwKClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzdCA9IGhvdmVybWFwWzFdKGUpWzBdOyAvLyBQb3NpdGlvbiBkaXN0YW5jZSBvZiBzaG93LWljb24gZ29vZXlcbiAgICAgICAgICAgICAgICAgICAgaG92ZXJtYXBbMF0oIGRpc3QsIHRydWUgKSAgLy8gaGFuZGxlcihlKSBmdW5jdGlvbiByZW1vdmUgZ29vZXlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSb2JvdCBEZXNpZ24gc3RhcnMgZWxlbWVudFxuICAgICAgICAgICAgaWYobGVuZ3RoID09PSAyKSB7XG4gIFxuICAgICAgICAgICAgICAgIC8vUGFnZSBpbiB2aWV3IHN0YXJ0IGFuaW1hdGUgc3RhcnNcbiAgICAgICAgICAgICAgICBpZihlbG1Ub3AgPD0gZWxtSGVpZ2h0ICYmIGVsbUJvdHRvbSA+PSBlbG1IZWlnaHQgJiYgdG9nZ2xlQW5pbWF0ZS5zdGFycyl7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB0b2dnbGVBbmltYXRlLnN0YXJzID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlU3RhcnMudG9nZ2xlID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlclN0YXJzKGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vUGFnZSBvdXQgb2YgdmlldyBzdGFydCBzdG9wIGFuaW1hdGVcbiAgICAgICAgICAgICAgICBpZiggIXRvZ2dsZUFuaW1hdGUuc3RhcnMgICYmICAoZWxtVG9wID4gZWxtSGVpZ2h0IHx8IGVsbUJvdHRvbSA8PSAwKSApe1xuICAgICAgICAgICAgICAgICAgICB0b2dnbGVBbmltYXRlLnN0YXJzID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB0b2dnbGVTdGFycy50b2dnbGUgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9GbHlpbmcgUm9ib3QgLyBHcmFwaCBlbGVtZW50XG4gICAgICAgICAgICBpZihsZW5ndGggPT09IDMpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKGVsbVRvcCA8IGVsbUhlaWdodCAvIDIgJiYgZWxtQm90dG9tID49IGVsbUhlaWdodCAmJiB0b2dnbGVBbmltYXRlLmZsaWdodFN0YXJzKXtcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlUm9ib3QuZmxpZ2h0ID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQW5pbWF0ZS5mbGlnaHRTdGFycyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSggcm9ib3RGbGlnaHQuZHJhd0J1cm5lcnMgKVxuICAgICAgICAgICAgICAgICAgICByb2JvdEZsaWdodC5mbHlJbnRvUGxhY2UuY3JlYXRlU3RhcnMoJ3VwJylcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJvYm90RmxpZ2h0LmZseUluKVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKCAhdG9nZ2xlQW5pbWF0ZS5mbGlnaHRTdGFycyAgJiYgIChlbG1Ub3AgPiBlbG1IZWlnaHQgLSA3NSB8fCBlbG1Cb3R0b20gPD0gMCkgKXtcblxuICAgICAgICAgICAgICAgICAgICAvL1JlbW92ZXMgcmF5XG4gICAgICAgICAgICAgICAgICAgIF8oJ3JlYy1jbGlwJykuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZUFuaW1hdGUuZmxpZ2h0U3RhcnMgPSB0cnVlXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZVJvYm90LmZsaWdodCA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IFxuICAgICAgICB9XG4gICAgfVxuXG4gICBcbiAgICBzY3JvbGwoKXtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIChlKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiBuYXYgaXRlbSBpcyBjbGlja2VkIHRoYXQgc2Nyb2xsIGV2ZW50IHdpbGwgcnVuIGFuZCBub3QgdHJpZ2dlciB0aGlzIHNjcm9sbCBldmVudFxuICAgICAgICAgICAgaWYobmF2VG9nZ2xlLnRvZ2dsZSl7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrRWxlbVRvcChlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICBcbiAgICAgICAgfSlcbiAgICB9XG59XG5jb25zdCBzY3JvbGxBbmltYXRlID0gbmV3IFNjcm9sbEFuaW1hdGUoKVxuc2Nyb2xsQW5pbWF0ZS5zY3JvbGwoKVxuXG4vLyoqKiBIQU5EIFNIQUtFICoqKlxuY2xhc3MgRGlnaXRhbCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5wYXRoID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnN0cm9rZScpXG4gICAgICAgIHRoaXMud2F0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncm90YXRlX3dhdGNoJylcbiAgICB9XG5cbiAgICBzdGFydEhhbmRBbmltYXRpb24oKXtcblxuICAgICAgICB0aGlzLndhdGNoLmNsYXNzTGlzdC5hZGQoJ3JvdGF0ZVdhdGNoJylcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnBhdGhbaV0uZ2V0VG90YWxMZW5ndGgoKSlcbiAgICAgICAgICAgICB0aGlzLnBhdGhbaV0uY2xhc3NMaXN0LmFkZCgncGF0aCcpXG4gICAgICAgIH1cbiAgICAgICAgLy9SZW1vdmVzIGFuaW1hdGlvbiBhZnRlciA0IGludGVydmFscyBcbiAgICAgICAgc2V0VGltZW91dCggKCk9PiB7IHRoaXMucmVtb3ZlRGlnaXRhbEFuaW1hdGlvbigpfSw4MTAwKVxuICAgIH1cbiAgICByZW1vdmVEaWdpdGFsQW5pbWF0aW9uKCl7XG4gICAgICAgIHRoaXMud2F0Y2guY2xhc3NMaXN0LnJlbW92ZSgncm90YXRlV2F0Y2gnKVxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHRoaXMucGF0aFtpXS5jbGFzc0xpc3QucmVtb3ZlKCdwYXRoJylcbiAgICAgICAgfSBcbiAgICB9XG59XG5cbmNvbnN0IGNpcmN1aXRUb2dnbGUgPSB7XG4gICAgdG9nZ2xlQW5pbTogdHJ1ZVxufVxuXG5jbGFzcyBDaXJjdWl0IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLmFuaW1DaXJjdWl0ID0gXygnYW5pbWF0ZS1jaXJjdWl0JylcbiAgICAgICAgdGhpcy5zdGFydEFuaW1hdGlvbiA9IHRoaXMuc3RhcnRBbmltYXRpb24uYmluZCh0aGlzKVxuICAgICAgICB0aGlzLnNwZWVkID0gW11cbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IFtdXG4gICAgICAgIHRoaXMuaW5kZXggPSBbXVxuICAgICAgICB0aGlzLnBhdGhMZW5ndGggPSBbXVxuICAgIH1cbiAgICAvL1NWRyAuZ2V0VG90YWxMZW5ndGgoKSBmaXhcbiAgICBnZXRTdmdQb2x5bGluZUxlbmd0aChlbCkge1xuICAgICAgICBsZXQgdG90YWxMZW5ndGggPSAwO1xuICAgICAgICBsZXQgcHJldlBvcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgZWwucG9pbnRzLm51bWJlck9mSXRlbXM7aSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gZWwucG9pbnRzLmdldEl0ZW0oaSk7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSBNYXRoLnNxcnQoTWF0aC5wb3coKHBvcy54IC0gcHJldlBvcy54KSwgMikgKyBNYXRoLnBvdygocG9zLnkgLSBwcmV2UG9zLnkpLCAyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2UG9zID0gcG9zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbExlbmd0aDtcbiAgICB9XG4gICAgLy9TVkcgLmdldFRvdGFsTGVuZ3RoKCkgZml4XG4gICAgZ2V0U3ZnRWVtZW50TGVuZ3RoKGVsKXtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSBlbC5jb25zdHJ1Y3RvclxuXG4gICAgICAgIHN3aXRjaCAoY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgU1ZHUG9seWxpbmVFbGVtZW50OiByZXR1cm4gdGhpcy5nZXRTdmdQb2x5bGluZUxlbmd0aChlbCk7XG4gICAgICAgICAgICBjYXNlIFNWR0xpbmVFbGVtZW50OiByZXR1cm4gKCh4MSwgeDIsIHkxLCB5MikgPT4gTWF0aC5zcXJ0KCAoeDItPXgxKSp4MiArICh5Mi09eTEpKnkyICkpKGVsLmdldEF0dHJpYnV0ZSgneDEnKSwgZWwuZ2V0QXR0cmlidXRlKCd4MicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmdldEF0dHJpYnV0ZSgneTEnKSwgZWwuZ2V0QXR0cmlidXRlKCd5MicpKTtcbiAgICAgICAgICAgIGNhc2UgU1ZHUmVjdEVsZW1lbnQ6IHJldHVybiAoZWwuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKjIpICsgKGVsLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykqMik7XG4gICAgICAgICAgICBjYXNlIFNWR1BhdGhFbGVtZW50OiByZXR1cm4gZWwuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLzNyZCBtZXRob2QgcmFuXG4gICAgZ2V0RGFzaFN0cm9rZShlbCl7XG5cbiAgICAgICAgbGV0IGxlbmd0aCA9IGVsLmxlbmd0aFxuICAgICAgICB3aGlsZShsZW5ndGgtLSl7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBlbFtsZW5ndGhdXG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgLy8gRml4IGZvciBTVkcuZ2V0VG90YWxMZW5ndGgoKSAgbm90IHdvcmtpbmcgb24gc29tZSBwYXRocy4gXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoTGVuZ3RoLnVuc2hpZnQoIHRoaXMuZ2V0U3ZnRWVtZW50TGVuZ3RoKF8oJ2FuaW1hdGUtY2lyY3VpdCcpW2luZGV4XSkgKVxuICAgICAgICAgICAgfWNhdGNoKGVycil7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQ2xhc3Nlcygpe1xuICAgICAgICBsZXQgbGVuZ3RoID0gdGhpcy5lbGVtZW50cy5sZW5ndGhcbiAgICAgICAgd2hpbGUobGVuZ3RoLS0pe1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tsZW5ndGhdLmNsYXNzTGlzdC5hZGQoJ2FuaW1hdGVQYXRoJylcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLzJuZCBtZXRob2QgcmFuXG4gICAgZ2V0UmFuZG9tUGF0aChjb3VudCl7XG5cbiAgICAgICAgbGV0IGkgPSAwXG4gICAgICAgIGxldCBsZW5ndGggPSBjb3VudCBcbiBcbiAgICAgICAgd2hpbGUoaSA8IGxlbmd0aCl7XG5cbiAgICAgICAgICAgIC8vIGl0ZW0gaXMgdGhlIGxvbmctcGF0aCB3aGljaCBpcyBhdCBpbmRleCAwIGlmIGNvdW50ID09PSAxLCBlbHNlIHJ1biByYW5kb20gXG4gICAgICAgICAgICBsZXQgaXRlbSA9IE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAxMCApXG5cbiAgICAgICAgICAgIC8vQ2hlY2tzIGZpcnN0IHRvIG1ha2Ugc3VyZSBubyBkdXBsaWNhdGUgaXRlbXMgaW4gYXJyYXlcbiAgICAgICAgICAgIGxldCBub3RJbkFycmF5ID0gdGhpcy5pbmRleC5pbmRleE9mKGl0ZW0pID09PSAtMVxuICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKG5vdEluQXJyYXkpe1xuICAgICAgICAgICAgICAgIGkrK1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucHVzaCggaXRlbSApXG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50cy5wdXNoKCBfKCdhbmltYXRlLWNpcmN1aXQnKVtpdGVtXSApXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFuaW1DaXJjdWl0ID0gdGhpcy5lbGVtZW50c1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFxuICAgICAgXG4gICAgfVxuICAgIC8vNHRoIG1ldGhvZCByYW5cbiAgICBhZGREYXRhKGluZGV4KXtcbiBcbiAgICAgICAgdGhpcy5zcGVlZC5wdXNoKHtzcGVlZDogMCwgajogMCwgZGVsYXk6IDI1ICogaW5kZXh9KVxuICAgIH1cbiAgICAvLzFzdCBtZXRob2QgcmFuXG4gICAgc2V0RGFzaEFycmF5KGNvdW50KXtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5nZXRSYW5kb21QYXRoKGNvdW50KVxuXG4gICAgICAgIGxldCBpID0gaW5kZXgubGVuZ3RoXG4gICAgICAgIHRoaXMuZ2V0RGFzaFN0cm9rZShpbmRleClcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgd2hpbGUoaS0tKXtcbiAgIFxuICAgICAgICAgICAgdGhpcy5hbmltQ2lyY3VpdFtpXS5zdHlsZS5zdHJva2UgPSAnb3JhbmdlJ1xuICAgICAgICAgICAgdGhpcy5hbmltQ2lyY3VpdFtpXS5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gLXRoaXMucGF0aExlbmd0aFtpXVxuICAgICAgICAgICAgdGhpcy5hbmltQ2lyY3VpdFtpXS5zdHlsZS5zdHJva2VEYXNoYXJyYXkgPSB0aGlzLnBhdGhMZW5ndGhbaV1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5hZGREYXRhKGNvdW50KVxuICAgIFxuICAgICAgICAgICBpZihpID09PSAwKSB0aGlzLnN0YXJ0QW5pbWF0aW9uKClcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL1JhbiBsYXN0XG4gICAgc3RhcnRBbmltYXRpb24oKXtcbiAgICAgICAgbGV0IGRpc3QgPSB0aGlzLnBhdGhMZW5ndGhcbiAgICAgICAgbGV0IGVsID0gdGhpcy5hbmltQ2lyY3VpdFxuICAgICAgICBsZXQgZHVyYXRpb24gPSB0aGlzLnNwZWVkXG4gICAgICAgIGxldCBsZW5ndGggPSBlbC5sZW5ndGhcbiAgICAgICAgbGV0IGNvdW50U3BlZWQgPSA1O1xuXG4gICAgICAgIGZ1bmN0aW9uIGRyYXcoKXtcbiAgICAgICAgICAgIC8vUmVtb3ZlcyBBbmltYXRpb25cbiAgICAgICAgICAgIGlmKCF0b2dnbGVBbmltYXRlLmNpcmN1aXQpe1xuICAgICAgICAgICAgICAgIGxldCBpID0gZWwubGVuZ3RoXG5cbiAgICAgICAgICAgICAgICB3aGlsZShpLS0pe1xuICAgICAgICAgICAgICAgICAgICBlbFtpXS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZGFzaEFycmF5ID0gZWxbaV0uc3R5bGUuc3Ryb2tlRGFzaGFycmF5XG4gICAgICAgICAgICAgICAgbGV0IGRhc2hPZmZzZXQgPSBlbFtpXS5zdHlsZS5zdHJva2VEYXNob2Zmc2V0XG5cbiAgICAgICAgICAgICAgICAvLyBTdHJva2VEYXNob2Zmc2V0IGlzIGxlc3MgdGhlbiAwIHJ1bnMgc2FtZSBkaXJlY3Rpb24gXG4gICAgICAgICAgICAgICAgaWYoZGFzaE9mZnNldCA+PSAwICYmICFkdXJhdGlvbltpXS5qKXtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25baV0uc3BlZWQgPSAwXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uW2ldLmogPSAxXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBzcGVlZCA9ICBkdXJhdGlvbltpXS5zcGVlZCArPSBjb3VudFNwZWVkXG4gICAgICAgICAgICAgICAgbGV0IGl0ZXJhdG9yID0gZGFzaE9mZnNldCA8PSAwID8gLWRpc3RbaV0gOiAwO1xuICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vU3RvcHMgc3Ryb2tlZGFzaGFycmF5IGF0IGFib3V0IGEgM3JkIHRvIGtlZXAgdGhlIGxlbmd0aCB0aGF0IHNpemVcbiAgICAgICAgICAgICAgICBpZihkYXNoQXJyYXkgPj0gKGRpc3RbaV0gLyAxLjgpICl7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBlbFtpXS5zdHlsZS5zdHJva2VEYXNoYXJyYXkgPSBkaXN0W2ldIC0gc3BlZWRcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlbFtpXS5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gaXRlcmF0b3IgKyBzcGVlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXcpXG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXcpXG4gICAgfVxufVxuXG5cblxuY2lyY3VpdFRvZ2dsZS50b2dnbGVBbmltID0gZmFsc2Vcblxud2luZG93Lm9ubG9hZCA9IGZ1bmN0aW9uKGUpe1xuICAgIGNvbnN0IGRpZ2l0YWwgPSBuZXcgRGlnaXRhbCgpXG4gICAgY29uc3QgY2lyY3VpdCA9IG5ldyBDaXJjdWl0KClcblxuICAgIC8vIGNpcmN1aXQuc2V0RGFzaEFycmF5KDYpXG4gICAgZGlnaXRhbC5zdGFydEhhbmRBbmltYXRpb24oKVxuXG4gXG4gICAgbGV0IG5ld1RlY2hub2xvZ2llcyA9IG5ldyBUZWNobm9sb2dpZXMoKTtcbiAgICBuZXdUZWNobm9sb2dpZXMubG9hZEltYWdlcygpO1xuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRlY2hub2xvZ2llcyAuc3RhcnQtY2FudmFzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgICBUZWNobm9sb2dpZXMucHJvdG90eXBlLnRvZ2dsZSA9IHRydWVcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG5ld1RlY2hub2xvZ2llcy5kcmF3LmJpbmQobmV3VGVjaG5vbG9naWVzKSkgXG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50ZWNobm9sb2dpZXMgLnN0b3AtY2FudmFzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgICBUZWNobm9sb2dpZXMucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShuZXdUZWNobm9sb2dpZXMuZHJhdy5iaW5kKG5ld1RlY2hub2xvZ2llcykpIFxuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB2YXIgc3RhcnJ5TmlnaHQgPSBuZXcgU3RhcnJ5TmlnaHQoKVxuICAgIHN0YXJyeU5pZ2h0LmxvYWRJbWFnZXMoKVxuXG4gICAgaG92ZXJNYXAoKVxuICAgIFxuICAgIHZhciBkZXNpZ25TbGlkZXIgPSBuZXcgRGVzaWduU2xpZGVyKCk7XG4gICAgZGVzaWduU2xpZGVyKCk7XG5cbiAgICByb2JvdFsxXSgpIC8vdXBkYXRlcyByb2JvdCBsb2NhdGlvblxuICAgIHJvYm90WzBdLmxvYWRJbWFnZXMoKTsgLy90aGVuIGxvYWRlcyBpbWFnZXMgaW50byBzbGlkZXJcblxuICAgIHJvYm90RmxpZ2h0LmZseUludG9QbGFjZS5oaWRlUm9ib3QoMS4zKTsgLy9IaWRlcyBmbHlpbmcgcm9ib3Qgb3V0IG9mIHNjcmVlbiB2aWV3XG4gICAgXG4gICAgXG59LmJpbmQodGhpcyk7XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFyQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFlQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1QkE7QUFDQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZkE7QUFpQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFJQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBdkJBO0FBeUJBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBdkhBO0FBQ0E7QUF5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTlCQTtBQWdDQTtBQUNBO0FBQ0E7Ozs7OztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBZEE7QUFlQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFwWkE7QUFDQTtBQXNaQTs7O0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWJBO0FBY0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUE3TUE7QUFDQTtBQStNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBTUE7QUFBQTtBQU5BO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpEQTtBQUFBO0FBQUE7QUFDQTtBQWtEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpDQTtBQUNBO0FBMkNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUxBO0FBT0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBREE7QUFDQTtBQUNBO0FBRkE7QUFHQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTs7OztBQTlFQTtBQUNBO0FBK0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFHQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFMQTtBQU9BO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ })

/******/ });