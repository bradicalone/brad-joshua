/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/******  GLOBAL VARIABLES  *******/\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar animate768 = \"M565.1,0v900H0c0,0,0-75.3,0-192.4c0-211.7,0-303.7,0-533.1C0,50.5,0,0,0,0H565.1z;\" + \"M565.1,0v900H182.7c0,0-44-72.5-44-191.7c0-107.5,121.8-396.1,121.8-533.8C260.5,41,245.9,0,245.9,0H565.1z;\" + \"M571.8,0v900H386.7c0,0-31.4-42.7-31.4-191.7C355.3,568,555,285,555,80.7C555,20,551.5,0,551.5,0H571.8z;\" + \"M573,0v900h-2.3c0,0,0.4-65.2,0.4-192.4c0-176.8-0.2-347.9-0.2-533.4c0-124-0.2-174.2-0.2-174.2H573z\";\n\nvar animate400 = \"M390,800H6c0,0-6-45.9-6-161.3C0,443.6,5,286.1,5,47.3C5,10.7,3,0,3,0h387V800z;\" + \"M390,800H96c0,0-46-45.9-46-161.3c0-195.1,130-352.6,130-591.3c0-36.7-3-47.3-3-47.3h213V800z;\" + \"M390,800H243c0,0-37-45.9-37-161.3c0-195.1,176-352.6,176-591.3c0-36.7-1-47.3-1-47.3h9V800z;\" + \"M390,800h-7c0,0,0-45.9,0-161.3c0-195.1,5-352.6,5-591.3c0-36.7-1-47.3-1-47.3h3V800z\";\n\nvar isFirefox = typeof InstallTrigger !== 'undefined';\nvar isSafari = navigator.userAgent.indexOf(\"Safari\") != -1 && navigator.userAgent.indexOf(\"Chrome\") === -1;\n//If user is on ipad / iphone / ipod\nvar isIOS = function isIOS() {\n    var userAgent = navigator.userAgent || navigator.vendor || window.opera;\n    return (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream\n    );\n};\n\nvar wW = window.innerWidth;\nvar wH = window.innerHeight;\nvar lastDist = void 0;\n\n//Firefox Bug, transforms not working, so sets attribute to 0 instead\nif (isFirefox) {\n    //svg morfing problem\n    document.getElementsByTagName('feGaussianBlur')[0].setAttribute('stdDeviation', '6');\n    //svg css problem\n    _('svg-circle').setAttribute('r', 0);\n    _('svg-circle').style.transform = 'scale(1)';\n}\n\nif (isSafari) _('svg-page').style.visibility = \"hidden\";\n\nfunction _(clss) {\n\n    var classes = document.getElementsByClassName(clss);\n\n    if (classes.length === 1) {\n        return classes[0];\n    }\n    if (classes.length > 1) {\n        return classes;\n    } else return \"Not a working class\";\n};\n\nvar easeOut = function easeOut(progress) {\n    return Math.pow(--progress, 5) + 1;\n};\n\n//String: indicates new size of width or height that you want. Size: of the new size of the string. El: the element you want it for\nvar newSize = function newSize(string, size, el) {\n    if (typeof el !== 'undefined') {\n\n        var ogWidth = el.getBoundingClientRect().width;\n        var ogHeight = el.getBoundingClientRect().height;\n        if (ogWidth === 0 || ogHeight === 0) {\n            ogWidth = el.getAttribute('width');\n            ogHeight = el.getAttribute('height');\n        }\n    } else {\n        var ogWidth = 762.22;\n        var ogHeight = 668.97;\n    }\n\n    if (string === 'height') {\n        var ratio = ogHeight / size;\n        return {\n            height: size,\n            width: ogWidth / ratio\n        };\n    } else if (string === 'width') {\n        var _ratio = ogWidth / size;\n        return {\n            width: size,\n            height: ogHeight / _ratio\n        };\n    } else console.log('check parameters');\n};\n\nWebFont.load({\n    google: {\n        families: ['Do Hyeon', 'Orbitron']\n    },\n    active: function active() {\n        //Starts when google fonts are loaded     \n        slotMachine();\n        Stretch();\n    }\n});\n\nfunction slotMachine() {\n\n    var canvas = document.getElementById('slot-machine');\n    var ctx = canvas.getContext('2d');\n\n    var Slot = function Slot() {\n        this.x = 0;\n        this.width = canvas.width = wW < 970 ? 360 : 475;\n        this.height = canvas.height = wW < 970 ? 360 : 475;\n        this.text = 'PHOTO';\n        this.letters = [];\n\n        this.addLetter = function (n) {\n\n            var letterHeight = wW < 970 ? -124 : -158;\n\n            //Places letters at top index 1,3,5\n            var bottom = wW < 970 ? this.height + 60 : this.height + 96;\n            for (var j = 0; j < n; j++) {\n                //Resets x every iteration\n                this.x = 0;\n                //Adjust bottom and height all letters\n                letterHeight = wW < 970 ? letterHeight + 121 : letterHeight + 158;\n                for (var i = 0; i < this.text.length; i++) {\n\n                    var data = {\n                        top: letterHeight,\n                        letter: this.text[i],\n                        x: i === 0 ? -5 : wW < 970 ? this.x += 74 : this.x += 100.8,\n                        speed: 9,\n                        bottom: bottom - letterHeight,\n                        start: i % 2 === 0 ? \"up\" : \"down\"\n                    };\n                    n === 4 ? this.letters.push(data) : this.letters.unshift(data);\n\n                    var letter = data;\n\n                    if (i % 2 === 0) {\n                        this.drawUp(letter);\n                    } else {\n\n                        if (wW < 970) {\n                            //fixes spacing issue Orbitron font\n                            i === 3 ? letter.x += 3 : true;\n                            i === 1 ? letter.x -= 3 : true;\n                        }\n                        this.drawDown(letter);\n                    }\n                }\n            }\n        };\n        this.addLetter(4);\n    };\n\n    Slot.prototype.drawUp = function (text) {\n\n        ctx.font = wW < 970 ? \"Bold 62pt Orbitron\" : \"105pt Do Hyeon\";\n        ctx.fillText(text.letter, text.x, text.bottom);\n    };\n    Slot.prototype.drawDown = function (text) {\n\n        ctx.fillStyle = \"#0D1B56\";\n        ctx.font = wW < 970 ? \"Bold 62pt Orbitron\" : \"105pt Do Hyeon\";\n        ctx.fillText(text.letter, text.x, text.top);\n    };\n\n    Slot.prototype.update = function () {\n\n        // var push = wW < 970 ? -61 : -74\n        var push = wW < 970 ? -61 : -75;\n        if (!slotMachine.prototype.toggle) return;\n\n        //New set if letters drawn based on spacing\n        if (this.letters[19].bottom <= push) {\n\n            this.letters.splice(15, 5);\n            this.addLetter(1);\n        }\n\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        for (var i = 0; i < this.letters.length; i++) {\n\n            var letter = this.letters[i];\n\n            letter.top += letter.speed;\n            letter.bottom -= letter.speed;\n\n            if (letter.start === \"up\") {\n\n                this.drawUp(letter);\n            } else this.drawDown(letter);\n        }\n        requestAnimationFrame(this.update.bind(this));\n    };\n    var slot = new Slot();\n\n    document.querySelector('.photo .start-canvas').addEventListener('click', function () {\n\n        //Start Canvas\n        slotMachine.prototype.toggle = true;\n        requestAnimationFrame(slot.update.bind(slot));\n    });\n\n    document.querySelector('.photo .stop-canvas').addEventListener('click', function () {\n        //Stop Canvas\n        slotMachine.prototype.toggle = false;\n    });\n}\n\nfunction Stretch() {\n\n    var canvas = document.getElementById('stretch');\n    var ctx = canvas.getContext('2d');\n\n    if (wW < 970) {\n        var width = 400;\n        var height = 375;\n        var strtch = 15;\n        var letterDist = 53;\n        var x = 65;\n        var stretchX = 5;\n        var mixedNum = 5;\n    }\n    if (wW < 400) {\n        var width = 360;\n        var height = 375;\n        var x = 50;\n        var mixedNum = -10;\n    }\n    if (wW > 970) {\n        var width = 650;\n        var height = 450;\n        var strtch = 30;\n        var letterDist = 65;\n        var x = 125;\n        var mixedNum = 5;\n    }\n    /** CHANGE NUMBER FOR lineCount TO ADD OR SUBTRACT HOW MANY LINES OF WORDS **/\n    var lineCount = 7;\n    var count = 0;\n    var t = lineCount - 1;\n    var colors = [\"#DAF7A6\", \"#FFC300 \", \"#FF5733\", \"#C70039\", \"#900C3F\", \"#581845\", \"#37102b\"];\n    var Letters = function Letters() {\n        // this.text = 'SOLUTIONS'\n        this.letters = [];\n        this.total = this.letters.length - 1;\n        this.total = 0;\n        this.y = 0;\n\n        this.width = canvas.width = width;\n        this.height = canvas.height = height;\n        this.text = 'DEVELOPER';\n\n        this.pushLetters = function (x, dist) {\n            //If pushLetters is ran again makes sure this.y = 0\n            if (this.y) this.y = 0;\n            var canvasHeight = this.height;\n            for (var i = 0; i < lineCount; i++) {\n                var data = {\n                    x: x,\n                    letter: this.text,\n                    stretch: strtch,\n                    start: 0,\n                    speed: i,\n                    dist: typeof dist === 'number' ? dist : 0,\n                    //Letters distance between each other virticle \n                    distance: this.y += letterDist,\n                    //Letters start on the bottom\n                    bottom: wW < 970 ? canvasHeight + 45 : canvasHeight + 62,\n                    begin: 1,\n                    //When the next rotation starts\n                    beginY: 0,\n                    scaleTotal: 4,\n                    distY: 0,\n                    color: colors[i]\n                };\n                this.letters.push(data);\n            }\n        };\n        this.pushLetters(x);\n    };\n\n    var drawUp = function drawUp(letter, dist) {\n\n        ctx.setTransform(1, 0, 0, letter.scale, letter.x, letter.bottom - dist);\n        ctx.font = wW < 970 ? \"40pt Do Hyeon\" : \"60pt Do Hyeon\";\n        ctx.fillStyle = letter.color;\n        ctx.fillText(letter.letter, 0, letter.textY);\n        // var text = ctx.measureText(letter.letter)\n    };\n    var stretch = function stretch(text) {\n        ctx.canvas.style.letterSpacing = text.dist + 'px';\n        ctx.font = wW < 970 ? \"40pt Do Hyeon\" : \"60pt Do Hyeon\";\n        ctx.fillStyle = text.color;\n        ctx.fillText(text.letter, text.x, text.bottom - text.distance);\n    };\n\n    var drawDown = function drawDown(letter) {\n        ctx.font = wW < 970 ? \"40pt Do Hyeon\" : \"60pt Do Hyeon\";\n        ctx.fillStyle = letter.color;\n        ctx.fillText(letter.letter, letter.x, letter.y);\n    };\n\n    var drawBackFlip = function drawBackFlip(letter) {\n        ctx.font = wW < 970 ? \"40pt Do Hyeon\" : \"60pt Do Hyeon\";\n        ctx.fillStyle = letter.color;\n        ctx.setTransform(1, 0, 0, letter.scale, letter.x, letter.y);\n        ctx.fillText(letter.letter, 0, letter.textY);\n    };\n\n    Letters.prototype.addLetters = function (timestamp) {\n\n        if (!Stretch.prototype.toggle) return;\n        var j = 0;\n\n        ctx.globalCompositeOperation = 'destination-under';\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        for (var i = 0; i < this.letters.length; i++) {\n\n            var letter = this.letters[i];\n            letter.y = letter.bottom - letter.distance;\n\n            //FOURTH AND LAST CALL, REMOVE WORDS\n            if (count === 3 && i === t) {\n\n                if (!letter.start) letter.start = timestamp;\n                var runtime = timestamp - letter.start;\n                var progress = Math.min(runtime / 600, 1);\n                letter.y += letter.distance * progress;\n\n                letter.scale = 0 || (letter.begin - letter.scaleTotal * progress).toFixed(2);\n                letter.textY = (letter.beginY + letter.distY * progress).toFixed(2);\n                drawBackFlip(letter);\n\n                if (letter.scale == -1 || letter.scale < -1) {\n\n                    letter.beginY = 10;\n                    letter.distY = wW < 970 ? -5 : -10;\n                    letter.scaleTotal = -4;\n                    letter.begin = -3;\n                }\n\n                if (progress === 1) {\n                    //Removes item from array after each word is finished animating\n                    this.letters.splice(t, 1);\n                    t--;\n                }\n                if (t === -1) {\n                    setTimeout(function () {\n                        this.total = 0;\n                        count = 0;\n                        t = lineCount - 1;\n                        this.letters.length = 0;\n                        this.pushLetters(x);\n                    }.bind(this), 200);\n                }\n            }\n            if (count === 3 && i !== t) drawDown(letter);\n\n            //THIRD, LETTER STRETCH IN\n            if (count === 2 && i === t) {\n                if (!letter.start) letter.start = timestamp;\n                var runtime = timestamp - letter.start;\n                var progress = Math.min(runtime / 125, 1);\n                letter.dist = letter.stretch - letter.stretch * progress;\n\n                letter.x = mixedNum + letter.stretch * progress * 4;\n\n                stretch(letter);\n\n                if (progress === 1) {\n                    t--;\n                }\n                //RESETS VARIABLES, CALLS FUNCTION ALL OVER AGAIN\n                if (t === -1) {\n                    setTimeout(function () {\n                        count++;\n                        t = lineCount - 1;\n                        this.letters.length = 0;\n                        this.pushLetters(x, 0);\n                    }.bind(this), 200);\n                }\n            }\n            if (count === 2 && i !== t) {\n\n                stretch(letter);\n            }\n\n            //SECOND, LETTER STRETCH OUT\n            if (count === 1 && i === j) {\n\n                if (!letter.start) letter.start = timestamp;\n                var runtime = timestamp - letter.start;\n                var progress = Math.min(runtime / 150, 1);\n\n                letter.dist = letter.stretch * progress;\n                letter.x = x - letter.dist * 4;\n\n                stretch(letter);\n\n                if (progress === 1) {\n                    j++;\n                }\n\n                if (j === this.letters.length) {\n                    count++;\n                    this.letters.length = 0;\n                    // -5 because letters stretched to far, need to fix numbers\n                    // wW < 970 ? this.pushLetters(5, 15) : this.pushLetters(5, 30);\n                    this.pushLetters(mixedNum, wW < 970 ? 15 : 30);\n                }\n            }\n            if (count == 1 && i !== j) {\n                letter.x = letter.x;\n                letter.dist = letter.dist;\n                stretch(letter);\n            }\n\n            //FIRST, LETTER CLIMBE\n            if (i === j && count === 0) {\n\n                if (!letter.start) letter.start = timestamp;\n                var runtime = timestamp - letter.start;\n                var progress = Math.min(runtime / 600, 1);\n                var dist = letter.distance * progress;\n\n                letter.scale = 0 || (letter.begin - letter.scaleTotal * progress).toFixed(2);\n                letter.textY = (letter.beginY + letter.distY * progress).toFixed(2);\n\n                drawUp(letter, dist);\n\n                //Adds second flip to make upright text half way up canvas\n                if (letter.scale == -1 || letter.scale < -1) {\n                    //When the next rotation starts for beginY and distY\n                    letter.beginY = wW < 970 ? 5 : 10;\n                    letter.distY = wW < 970 ? -5 : -10;\n                    letter.scaleTotal = -4;\n                    letter.begin = -3;\n                }\n\n                if (progress === 1) {\n                    j++;\n                }\n\n                if (j === this.letters.length) {\n                    count++;\n                    this.letters.length = 0;\n                    this.pushLetters(x, 0);\n                }\n            }\n        }\n        requestAnimationFrame(this.addLetters.bind(this));\n    };\n    var letters = new Letters();\n\n    document.querySelector('.developer .start-canvas').addEventListener('click', function (e) {\n\n        Stretch.prototype.toggle = true;\n        requestAnimationFrame(letters.addLetters.bind(letters));\n    });\n\n    document.querySelector('.developer .stop-canvas').addEventListener('click', function () {\n\n        Stretch.prototype.toggle = false;\n    });\n};\n\nfunction ImageShatter() {\n    var sizing = function sizing(content) {\n        if (content === 'dur') {\n            if (window.innerWidth < 600) return 2.6;else if (window.innerWidth > 600) return 3.5;\n        }\n        if (content === 'img') {\n            if (window.innerWidth <= 600) return 400;else if (window.innerWidth > 1200) return 580;else return 500;\n        }\n    };\n\n    var ns = 'http://www.w3.org/2000/svg';\n    var img = new Image();\n    var ctx, canvas;\n    var particleCanvas, particleCtx;\n    var canvasParentWidth;\n    var canvasParentHeight;\n    var ending = [];\n    var retractStart = 0;\n    var imgCanvas = function imgCanvas(width, height, img, callback) {\n        //Watch where this is loaded into when portfolio done\n        // document.body.innerHTML += '<canvas id=\"img-canvas\"></canvas>';\n        // canvas = document.getElementById('img-canvas')\n        canvas = document.getElementById('particle');\n        ctx = canvas.getContext(\"2d\");\n\n        canvas.width = width;\n        canvas.height = height;\n        canvasParentWidth = _('svg-page').getBoundingClientRect().width;\n        canvasParentHeight = _('svg-page').getBoundingClientRect().height;\n\n        ctx.drawImage(img, 0, 0, width, height);\n\n        //Calls function for clickable event listener to run and appends background canvas\n        callback(canvas, createParticleCanvas());\n    };\n\n    function createParticleCanvas() {\n\n        // Create our canvas\n        particleCanvas = document.createElement(\"canvas\");\n        particleCtx = particleCanvas.getContext(\"2d\");\n\n        // Size our canvas with additional sizing\n        particleCanvas.width = canvasParentWidth;\n        particleCanvas.height = canvasParentHeight;\n\n        // Position out canvas\n        particleCanvas.style.position = \"absolute\";\n        particleCanvas.style.top = \"0\";\n        particleCanvas.style.left = \"0\";\n\n        // Make sure it's on top of other elements\n        particleCanvas.style.zIndex = \"500\";\n\n        // Make sure other elements under it are clickable\n        particleCanvas.style.pointerEvents = \"none\";\n        var foreignObject = document.createElementNS(ns, \"foreignObject\");\n        foreignObject.setAttribute('class', \"particleObject\");\n        foreignObject.setAttribute('width', canvasParentWidth);\n        foreignObject.setAttribute('height', canvasParentHeight);\n        foreignObject.appendChild(particleCanvas);\n\n        document.querySelector('g.design').appendChild(foreignObject);\n    }\n\n    //Image comes appart\n    var ExplodingParticle = function ExplodingParticle() {\n        var _this2 = this;\n\n        this.begin = 0;\n\n        // Set how long we want our particle to animate for\n        this.animationDuration = 1000; // in ms\n\n        // Set the speed / distance for our particle\n        this.speed = {\n            x: window.innerWidth < 768 ? -5 + Math.random() * 10 : -10 + Math.random() * 20,\n            y: window.innerWidth < 768 ? -5 + Math.random() * 10 : -10 + Math.random() * 20\n        };\n\n        // Size our particle\n        window.innerWidth < 768 ? this.radius = 3 + Math.random() * 3 : this.radius = 4 + Math.random() * 4;\n\n        // Set a max time to live for our particle\n        this.life = 30 + Math.random() * 10;\n        this.remainingLife = this.life;\n\n        // This function will be called by our animation logic later on\n        this.draw = function (ctx) {\n\n            var p = _this2;\n\n            if (_this2.remainingLife > 0 && _this2.radius > 0) {\n\n                // Draw a circle at the current location\n                ctx.beginPath();\n                ctx.arc(p.startX, p.startY, p.radius, 0, Math.PI * 2);\n                ctx.fillStyle = \"rgba(\" + _this2.rgbArray[0] + ',' + _this2.rgbArray[1] + ',' + _this2.rgbArray[2] + \", 1)\";\n                ctx.fill();\n\n                // Update the particle's location and life\n                p.remainingLife--;\n                p.radius -= 0.25;\n                p.startX += p.speed.x;\n                p.startY += p.speed.y;\n            }\n        };\n        this.retract = function (begin, finale, timestamp) {\n\n            if (!retractStart) retractStart = timestamp;\n\n            var runtime = timestamp - retractStart;\n            var progress = Math.min(runtime / 3000, 1);\n\n            // canvas.style.opacity = 1 - progress\n            particleCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n\n            for (var i = 0; i < begin.length; i++) {\n                var start = begin[i];\n                var end = finale[i];\n\n                var distX = Math.abs(start.startX - end.x);\n                var distY = Math.abs(start.startY - end.y);\n\n                //If end x or y is greater than x or y subtract else add\n                start.x = start.startX > end.x ? start.startX - distX * progress : start.startX + distX * progress;\n                start.y = start.startY > end.y ? start.startY - distY * progress : start.startY + distY * progress;\n                start.rad = start.begin + end.rad * progress;\n\n                particleCtx.beginPath();\n\n                particleCtx.arc(start.x, start.y, start.rad, 0, Math.PI * 2);\n                particleCtx.fillStyle = \"rgba(\" + start.rgbArray[0] + ',' + start.rgbArray[1] + ',' + start.rgbArray[2] + ',' + start.rgbArray[3] + \")\";\n\n                particleCtx.fill();\n            }\n            if (progress === 1) {\n                //returns the photo back if ran again\n                return;\n            }\n\n            requestAnimationFrame(function (timestamp) {\n                this.retract(begin, finale, timestamp);\n            }.bind(_this2));\n        };\n    };\n\n    var particles = [];\n\n    function createParticleAtPoint(x, y, colorData) {\n        var particle = new ExplodingParticle();\n\n        particle.rgbArray = colorData;\n        particle.startX = x;\n        particle.startY = y;\n        particle.startTime = Date.now();\n\n        particles.push(particle);\n        var end = {};\n        end.start = 0;\n        end.rad = particle.radius;\n        end.x = x;\n        end.y = y;\n        ending.push(end);\n    }\n\n    var opac = 1;\n    function update() {\n        if (typeof particleCtx !== \"undefined\") {\n            particleCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n        }\n        //image fades as it's breaking apart\n        canvas.style.opacity = opac = opac - .08;\n\n        // Draw all of our particles in their new location\n        for (var i = 0; i < particles.length; i++) {\n\n            particles[i].draw(particleCtx);\n\n            // When particles \n            if (particles[i].radius < 0) {\n                var percent = (Date.now() - particles[i].startTime) / particles[i].animationDuration;\n                var dur = sizing('dur');\n\n                if (percent > dur) {\n\n                    var particle = new ExplodingParticle();\n\n                    particle.retract(particles, ending);\n\n                    return;\n                }\n            }\n        }\n        window.requestAnimationFrame(update);\n    }\n\n    var clearData = function clearData() {\n        retractStart = null;\n        canvas.removeAttribute('style');\n        particleCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n        ending = [];\n        particles = [];\n    };\n\n    img.onload = function () {\n        var width = sizing('img');\n        var height = width;\n        imgCanvas(width, height, this, runEvents);\n    };\n    img.src = 'images/design-img.png';\n\n    function runEvents(imgCanvas) {\n        var foreignObject = document.querySelector('.design .item-canvas');\n\n        var imageLeft = parseInt(foreignObject.getAttribute('x'));\n        var imageTop = parseInt(foreignObject.getAttribute('y'));\n        // let reductionFactor = window.width <= 400 ? 15 : Math.round(imgCanvas.width / 15)\n        if (window.innerWidth < 600) var reductionFactor = 15;\n        if (window.innerWidth >= 600) var reductionFactor = 22;\n        if (window.innerWidth >= 1200) var reductionFactor = 33;\n\n        //Removes canvas with particles made from when closing svg page\n        _('close-btn').addEventListener('click', clearData);\n\n        imgCanvas.addEventListener('click', function (e) {\n            if (e.target.style.opacity) {\n\n                return clearData();\n            }\n\n            //width first one pixel, then all of height pixels, width another pixel then all of height pixels \n            var rgbaData = ctx.getImageData(0, 0, this.width, this.height).data;\n            var count = 0;\n            for (var x = 0; x < this.width; x++) {\n                for (var y = 0; y < this.height; y++) {\n\n                    if (count % reductionFactor === 0) {\n\n                        var index = (y * this.width + x) * 4;\n                        var rgbaColorArr = rgbaData.slice(index, index + 4);\n\n                        var globalX = imageLeft + x;\n                        var globalY = imageTop + y;\n\n                        createParticleAtPoint(globalX, globalY, rgbaColorArr);\n                    }\n                    count++;\n                }\n            }\n            update();\n        });\n    }\n}\nImageShatter();\n\nfunction StarryNight() {\n\n    var canvas = document.getElementById('starryNight');\n    var ctx = canvas.getContext('2d');\n    var data = [];\n    var trailData = [];\n    var rgb = trailData.length > 1 && 150 / trailData.length;\n    var j = 0;\n    var houseWidth = window.innerWidth < 768 ? 380 : 600;\n    var houseHeight = newSize('width', houseWidth).height;\n    this.width = canvas.width = _('svg-page').getAttribute('width');\n    this.height = canvas.height = _('svg-page').getAttribute('height');\n    this.toggle = true;\n\n    this.images = [];\n\n    //Men Data\n    var menData = {\n        headArc: window.innerWidth < 768 ? 4 : 6,\n        stepDown: window.innerWidth < 768 ? 12 : 17,\n        rotatedPos: 0,\n        rotateDegree: 14,\n        j: 0, //Each point of animation, walk, stand still, rotate ,falling\n        start: 0,\n        begin: 0,\n        lastPosX: 90,\n        lastPosY: undefined,\n        arcStartX: window.innerWidth < 768 ? 7 : 10,\n        arcStartY: 5\n\n        //House animation Data\n    };this.house = {\n        houseImg: undefined,\n        toggle: undefined,\n        currentY: undefined,\n        start: 0,\n        right: this.width - houseWidth,\n        bottom: this.height - houseHeight,\n        startY: function startY() {\n            return this.bottom + houseWidth / 2.4;\n        },\n        startX: function startX() {\n            return this.right;\n        },\n        begin: function begin() {\n            menData.lastPosY = houseHeight / 2.24 - starryNight.images[0].height;\n            ctx.drawImage(this.houseImg, this.startX(), this.startY(), houseWidth, houseHeight);\n        },\n        rise: this.height / 2,\n        moveLeft: window.innerWidth < 500 ? this.width / 20 : this.width / 8\n\n        //Star Trail Data\n    };var lastPosition = function lastPosition(xPos, yPos, radius, alpha) {\n        trailData.push({\n            x: xPos,\n            y: yPos,\n            radius: radius,\n            alpha: alpha\n        });\n        if (trailData.length > 25) trailData.shift();\n    };\n\n    this.randomMax = function (min, max) {\n        return Math.floor(Math.random() * (max - min) + min);\n    };\n\n    //Adds data for Shooting star\n    this.addData = function () {\n        for (var i = 0; i < 8; i++) {\n            var measurements = {\n                // Starts randomly on the x axis\n                delay: i === 0 ? 0 : this.randomMax(1, 2),\n                x: this.randomMax(0, this.width / 2),\n                y: this.randomMax(200, this.height),\n                radius: window.innerWidth < 768 ? this.randomMax(5, 13) : this.randomMax(8, 16),\n                distance: this.width + 100,\n                globAlpha: 1,\n                opac: 1,\n                endPos: this.randomMax(100, this.width),\n                start: 0,\n                time: 0,\n                explodeStart: 0,\n                explodeSize: window.innerWidth < 768 ? 20 : 35\n            };\n            data.push(measurements);\n        }\n    }.bind(this);\n\n    //When prototype.toggle = false this automatically gets ran to be able to run animation again\n    this.restoreData = function () {\n        data = [];\n        trailData = [];\n        j = 0;\n        this.addData();\n        menData.begin = null;\n    };\n\n    function drawHouse(image, timestamp) {\n        if (!image.start) image.start = timestamp;\n        var runtime = timestamp - image.start;\n        var progress = runtime / 2000;\n\n        var distance = image.rise * progress;\n\n        //Floating in place\n        if (image.currentY) {\n\n            image.toggle ? image.x = image.currentX - distance : image.x = image.currentX + distance;\n            image.toggle ? image.y = image.currentY + distance : image.y = image.currentY - distance;\n        }\n\n        if (distance >= image.rise) {\n            //Makes currentY true and updates postion of the image\n            image.currentY = image.y;\n            image.currentX = image.x;\n            image.toggle ? image.toggle = false : image.toggle = true;\n            image.start = 0;\n            image.rise = 50;\n        }\n        //Ends the first rise of the image\n        if (!image.currentY) {\n            image.x = image.startX() - image.moveLeft * progress;\n            image.y = image.startY() - image.rise * progress;\n        }\n\n        ctx.drawImage(image.houseImg, image.x, image.y, houseWidth, houseHeight);\n    }\n\n    function drawStars(cir) {\n        ctx.save();\n        ctx.globalAlpha = cir.alpha;\n\n        ctx.beginPath();\n        ctx.arc(cir.xPos, cir.yPos, cir.radius, 0, 2 * Math.PI);\n        ctx.fillStyle = 'rgba(255, 255, 73, ' + cir.opacity + ')';\n        ctx.fill();\n        ctx.restore();\n        lastPosition(cir.xPos, cir.yPos, cir.radius, cir.alpha);\n    }\n\n    function drawTrail(trail) {\n        ctx.save();\n        ctx.globalAlpha = 0.2;\n        ctx.beginPath();\n        ctx.arc(trail.x, trail.y, trail.rad, 0, 2 * Math.PI, true);\n        ctx.fillStyle = 'rgba(238,' + trail.color + ', 6, ' + trail.fade + ')';\n        ctx.fill();\n        ctx.restore();\n    }\n    function drawExplosion(circle, timestamp) {\n\n        if (!circle.explodeStart) circle.explodeStart = timestamp;\n        var runtime = timestamp - circle.explodeStart;\n        var progress = runtime / 400;\n        var ease = easeOut(progress);\n        ctx.beginPath();\n        ctx.arc(circle.xPos, circle.yPos, 0 + circle.explodeSize * ease, 0, 2 * Math.PI, true);\n        ctx.fillStyle = 'rgba(249, 255, 0, ' + (1 - .9 * progress) + ')';\n        ctx.fill();\n    }\n    function drawMen(men) {\n\n        if (menData.j >= 4 && menData.j <= 5) {\n            ctx.translate(men.translateX, men.translateY);\n            ctx.rotate(men.rotate * Math.PI / 180);\n            ctx.drawImage(men.img, -men.width / 2, -men.height, men.width, men.height);\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\n        } else {\n            ctx.save();\n            ctx.globalAlpha = men.opac;\n            ctx.beginPath();\n            ctx.arc(men.arcX, men.arcY, men.arcRadius, 0, 2 * Math.PI);\n            ctx.fillStyle = \"#000\";\n            ctx.fill();\n            ctx.drawImage(men.img, men.x, men.y, men.width, men.height);\n            ctx.restore();\n        }\n    }\n\n    var draw = function (timestamp) {\n        if (!StarryNight.prototype.toggle) {\n            return this.restoreData();\n        }\n\n        //House\n        var image = this.house;\n\n        ctx.clearRect(0, 0, this.width, this.height);\n\n        //Men running start , Stars start after house gets to top. \n        if (image.currentY) {\n\n            //**  START OF STARS  **/\n\n            // Draws the trail opacity  \n            if (menData.j >= 1) {\n                for (var i = 0; i < trailData.length; i++) {\n                    var trail = trailData[i];\n                    var fadeSize = i / trailData.length;\n\n                    //Trail tapers as it goes.\n                    var radiusTaper = (trail.radius - 2) / trailData.length;\n                    trail.color = 240 - (i + j);\n                    trail.fade = i / trailData.length;\n\n                    //Tapers down the raidus of the trail\n                    trail.rad = trail.radius = trail.radius - radiusTaper;\n                    // trail.rad = trail.radius\n                    drawTrail(trail);\n                }\n\n                //Draws stars\n                for (var _i = 0; _i < data.length; _i++) {\n                    var circle = data[_i];\n\n                    if (j >= _i) {\n\n                        if (!circle.start) circle.start = timestamp;\n                        var _runtime = timestamp - circle.start;\n                        var _progress = _runtime / 2000;\n                        var ease = easeOut(_progress);\n                        circle.time = circle.delay - ease;\n\n                        //If the current circle delay = progress draws next circle, (random drawing look)\n                        if (circle.time <= 0) {\n\n                            //current circle set to undefined keep from running again\n                            circle.delay = undefined;\n                            j++;\n                        }\n                        circle.alpha = circle.globAlpha - 1 * _progress;\n                        circle.opacity = circle.opac - .9 * _progress;\n                        // circle.duration = ease\n\n                        if (j % 3 !== 0 && menData.j >= 1) {\n                            circle.xPos = circle.x + circle.endPos * ease;\n                            circle.yPos = 0 + circle.y * ease;\n                            ctx.globalCompositeOperation = 'destination-over';\n                        } else {\n                            circle.xPos = circle.x + circle.endPos * ease;\n                            circle.yPos = 0 + circle.y * _progress;\n                            ctx.globalCompositeOperation = 'source-over';\n                        }\n\n                        drawStars(circle);\n\n                        //Explosion start\n                        if (circle.xPos > image.x && circle.yPos > image.y) {\n\n                            drawExplosion(circle, timestamp);\n                        }\n\n                        if (j === data.length) {\n                            j = 0;\n                            data = [];\n                            trailData = [];\n                            this.addData();\n                        }\n                    }\n                }\n            }\n            //**  START OF MEN  **/\n            var menLength = starryNight.images.length - 1;\n\n            for (var _i2 = 0; _i2 < menLength; _i2++) {\n                var men = starryNight.images[_i2];\n\n                if (!menData.begin) menData.begin = timestamp;\n                var runtime = timestamp - menData.begin;\n                var progress = Math.min(runtime / 2000, 1);\n\n                //First walk out\n                if (menData.j === 0) {\n                    menData.start = parseInt((progress * 15).toFixed(0));\n                    menData.distanceX = window.innerWidth < 768 ? 95 : 205;\n                }\n                //Second Walk stands still\n                if (menData.j === 1) {\n                    //Starts and ends with last dude\n                    menData.start = 15;\n                    // Keeping count at last man instead of counting through them to animate\n                    menData.distanceX = 0;\n                }\n\n                //Third walk down and to the end\n                if (menData.j === 2) {\n                    menData.start = parseInt((progress * 15).toFixed(0));\n                    men.walkDown = Math.min(progress * 6, 1) * menData.stepDown;\n                    // menData.distanceX = 250\n                    menData.distanceX = window.innerWidth < 768 ? 159 : 250;\n                }\n\n                //Looks down\n                if (menData.j === 3) {\n                    var headIterate = Math.min(runtime / 1000, 1);\n\n                    //updates men.walkdown that gets ran before back to 0\n                    men.walkDown = 0;\n                    menData.start = 16;\n                    menData.distanceX = 0;\n                    men.arcX = image.x + (menData.lastPosX + (men.width / 2 + 2)) + menData.arcStartX * headIterate;\n                    men.arcY = image.y + (menData.lastPosY + 4) + menData.arcStartY * headIterate;\n                    men.arcRadius = menData.headArc;\n                }\n                //Rotates back and forth\n                if (menData.j === 4) {\n                    //2nd rotated position\n                    var newRotatedPos = menData.rotatedPos - (menData.rotateDegree * iterate - menData.rotatedPos);\n                    menData.start = 14;\n\n                    menData.distanceX = 0;\n\n                    men.translateX = image.x + (menData.lastPosX + men.width / 1.8);\n                    men.translateY = image.y + (menData.lastPosY + men.height);\n                    var iterate = Math.min(progress * 3, 3);\n\n                    if (menData.rotatedPos <= menData.rotateDegree) {\n                        menData.rotatedPos = menData.rotateDegree * iterate;\n                        men.rotate = menData.rotatedPos;\n                    } else {\n                        //Rotate back and forth\n                        if (newRotatedPos >= 0) men.rotate = newRotatedPos;\n                        if (newRotatedPos <= 0) men.rotate = -newRotatedPos;\n                    }\n\n                    //updates roatedPos for mendata.js = 5 to be used below\n                    if (progress === 1) {\n                        men.arcRadius = 0;\n                        menData.roatedPos = men.rotate;\n                    }\n                }\n                //Falls Down\n                if (menData.j === 5) {\n                    menData.start = parseInt((progress * 10).toFixed(0));\n\n                    men.translateX = image.x + (menData.lastPosX + men.width / 2) + this.width / 6 * progress;\n                    men.translateY = image.y + (menData.lastPosY + men.height) + this.height / 2 * progress;\n                    men.rotate = menData.roatedPos + 180 * progress;\n                    menData.distanceX = 0;\n                    if (progress === 1) men.opacity = 0;\n                }\n                if (menData.j === 6) {\n\n                    men.opac = men.opacity + 1 * progress;\n                }\n\n                if (men.startPos === menData.start) {\n\n                    //Constanatly updates men location on the House\n                    var lastX = menData.lastPosX + menData.distanceX * progress;\n                    var lastY = menData.lastPosY + (men.walkDown || 0);\n\n                    men.x = image.x + (menData.lastPosX + menData.distanceX * progress);\n                    men.y = image.y + (menData.lastPosY + (men.walkDown || 0));\n\n                    drawMen(men);\n\n                    if (progress < 1) {} else {\n                        //Resets or updates positions\n                        menData.lastPosX = lastX;\n                        menData.lastPosY = lastY;\n                        menData.j++;\n                        menData.begin = 0;\n                        menData.start = 0;\n                    }\n                }\n            }\n        };\n        drawHouse(image, timestamp);\n\n        requestAnimationFrame(draw);\n    }.bind(this);\n\n    document.querySelector('.animations .start-canvas').addEventListener('click', function () {\n\n        StarryNight.prototype.toggle = true;\n        requestAnimationFrame(draw);\n    }.bind(this));\n\n    document.querySelector('.animations .stop-canvas').addEventListener('click', function () {\n\n        StarryNight.prototype.toggle = false;\n    });\n}\n\nStarryNight.prototype.loadImages = function () {\n    var height = window.innerWidth < 768 ? 60 : 80;\n    var width = window.innerWidth < 768 ? 48 : 64;\n    var $this = this;\n    var count = 0;\n    var images = [];\n    var ext = isFirefox ? \"png\" : \"svg\";\n\n    var men = [{ src: \"images/men/zero.\" + ext, height: height, width: width }, { src: \"images/men/one.\" + ext, height: height, width: width }, { src: \"images/men/two.\" + ext, height: height, width: width }, { src: \"images/men/three.\" + ext, height: height, width: width }, { src: \"images/men/four.\" + ext, height: height, width: width }, { src: \"images/men/five.\" + ext, height: height, width: width }, { src: \"images/men/six.\" + ext, height: height, width: width }, { src: \"images/men/seven.\" + ext, height: height, width: width }, { src: \"images/men/eight.\" + ext, height: height, width: width }, { src: \"images/men/nine.\" + ext, height: height, width: width }, { src: \"images/men/ten.\" + ext, height: height, width: width }, { src: \"images/men/eleven.\" + ext, height: height, width: width }, { src: \"images/men/twelve.\" + ext, height: height, width: width }, { src: \"images/men/thirteen.\" + ext, height: height, width: width }, { src: \"images/men/fourteen.\" + ext, height: height, width: width }, { src: \"images/men/fifteen.\" + ext, height: height, width: width }, { src: \"images/men/headless.\" + ext, height: height, width: width }, { src: \"images/men/house-floating.\" + ext }];\n\n    for (var i = 0; i < men.length; i++) {\n\n        var img = new Image();\n\n        try {\n            throw i;\n        } catch (i) {\n            img.onload = function () {\n\n                images.push({\n                    img: this,\n                    height: men[i].height,\n                    width: men[i].width,\n                    start: 0,\n                    startPos: i\n                });\n\n                if (++count === men.length) {\n\n                    //Sorts the men array in order due to loading images differently\n                    images.sort(function (a, b) {\n                        return a.startPos - b.startPos;\n                    });\n\n                    starryNight.images = images;\n                    //updates the undefined house property with this img\n                    $this.house.houseImg = img;\n                    $this.addData();\n                    $this.house.begin();\n                }\n            };\n            img.src = men[i].src;\n        }\n    }\n};\nfunction setTechnologiesWidth(canvasWidth, svgHeight) {\n\n    var canvas = document.getElementById('techIcons');\n    if (wW < 768) canvas.style.width = canvasWidth * .90 + 'px';\n    if (wW < 540) canvas.style.width = canvasWidth * .75 + 'px';\n    canvas.style.top = svgHeight - canvas.getBoundingClientRect().height + 'px';\n}\nvar Technologies = function Technologies() {\n    var svgPageWidth = _('svg-page').getAttribute('width');\n    var svgPageHeight = _('svg-page').getAttribute('height');\n    var width = svgPageWidth < 970 || svgPageHeight < 800;\n    this.canvas = document.getElementById('techIcons');\n\n    this.ctx = this.canvas.getContext('2d');\n    this.width = this.canvas.width = svgPageWidth;\n    this.height = this.canvas.height = svgPageHeight;\n    this.start = 0;\n    this.start;\n    this.duration = 1000;\n    this.bodyData = [];\n    this.icons;\n    this.j = 0;\n    var newTechnologies = this;\n    //Sets canvas width again\n    if (wW < 768) setTechnologiesWidth(this.width, svgPageHeight);\n    this.data = {\n        addBodyData: function addBodyData() {\n\n            if (width) {\n                //Body location X and Y\n                return {\n                    x: newTechnologies.width / 2 - newTechnologies.bodyData[1].width / 2.2,\n                    y: newTechnologies.height - newTechnologies.bodyData[1].height,\n                    translateX: newTechnologies.width / 2 - newTechnologies.bodyData[3].width / 2 + 60,\n                    translateY: newTechnologies.height - newTechnologies.bodyData[1].height + 70,\n                    headX: newTechnologies.width / 2 - newTechnologies.bodyData[1].width / 2.2 + 41,\n                    headY: newTechnologies.height - newTechnologies.bodyData[1].height - 61\n                };\n            } else {\n                return {\n                    x: newTechnologies.width / 2 - newTechnologies.bodyData[1].width / 2.2,\n                    y: newTechnologies.height - newTechnologies.bodyData[1].height,\n                    //Translate head rotation\n                    translateX: newTechnologies.width / 2 - newTechnologies.bodyData[3].width / 2 + 85,\n                    //Translate head rotation\n                    translateY: newTechnologies.height - newTechnologies.bodyData[1].height + 100,\n                    headX: newTechnologies.width / 2 - newTechnologies.bodyData[1].width / 2.2 + 57,\n                    headY: newTechnologies.height - newTechnologies.bodyData[1].height - 87\n                };\n            }\n        },\n        rotate: -140,\n        j: 0,\n        bookHeight: 200\n    };\n\n    this.sprites = [];\n\n    var ext = isFirefox ? \"png\" : \"svg\";\n\n    var bodyWidth = width ? 1.3 : 1.8;\n    var bodyHeight = width ? 1.3 : 1.8;\n    var src = [\"images/top-head.\" + ext, \"images/face-body.\" + ext, \"images/book.\" + ext, \"images/full-body.\" + ext];\n\n    if (width) {\n        var imgWidth = [284.5, 400, 320.96, 400];\n        var imgHeight = [170.9, 483.7, 226.8, 564.66];\n    } else {\n        var imgWidth = [553.5, 778.2, 629.9, 778];\n        var imgHeight = [332.49, 941, 443.27, 1098.9];\n    }\n\n    this.imgIcons = [{ src: \"images/icons/adobe-50-50.\" + ext, width: 40, height: 40 }, { src: \"images/icons/after-effects-52-52.\" + ext, width: 40, height: 40 }, { src: \"images/icons/artistic-52-54.\" + ext, width: 40, height: 42 }, { src: \"images/icons/bootstrap-50-50.\" + ext, width: 40, height: 40 }, { src: \"images/icons/camera-52-52.\" + ext, width: 40, height: 40 }, { src: \"images/icons/cloud-64-49.5.\" + ext, width: 42, height: 32.5 }, { src: \"images/icons/code-60-53.\" + ext, width: 43, height: 38 }, { src: \"images/icons/css-55-52.\" + ext, width: 42, height: 39.8 }, { src: \"images/icons/design-52-52.\" + ext, width: 40, height: 40 }, { src: \"images/icons/git-hub-55-55.\" + ext, width: 43, height: 43 }, { src: \"images/icons/google-drive-72-64.\" + ext, width: 46, height: 40.8 }, { src: \"images/icons/illustrator-52-52.\" + ext, width: 40, height: 40 }, { src: \"images/icons/js-55-56.\" + ext, width: 41, height: 42 }, { src: \"images/icons/node-50-50.\" + ext, width: 40, height: 40 }, { src: \"images/icons/nodejs-60.5-37.\" + ext, width: 55, height: 33.6 }, { src: \"images/icons/npm-70-27.2.\" + ext, width: 65, height: 25.2 }, { src: \"images/icons/photoshop-52-52.\" + ext, width: 40, height: 40 }, { src: \"images/icons/php-65-35.\" + ext, width: 45, height: 24.2 }, { src: \"images/icons/python-57-58.\" + ext, width: 40, height: 40.7 }, { src: \"images/icons/react-59-52.\" + ext, width: 42, height: 37 }, { src: \"images/icons/server-55-58.\" + ext, width: 40, height: 40 }];\n\n    this.loopImgs = function () {\n        var load = [];\n\n        for (var j = 0; j < 4; j++) {\n            load.push({\n                src: src[j],\n                width: imgWidth[j] / bodyWidth,\n                height: imgHeight[j] / bodyHeight\n            });\n        }\n        var icons = this.imgIcons;\n\n        for (var i = 0; i < icons.length; i++) {\n            var w = !width ? icons[i].src.replace(/^([a-z\\/]+)\\/([a-z-?]+)-(\\d\\d)(.+)/ig, \"$3\") : icons[i].width;\n            var h = !width ? icons[i].src.replace(/^(.+)(\\d{2})(.+)/ig, \"$2\") : icons[i].height;\n\n            load.push({\n                src: icons[i].src,\n                width: parseInt(w),\n                height: parseInt(h)\n            });\n        }\n        return load;\n    };\n    function random(min, max) {\n        return Math.floor(Math.random() * (max - min) + min);\n    };\n    this.addData = function (n) {\n        var icons = this.icons;\n        for (var i = 0; i < n; i++) {\n\n            this.sprites.push({\n                //Each icon draws for ever 30 mil sec\n                timing: 30,\n                endX: random(0, this.width / 2),\n                endY: random(0, this.height - (this.bodyData[1].height + 50)),\n                start: 0,\n                speed: random(4000, 9000),\n                x: this.width / 2,\n                y: this.data.addBodyData().y + 15, // plus 100 the sprite size\n                img: this.icons[i % icons.length].img,\n                width: this.icons[i % icons.length].width,\n                height: this.icons[i % icons.length].height,\n                X: 0,\n                Y: 0,\n                staticSpeed: 0,\n                rotate: random(180, 1440)\n            });\n        }\n    };\n};\n\nTechnologies.prototype.rotateHead = function (rotate, pos) {\n    var img = this.bodyData;\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.ctx.drawImage(img[1].img, pos.x, pos.y, img[1].width, img[1].height); //Face body\n    this.ctx.translate(pos.translateX, pos.translateY); // Translate \n    this.ctx.rotate(rotate * Math.PI / 180);\n    this.ctx.translate(-pos.translateX, -pos.translateY); // Translate back\n    this.ctx.drawImage(img[0].img, pos.headX, pos.headY, img[0].width, img[0].height); //Head draw in translated canves\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n};\n\nTechnologies.prototype.drawBook = function (data, pos) {\n    var img = this.bodyData;\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.ctx.globalCompositeOperation = 'destination-over';\n    this.ctx.drawImage(img[1].img, pos.x, pos.y, img[1].width, img[1].height); //Face body\n    this.ctx.translate(pos.translateX, pos.translateY); // Translate \n    this.ctx.rotate(-140 * Math.PI / 180);\n    this.ctx.translate(-pos.translateX, -pos.translateY); // Translate back\n    this.ctx.drawImage(img[0].img, pos.headX, pos.headY, img[0].width, img[0].height); //Head draw in translated canves\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n    this.ctx.translate(pos.translateX + img[2].width / 2, pos.translateY); // Translate  \n    this.ctx.scale(data.scale, data.scale); //Scales book\n    this.ctx.translate(-pos.translateX - img[2].width / 2, -pos.translateY); // Translate back for\n    this.ctx.drawImage(img[2].img, data.bookX, data.bookY, img[2].width, img[2].height); //book image\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n};\n\nTechnologies.prototype.drawBody = function (data, pos) {\n    var img = this.bodyData;\n\n    this.ctx.drawImage(img[1].img, pos.x, pos.y, img[1].width, img[1].height); //Face body\n    this.ctx.translate(pos.translateX, pos.translateY); // Translate \n    this.ctx.rotate(-140 * Math.PI / 180);\n    this.ctx.translate(-pos.translateX, -pos.translateY); // Translate back\n    this.ctx.drawImage(img[0].img, pos.headX, pos.headY, img[0].width, img[0].height); //Head draw in translated canves\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.translate(pos.translateX + img[2].width / 2, pos.translateY); // Translate  \n    this.ctx.scale(1.05, 1.05);\n    this.ctx.translate(-pos.translateX - img[2].width / 2, -pos.translateY); // Translate back\n    this.ctx.drawImage(img[2].img, data.bookX, data.bookY, img[2].width, img[2].height); //book image\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n};\n\nTechnologies.prototype.drawIcons = function (spr) {\n    this.ctx.setTransform(1, 0, 0, 1, spr.X, spr.Y);\n    this.ctx.rotate(spr.turn * Math.PI / 180);\n    this.ctx.drawImage(spr.img, -spr.width / 2, -spr.height / 2, spr.width, spr.height);\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n};\n\nTechnologies.prototype.draw = function (timestamp) {\n    if (!this.toggle) return;\n    var width = this.width < 970 || this.height < 800;\n    var img = this.bodyData;\n    var data = this.data;\n    var pos = data.addBodyData();\n\n    if (!this.start) this.start = timestamp;\n    var runtime = timestamp - this.start;\n    var progress = Math.min(runtime / 1000, 1);\n\n    if (progress < 1 && data.j <= 1) {\n\n        if (width) {\n            //Updates x loactions and y location of book\n            data.bookX = pos.translateX - 40 - 0;\n            data.bookY = pos.translateY - 110 - 60 * progress;\n        } else {\n            //Updates x loactions and y location of book\n            data.bookX = pos.translateX - 60 - 0;\n            data.bookY = pos.translateY - 180 - 60 * progress;\n        }\n        //Rotate head\n        if (data.j === 0) {\n\n            var rotate = data.rotate * progress;\n            this.rotateHead(rotate, pos);\n        }\n        //Push up book\n        if (data.j === 1) {\n            // this.duration = 500\n            console.log('ran book');\n            data.scale = .5 + .55 * progress;\n            this.drawBook(data, pos);\n        }\n    } else {\n\n        //Draw Icons\n        if (data.j === 2) {\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            this.drawBody(data, pos);\n\n            var sprites = this.sprites.length;\n\n            for (var i = 0; i < sprites; i++) {\n\n                var spr = this.sprites[i];\n\n                if (i <= this.j) {\n\n                    spr.staticSpeed++;\n\n                    if (!spr.start) spr.start = timestamp;\n                    var run = timestamp - spr.start;\n                    var prog = run / spr.speed;\n\n                    if (i % 2) {\n                        //left up\n                        spr.X = spr.x - spr.endX * prog;\n                        spr.Y = spr.y - spr.endY * prog;\n                        spr.turn = -spr.rotate * prog;\n                    } else {\n                        //right up;\n                        spr.X = spr.x + spr.endX * prog;\n                        spr.Y = spr.y - spr.endY * prog;\n                        spr.turn = spr.rotate * prog;\n                    }\n\n                    spr.totalX = spr.X;\n                    spr.totalY = spr.Y;\n\n                    if (spr.totalX + spr.width <= 0 || spr.totalY + spr.height <= 0 || spr.totalX > this.width + spr.width) {\n\n                        //Resets values, for same icon to run again\n                        this.sprites[i].start = 0;\n                    }\n                    this.drawIcons(spr);\n                    if (spr.staticSpeed === spr.timing) this.j++;\n                }\n            }\n        } else {\n            this.start = 0;\n            data.j++;\n        }\n    }\n    requestAnimationFrame(this.draw.bind(this));\n};\n\nTechnologies.prototype.loadImages = function () {\n    var $this = this;\n    var counter = 0;\n    var loadedImages = 0;\n    var imgs = [];\n\n    this.loopImgs().forEach(function (image, i) {\n        counter++;\n        var img = new Image();\n\n        img.onload = function () {\n\n            //Width or height doesn't exist updates 0 for it\n            imgs.push({ img: this, i: i, width: image.width, height: image.height });\n\n            if (++loadedImages >= counter) {\n                imgs.sort(function (a, b) {\n                    return a.i - b.i;\n                });\n                //When Icons load full body image gets added\n                $this.ctx.drawImage(imgs[3].img, $this.width / 2 - imgs[1].width / 2.2, $this.height - imgs[3].height, imgs[3].width, imgs[3].height); //Full-body image\n\n                var bodyImgs = imgs.splice(0, 4);\n\n                $this.bodyData = bodyImgs;\n                $this.icons = imgs;\n\n                //Icon data\n                $this.addData(imgs.length);\n            }\n        };\n        img.src = image.src;\n    });\n};\n\nfunction SvgPage() {\n    var svgCloseButton = document.getElementsByClassName('close-btn svg-button')[0];\n    var svgCircle = document.getElementsByClassName('svg-circle')[0];\n    var toggle, btnOpen;\n    var hovermap = hoverMap();\n\n    var removeGooey = function removeGooey(e) {\n        setTimeout(function () {\n            hovermap[1](e);\n        }, 1400);\n\n        //     var dist = hovermap[1](e)[0]; // Position distance of show-icon gooey\n        //     hovermap[0]( dist, true )  // handler(e) function\n    };\n    this.start;\n    //Page animated down removes circle to be animated again\n    this.animateEnd = function (e) {\n        _('interactive-container').style.pointerEvents = 'auto';\n\n        if (toggle) {\n            //Safari only\n            _('svg-page').style.visibility = 'hidden';\n            svgCircle.classList.remove('circle-animate');\n\n            _(btnOpen)[0].style.display = 'none';\n            document.querySelector('g.' + btnOpen + ' .items').classList.remove('items-active');\n\n            toggle = false;\n        }\n    };\n\n    this.animateCircle = function (timestamp, elem) {\n\n        if (!this.start) this.start = timestamp;\n\n        var runtime = timestamp - this.start;\n        var progress = Math.min(runtime / this.speed, 1);\n        isFirefox ? svgCircle.setAttribute('r', 1500 * progress) : svgCircle.style.transform = 'scale(' + (0 + 1 * progress) + ')';\n\n        if (progress < 1) {\n            requestAnimationFrame(function (timestamp) {\n                this.animateCircle(timestamp, elem);\n            }.bind(this));\n        } else {\n            //Canvas fades in after page is animated open\n            document.querySelector('g.' + elem + ' .items').classList.add('items-active');\n            document.getElementsByClassName(elem)[1].parentElement.classList.add('showCanvas');\n            this.start = null;\n        }\n    };\n    var closeButtonShow = function closeButtonShow(num) {\n        var opposite = !num ? -56 : 0;\n        _('x-circle').style.transform = 'translateX(' + num + 'px)';\n        _('line')[0].style.transform = 'translateX(' + opposite + 'px) rotate(-45deg)';\n        _('line')[1].style.transform = 'translateX(' + opposite + 'px) rotate(45deg)';\n    };\n\n    // Open page function\n    this.openModals = function (e) {\n\n        try {\n            btnOpen = e.target.id;\n        } catch (err) {\n            btnOpen = e;\n        }\n\n        _('interactive-container').style.pointerEvents = 'none';\n        event = e;\n        _(btnOpen)[0].style.display = 'block';\n        closeButtonShow(-56);\n        //Google 'Do Hyeon' font bug, function has to be ran again in view\n        if (btnOpen === 'photo') slotMachine();\n        //Throbbing Finger image icon\n        if (btnOpen === 'design') document.getElementById('finger').classList.add('finger-scale');\n\n        if (isSafari) {\n\n            toggle = true;\n            _('svg-page').style.visibility = \"visible\";\n            svgCircle.classList.add('circle-animate');\n\n            svgCircle.onanimationend = function () {\n\n                document.querySelector('g.' + btnOpen + ' .items').classList.add('items-active');\n                document.getElementsByClassName(btnOpen)[1].parentElement.classList.add('showCanvas');\n            };\n\n            //Closes the page animated down\n            svgCloseButton.addEventListener('click', function () {\n                toggle = true;\n\n                //Automatically stops canvas \n                Stretch.prototype.toggle = false;\n                slotMachine.prototype.toggle = false;\n                StarryNight.prototype.toggle = false;\n                Technologies.prototype.toggle = false;\n\n                //Canvas / Items fades out\n                document.getElementsByClassName(btnOpen)[1].parentElement.classList.remove('showCanvas');\n            });\n        } else {\n            toggle = false;\n\n            requestAnimationFrame(function (timestamp) {\n                this.speed = 600;\n                this.animateCircle(timestamp, btnOpen);\n            }.bind(this));\n\n            svgCloseButton.addEventListener('click', function (e) {\n                closeButtonShow(0);\n                Stretch.prototype.toggle = false;\n                slotMachine.prototype.toggle = false;\n                StarryNight.prototype.toggle = false;\n                Technologies.prototype.toggle = false;\n                document.getElementsByClassName(btnOpen)[1].parentElement.classList.remove('showCanvas');\n\n                setTimeout(function () {\n                    isFirefox ? _('svg-circle').setAttribute('r', 0) : _('svg-circle').style.transform = 'scale(0)';\n\n                    //Current SVG element hides\n                    document.getElementsByClassName(btnOpen)[0].style.display = 'none';\n                    document.querySelector('g.' + btnOpen + ' .items').classList.remove('showCanvas');\n                    // document.getElementsByClassName(btnOpen)[1].parentElement.classList.remove('showCanvas')\n                }, 1100);\n            });\n        }\n    }.bind(this);\n\n    var popUpCards = function () {\n        var open_modals = this.openModals;\n\n        var popUpcards = _('card-popups');\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = popUpcards[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var cards = _step.value;\n\n                cards.addEventListener('click', function (e) {\n                    removeGooey(e);\n                    open_modals(this.attributes[3].value);\n                });\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    }.bind(this);\n    if (wW < 768) popUpCards();\n\n    _('circle-thumbnails').addEventListener('click', function (e) {\n        if (wW < 768) {\n            hovermap[1](e);\n        } else {\n            removeGooey(e);\n            this.openModals(e);\n        }\n    }.bind(this));\n};\n//Add to window object to be used for html page onend function\nwindow.svgPage = new SvgPage();\n\nfunction getPos(ele) {\n\n    var elemRect = ele.getBoundingClientRect();\n    var mainSvg = document.getElementsByClassName('svg-page')[0].getBoundingClientRect();\n    var elemLeft = (mainSvg.width - (parseInt(ele.getAttribute('width')) || elemRect.width)) / 2;\n\n    return {\n        width: elemRect.width,\n        mainSvg: mainSvg,\n        left: elemRect.left,\n        top: elemRect.top,\n        height: elemRect.height,\n        //Places image's property left to the center of it's container (center of page)\n        centeredLeft: elemLeft\n    };\n};\nfunction adjustButton() {\n    _('line')[0].setAttribute('width', '35');\n    _('line')[0].setAttribute('x', '10.5');\n    _('line')[0].setAttribute('y', '25');\n    _('line')[1].setAttribute('width', '35');\n    _('line')[1].setAttribute('x', '10.5');\n    _('line')[1].setAttribute('y', '25');\n    _('x-circle').setAttribute('r', '22');\n}\n\n//Different screen sizing , elements adjust to it\nfunction adjustElements() {\n    var pathD768 = \"M565.1,0v900H0c0,0,0-75.3,0-192.4c0-211.7,0-303.7,0-533.1C0,50.5,0,0,0,0H565.1z\";\n    var pathD400 = \"M390,800H0c0,0,0-87.3,0-161.3S0,84,0,47.3S0,0,0,0h390V800z\";\n    var smallSplines = \".42 0 1 1;.42 0 1 1;.42 0 1 1;.42 0 1 1;\";\n    var smallKeyTimes = \"0; 0.20; 0.45; 1\";\n    var svg = document.getElementsByClassName('svg-page')[0];\n\n    //Sets sizing for opening closing svg-page wave\n    if (wH < 840 && wW) {\n        var svgWidth = wW < 500 ? wW - 20 : wW - 50;\n        var svgHeight = wH < 680 ? wH - 15 : wH - 50;\n    } else {\n        var svgWidth = wW < 500 ? wW - 20 : wW - 50;\n        var svgHeight = 840;\n    }\n\n    if (wW <= 615) {\n        adjustButton();\n        document.getElementById('path').setAttribute('d', pathD768);\n        _('path').setAttribute('values', animate768);\n        _('path').setAttribute('keyTimes', smallKeyTimes);\n        _('path').setAttribute('keySplines', smallSplines);\n    }\n\n    if (wW <= 400) {\n        document.getElementById('path').setAttribute('d', pathD400);\n        _('path').setAttribute('values', animate400);\n    }\n\n    if (wW >= 970 && wH) {\n\n        svg.setAttribute(\"height\", svgHeight);\n    } else {\n        if (wH > 840) {\n            svg.setAttribute(\"viewBox\", \"0 0 \" + \" \" + svgWidth + \" \" + svgHeight);\n            svg.setAttribute(\"width\", svgWidth);\n            svg.setAttribute(\"height\", svgHeight);\n        }\n        if (wH < 840) {\n            svg.setAttribute(\"viewBox\", \"0 0 \" + \" \" + svgWidth + \" \" + svgHeight);\n            svg.setAttribute(\"width\", svgWidth);\n            svg.setAttribute(\"height\", svgHeight);\n        }\n    }\n\n    if (wW && wH) {\n\n        //Add to element when more canvases are added to HTML\n        var elementG = document.querySelectorAll('g.photo, g.developer, g.design, g.animations, g.technologies');\n\n        elementG.forEach(function (el, i) {\n            var groupName = el.classList[0];\n\n            if (groupName === 'photo') {\n\n                document.getElementById('canvas-area').setAttribute('transform', 'translate(157, 0)');\n\n                Array.prototype.forEach.call(el.children, function (elem, i) {\n\n                    //Camera SVG\n                    if (i === 0) {\n\n                        var newHeight = newSize('width', 700, elem).height;\n\n                        elem.setAttribute('width', 700);\n                        elem.setAttribute('height', newHeight);\n\n                        var _pos = getPos(elem);\n                        var setAttributeY = _pos.mainSvg.height - newHeight - 5;\n\n                        elem.setAttribute('x', _pos.centeredLeft);\n                        elem.setAttribute('y', setAttributeY);\n\n                        if (wW <= 500 || wH <= 800) {\n\n                            elem.style.visibility = 'hidden';\n                        }\n                    }\n                    //ForeignObject holds canvas\n                    if (i === 2) {\n\n                        if (wW < 970) {\n                            var canvasArea = document.getElementById('canvas-area');\n\n                            var _pos2 = getPos(canvasArea);\n\n                            if (wH < 640 && wW < 800) {\n\n                                elem.setAttribute('y', 240);\n                            } else {\n\n                                //firefox\n                                !isFirefox ? elem.setAttribute('y', svg.getAttribute('height') - _pos2.height - 16) : svg.getAttribute('width') / 2 - 397.6 / 2;\n                                elem.setAttribute('y', svg.getAttribute('height') - 397.6 - 16);\n                                // elem.setAttribute('y', 250)\n                            }\n\n                            elem.setAttribute('width', 360);\n                            elem.setAttribute('height', 360);\n                            !isFirefox ? elem.setAttribute('x', _pos2.left - 6) : elem.setAttribute('x', svg.getAttribute('width') / 2 - 397.6 / 2 + 20);\n                            // elem.setAttribute('y', svg.getAttribute('height') - pos.height - 16)\n                        } else {\n                            var posHeight = getPos(elem);\n                            var width = parseInt(elem.getAttribute('width'));\n                            var elemLeft = posHeight.mainSvg.width - width - 15;\n\n                            elem.setAttribute('y', 60);\n                            elem.setAttribute('x', elemLeft);\n                        }\n\n                        if (wW <= 500) {\n                            var _thisPos = getPos(elem);\n                            elem.setAttribute('x', _thisPos.centeredLeft);\n\n                            if (wH < 620) {\n                                elem.setAttribute('y', 200);\n                            }\n                        }\n                    }\n                    //Items\n                    if (i === 1) {\n                        var pos = getPos(document.getElementById('canvas-area'));\n\n                        elem.childNodes[1].setAttribute('width', 400);\n                        elem.childNodes[1].setAttribute('height', 235);\n                        elem.childNodes[1].setAttribute('x', 20);\n                        if (wW < 970) {\n                            elem.childNodes[1].setAttribute('y', 0);\n                        } else {\n                            elem.childNodes[1].setAttribute('y', 100);\n                        }\n                        if (window.innerWidth <= 500) {\n                            elem.childNodes[1].setAttribute('width', 335);\n                            elem.childNodes[1].setAttribute('x', 10);\n                            var thisPos = getPos(elem.childNodes[1]);\n                        }\n                    }\n                });\n            };\n            if (groupName === 'developer') {\n                Array.prototype.forEach.call(el.children, function (elem, i) {\n\n                    //foreignObject holds canvas\n                    if (i === 1) {\n                        if (wW < 970) {\n                            elem.setAttribute('width', 400);\n                            elem.setAttribute('height', 375);\n                        }\n                        var pos = getPos(el.children[0]);\n                        elem.setAttribute('y', 200);\n\n                        if (window.innerWidth <= 850) {\n                            if (wH < 690) {\n                                elem.setAttribute('y', 25);\n                                elem.setAttribute('x', 5);\n                            } else {\n                                elem.setAttribute('x', 50);\n                                elem.setAttribute('y', 75);\n                            }\n                        }\n                        if (window.innerWidth < 505) {\n                            if (wH < 690) {\n                                elem.setAttribute('y', 50);\n                                elem.setAttribute('x', 0);\n                            }\n                            elem.childNodes[1].setAttribute('width', 360);\n                            elem.setAttribute('height', 375);\n\n                            var thisPos = getPos(elem.childNodes[1]);\n                            elem.setAttribute('y', 50);\n                            elem.setAttribute('x', 5);\n                        }\n                    }\n                    //items\n                    if (i === 0) {\n                        if (window.innerWidth < 505) {\n                            elem.childNodes[1].setAttribute('x', 10);\n                            elem.childNodes[1].setAttribute('y', 424);\n                            elem.childNodes[1].setAttribute('width', 370);\n                        }\n                        if (wW > 505 && wW < 850) {\n                            if (wH < 690) {\n                                elem.childNodes[1].setAttribute('y', 425);\n                                elem.childNodes[1].setAttribute('width', 370);\n                            } else elem.childNodes[1].setAttribute('y', 460);\n                        }\n                    }\n                });\n            }\n            if (groupName === 'design') {\n                var items = el.children[0].children[0];\n                var canvasArea = el.children[1];\n\n                if (wH && wW > 970) {\n\n                    if (canvasArea) {\n                        if (wW > 1200) {\n                            canvasArea.setAttribute('width', 580);\n                            canvasArea.setAttribute('height', 580);\n                        }\n                        canvasArea.setAttribute('y', 80);\n                    }\n                    if (items) {\n                        items.setAttribute('y', 200);\n                    }\n                } else if (wW > 750 && wW < 970) {\n\n                    if (canvasArea) {\n                        //For Safari overflow not working\n                        wW < 810 ? canvasArea.setAttribute('x', 210) : canvasArea.setAttribute('x', 255);\n                        canvasArea.setAttribute('y', 160);\n                        if (wH < 703) {\n                            //For Safari overflow not working\n                            canvasArea.setAttribute('height', 450);\n                        }\n                    }\n                    if (items) {\n                        items.setAttribute('y', 0);\n                    }\n                } else {\n                    items.setAttribute('y', 0);\n                    items.setAttribute('x', 10);\n                    wH < 700 ? items.setAttribute('height', 250) : items.setAttribute('height', 260);\n                    items.setAttribute('width', 340);\n\n                    var height = items.getAttribute('height');\n                    canvasArea.setAttribute('y', height);\n\n                    wW < 600 ? canvasArea.setAttribute('width', 400) : canvasArea.setAttribute('width', 500);\n                    wW < 600 ? canvasArea.setAttribute('height', 400) : canvasArea.setAttribute('height', 500);\n\n                    var canvasPos = getPos(canvasArea);\n                    canvasArea.setAttribute('x', canvasPos.centeredLeft);\n                    //For safari, so photo doesn't show the overflow\n                    canvasArea.setAttribute('height', svg.getAttribute('height') - items.getAttribute('height'));\n                }\n            }\n            if (groupName === 'animations') {\n                var items = el.children[0].children[0];\n                var canvasArea = el.children[1];\n                var svgPageHeight = svg.getAttribute('height');\n\n                if (wH && wW > 970) {\n                    canvasArea.setAttribute('height', svgPageHeight);\n                }\n                if (wW < 768) {\n                    var _bottom = (svg.getAttribute('height') - 310) / 2;\n                    items.setAttribute('x', 15);\n                    items.setAttribute('y', _bottom);\n                    items.setAttribute('height', 320);\n                    items.setAttribute('width', 370);\n                } else {\n                    canvasArea.setAttribute('height', svgPageHeight);\n                }\n            }\n            if (groupName === 'technologies') {\n                var items = el.children[0].children[0];\n                var canvasArea = el.children[1];\n\n                if (wW < 650 && wH < 655) {\n                    var bottom = (svg.getAttribute('height') - 370) / 2;\n                    items.setAttribute('y', bottom);\n                    items.setAttribute('x', 5);\n                }\n            }\n        });\n    }\n};\n\nif (wW < 970 || wH < 800) {\n    adjustElements();\n} else {\n    //Adds margin between full height threshhold for svg-page\n    if (wH < 840) {\n        _('svg-page').setAttribute('height', wH - 40);\n    }\n    if (wW < 1000) {\n        _('svg-page').setAttribute('width', wW - 40);\n    }\n    var designCanvas = document.querySelector('.design .item-canvas');\n    designCanvas.setAttribute('width', 580);\n    designCanvas.setAttribute('height', 580);\n}\n\n//Moves close button to right of svg-page\nfunction placeCloseButton() {\n\n    var btnPos = getPos(_('close-btn'));\n    _('close-btn').style.transform = 'translateX(' + (btnPos.mainSvg.width - 56) + 'px)';\n}\nplaceCloseButton();\n\nfunction hoverMap() {\n    var btnWrap = _('button-wrap');\n    var dist;\n    var lastDist;\n    var currentPath; //Path to be removed when mouseout\n\n    var mouseOut = function mouseOut(dist) {\n        // dist from opening popups to remove pointer\n        var pointerDist = typeof dist === 'number' ? dist : lastDist;\n\n        _('oval-pointer').style.transform = 'translate(-80px, 0px )';\n\n        if (isFirefox) {\n\n            _('show-icon').style.transform = 'translate(-24px,' + pointerDist + 'px )';\n        } else if (isSafari) {\n\n            _('show-icon').style.transform = 'translate(-24px,' + pointerDist + 'px )';\n        } else {\n\n            _('show-icon').style.transform = 'translate(-22px,' + pointerDist + 'px )';\n        }\n    };\n\n    if (wW > 768) btnWrap.onmouseover = handler;\n\n    function handler(e) {\n        dist = getDistance(e.target.className, e.target.id);\n\n        function getDistance(el, id) {\n            var totalDist = function totalDist(n) {\n                return n * 37;\n            };\n            var nodelist = _(el);\n            var elArray = [].slice.call(nodelist);\n\n            for (var i = 0; i < elArray.length; i++) {\n                if (elArray[i].id == id) return totalDist(i);\n            }\n        }\n\n        function getPathElement(el, map_paths) {\n            var newPathArray = [];\n            var pathArray = [].slice.call(map_paths);\n\n            //Puts elements in correct order\n            for (var i = pathArray.length - 1; i >= 0; i--) {\n                newPathArray.push(pathArray[i]);\n            }\n\n            var target = document.getElementById(el);\n            var targetArray = [].slice.call(_(target.className));\n\n            for (var i = 0; i < targetArray.length; i++) {\n                if (targetArray[i] === target) return newPathArray[i];\n            }\n        };\n\n        var animateGooey = function animateGooey() {\n\n            if (!_('show-icon').classList.contains('icon-transition')) {\n\n                // transforms only up and down before out.\n                _('show-icon').style.transform = 'translate(-22px,' + dist + 'px )';\n\n                setTimeout(function () {\n                    _('show-icon').classList.add('icon-transition');\n                    _('show-icon').style.transform = 'translate(-15px,' + dist + 'px )';\n                    _('oval-pointer').style.transform = 'translate(0px, 0px )';\n                }, 100);\n            } else {\n                _('show-icon').style.transform = 'translate(-15px,' + dist + 'px )';\n                _('oval-pointer').style.transform = 'translate(0px, 0px )';\n            }\n        };\n\n        var animatePathLines = function animatePathLines(path, map_paths) {\n            var classId = path.id.replace(/-sm$/ig, \"\");\n\n            for (var i = 0; i < map_paths.length; i++) {\n                //Removes all classes before target element class gets added\n                if (map_paths[i].classList.length === 2) {\n\n                    var className = map_paths[i].classList[1];\n                    map_paths[i].classList.remove(className);\n                }\n            }\n            path.classList.add(classId);\n            return classId;\n        };\n\n        var removeCardsClass = function removeCardsClass(target) {\n\n            var card = _('card-icon');\n            var length = card.length;\n\n            while (length--) {\n                var styleTransform = +card[length].style.transform.replace(/([^-\\d])/ig, '');\n                if (styleTransform !== 0) card[length].style.transform = 'translateY(0px)';\n            }\n        };\n        var animateCardsUp = function animateCardsUp(path) {\n\n            var card = _('card-icon');\n            var regEx = /-.+$/ig;\n            var target = path.id.replace(regEx, '');\n            var length = card.length;\n\n            //If target also has 2 classList, remove that class and add p0opupcard\n            while (length--) {\n                var cardParent = card[length].parentNode;\n                var styleTransform = +card[length].style.transform.replace(/([^-\\d])/ig, '');\n\n                if (target === cardParent.id.replace(regEx, '')) {\n                    // card[length].style.transform = 'translateY(-140px)'\n\n                    card[length].style.transform = 'translateY(-140px)';\n                } else if (styleTransform !== 0) {\n                    card[length].style.transform = 'translateY(0px)';\n                }\n            }\n        };\n\n        function AnimateCircles(path, map_paths) {\n\n            var circles = document.querySelectorAll('#pulse-circles circle');\n            var paths = [];\n            //Removes all classes before target elements classes gets added\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = circles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var cir = _step2.value;\n\n                    if (cir.classList.length > 1) {\n                        cir.classList.remove(cir.classList[1]);\n                    }\n                }\n                //Stops before error when not passing arguments from click handler\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            if (!arguments.length) return;\n\n            //Pairs circles and returns the pairs so classes can be added\n            var pairCircles = function pairCircles() {\n                var cir = [];\n                for (var j = 0; j < circles.length; j += 2) {\n\n                    cir.push([circles[j], circles[j + 1]]);\n                }\n                return cir;\n            };\n\n            for (var i = 0; i < map_paths.length; i++) {\n\n                paths.unshift(map_paths[i].id);\n            }\n\n            var index = paths.indexOf(path.id);\n            var cirPairs = pairCircles()[index];\n\n            cirPairs[0].classList.add('middle-pulse');\n            cirPairs[1].classList.add('ring-pulse');\n        };\n\n        var removeCircles = function removeCircles(string) {\n            var activeCircles = document.querySelectorAll('.middle-pulse, .ring-pulse');\n\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = activeCircles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var cir = _step3.value;\n\n\n                    cir.addEventListener('animationend', function (e) {\n\n                        e.target.classList.remove(e.target.classList[1]);\n                    });\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n        };\n        function removeAll(string) {\n            removeCircles(string);\n            mouseOut(dist);\n            removeCardsClass();\n            try {\n                //Path to be removed when mouseout\n                document.getElementById(currentPath).classList.remove(currentPath);\n            } catch (err) {}\n        }\n        function handleMap(e) {\n            var target = e.target.classList.value;\n\n            //If click comes from opening svg modals\n            if (target === 'card-color-st39' || wW > 768 && e.type === 'click') {\n\n                return removeAll(path);\n            }\n            // mouse over\n            if (e.target.id) {\n                //Start the path animated lines\n                var map_paths = wW > 768 ? _('map-paths') : _('map-paths-sm');\n                var path = getPathElement(e.target.id, map_paths);\n\n                //Used to update translate for button location\n                lastDist = dist;\n\n                animateGooey();\n                currentPath = animatePathLines(path, map_paths);\n                AnimateCircles(path, map_paths);\n                animateCardsUp(path);\n\n                //Only runs after mouseover elements run first, then initiated. \n                _('interactive-container').onmouseover = function (e) {\n                    if (e.target.className !== 'open-canvas-page' && wW > 768) {\n\n                        removeAll();\n                    }\n                };\n            }\n        }\n\n        if (e.type == 'mouseover' && wW > 768) {\n            handleMap(e);\n        } else if (e.type === 'click') {\n\n            handleMap(e);\n        }\n        return [dist];\n    }\n    return [mouseOut, handler]; // To be able to use mouseOut function and handler function that returns dist to use for mouseOut Func\n};\n\nvar toggleStars = {\n    toggle: false\n};\n\nvar robotSection = function robotSection(e) {\n\n    var stars = [];\n    var animateStars = function animateStars() {\n\n        var canvas = document.getElementById('star-canvas');\n        var ctx = canvas.getContext('2d');\n        var width = canvas.width = window.innerWidth;\n        var height = canvas.height = window.innerHeight;\n\n        var randomWidth = function randomWidth() {\n            //max and min\n            return Math.random() * (width / 2 - width / 9) + width / 9;\n        };\n\n        var NightStars = function NightStars() {\n            var _this3 = this;\n\n            var randomStart = randomWidth();\n\n            this.duration = 2000; //used to delay stars\n            this.radius = 13 + Math.random() * 5; //size of stars\n\n            this.i = 0; //x and y speed\n            this.k = 0; //opacity speed\n\n            this.start = {\n                y: Math.random() * height\n            };\n\n            this.Flicker = function (increntment) {\n                return Math.cos(increntment - Math.PI / 180) * .2;\n            };\n\n            this.radSize = function (increntment) {\n                return Math.sin(increntment - Math.PI / 180) * 7;\n            };\n\n            this.x = function (increntment, starSize) {\n                //full screen animate change this.randomWidth back to width / 2\n                return Math.cos(increntment - Math.PI / 180) * (randomStart + starSize);\n            };\n\n            this.y = function (increntment) {\n                return Math.sin(-increntment - Math.PI / 180) * 160;\n            };\n\n            this.draw = function (ctx) {\n                var s = _this3;\n\n                var opacSpeed = s.k += .3;\n                var speed = s.i += s.randomSpeed;\n\n                var radSize = s.radSize(speed);\n                var flicker = s.Flicker(opacSpeed);\n\n                var y = s.y(speed);\n                var x = s.x(speed, s.radius);\n\n                ctx.translate(width / 2, s.start.y);\n                var gradient = ctx.createRadialGradient(x, y, .4, x, y, 14);\n\n                gradient.addColorStop(0, 'LightSkyBlue');\n                gradient.addColorStop(.9, 'DodgerBlue');\n                gradient.addColorStop(1, 'RoyalBlue');\n\n                ctx.beginPath();\n                ctx.arc(x, y, s.radius - radSize - flicker, 0, Math.PI * 2);\n                ctx.fillStyle = gradient;\n                ctx.fill();\n\n                ctx.translate(-width / 2, -s.start.y);\n            };\n        };\n\n        function createStars(starCount, update) {\n            var delay = 0;\n\n            for (var i = 0; i < starCount; i++) {\n                delay += Math.random() * width;\n\n                var nightStars = new NightStars();\n                nightStars.randomSpeed = .001 + Math.random() * .006;\n                nightStars.startTime = Date.now();\n                nightStars.duration += delay; //sets a random delay for stars to start\n                stars.push(nightStars);\n            }\n            update();\n        }\n\n        function update() {\n            //Stopping stars\n            if (toggleStars.toggle) {\n                stars.length = 0;\n                ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n                return;\n            }\n\n            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n\n            var all = stars.length;\n            for (var i = 0; i < all; i++) {\n                // let percent = Math.min( ( Date.now() - stars[i].startTime ) / stars[i].duration, 1 )  //Delay to start stars\n                var percent = Math.min(Date.now() - stars[i].startTime, 1); // No delay\n\n                if (percent === 1) {\n                    stars[i].draw(ctx);\n                }\n            }\n            requestAnimationFrame(update);\n        }\n\n        return {\n            createStars: createStars,\n            update: update\n        };\n    };\n\n    var updateText = function () {\n\n        var toggle = true;\n        var textField = _('text-field');\n\n        function changeToggle(boolean) {\n            toggle = boolean;\n        }\n        return {\n            toggleFalse: function toggleFalse() {\n                changeToggle(false);\n            },\n            updateImgText: function updateImgText(img) {\n\n                changeToggle(true);\n\n                var imgText = img.getAttribute('data-target');\n                var textLength = imgText.length;\n\n                for (var i = 0; i < textLength; i++) {\n\n                    (function (i) {\n                        setTimeout(function () {\n\n                            if (!toggle) return;\n\n                            textField.textContent += imgText[i];\n                        }, 100 * i);\n                    })(i);\n                }\n            }\n        };\n    }();\n\n    function electricBox() {\n        var randomCir = [0, 1, 2, 3, 4, 5];\n\n        function getRandom(num) {\n            return Math.floor(Math.random() * Math.floor(num));\n        }\n        function findNum(item) {\n\n            var newNum = randomCir.splice(item, 1);\n\n            _('robot-st34')[newNum].classList.add('blink');\n            if (randomCir.length) {\n                relay(randomCir);\n            }\n        }\n        function relay(el) {\n            window.setTimeout(function () {\n                var item = getRandom(el.length - 1);\n                findNum(item);\n            }, 80);\n        }\n        relay(randomCir);\n    };\n\n    function checkForClasses() {\n        var circles = _('robot-st34').length;\n\n        // Add blinking light classes\n        for (var i = 0; i < circles; i++) {\n            if (_('robot-st34')[i].classList.contains('blink')) {\n\n                _('robot-st34')[i].classList.remove('blink');\n            }\n        }\n        electricBox();\n    };\n\n    // Add electricity for robot box stomach\n    function addElectricity() {\n        var pathLength = _('electric-path').length;\n        for (var i = 0; i < pathLength; i++) {\n            _('electric-path')[i].style.strokeDasharray = 20;\n            _('electric-path')[i].style.strokeDashoffset = 280;\n        }\n        var start = 0;\n\n        function draw(timestamp) {\n            if (!start) start = timestamp;\n            var runtime = timestamp - start;\n            var progress = Math.min(runtime / 1200, 1);\n\n            for (var i = 0; i < pathLength; i++) {\n                _('electric-path')[i].style.strokeDashoffset = 280 + 280 * progress;\n            }\n\n            if (progress < 1) {\n                requestAnimationFrame(draw);\n            } else {\n                for (var i = 0; i < pathLength; i++) {\n                    _('electric-path')[i].setAttribute('style', '');\n                }\n                return;\n            }\n        }\n        requestAnimationFrame(draw);\n    };\n\n    /** Outter function scope variables **/\n    var designImages = document.getElementsByClassName('designImages');\n    var img_container = document.getElementsByClassName('image-container')[0];\n\n    var animateSlider = {\n        target: null,\n        partialDist: 0,\n        j: 0,\n        dist: 0,\n        start: 0,\n        images: [],\n        imgStart: 0,\n        newStart: function newStart(num) {\n\n            return parseInt(this.images[num].style.transform.replace(/^([\\w]*)\\(|(px.*)$/ig, ''));\n        },\n        containerWidth: function containerWidth() {\n            return parseInt(img_container.style.width.replace(/px/ig, ''));\n        },\n        cloneImage: function cloneImage(img) {\n            var clonedImg = img.cloneNode(true);\n            clonedImg.className = '';\n            clonedImg.removeAttribute('style');\n            imgInlarge.checkForDuplicates('designVisible');\n            imgInlarge.moveElement(clonedImg, 'designVisible');\n        },\n        draw: function draw(timestamp) {\n\n            if (!this.start) this.start = timestamp;\n\n            var runtime = timestamp - this.start;\n            var progress = Math.min(runtime / 600, 1);\n\n            this.images[0].style.transform = 'translate(' + (this.imgStart - this.dist * progress) + 'px, -50%)';\n\n            if (progress === 1) {\n\n                //Second photo following the first to be animated automatically\n                if (this.j === 1) {\n\n                    //checks if left or right button click with a negative left or positive right and updates imgStart\n                    this.imgStart = this.dist < 0 ? -this.containerWidth() : this.containerWidth();\n                    this.dist = this.dist < 0 ? -this.containerWidth() : this.containerWidth();\n\n                    this.start = 0;\n                    var item = this.images.shift();\n                    this.images.push(item);\n                    this.j = 0;\n                } else {\n\n                    //User double clicks same button when 2nd image isn't finished it draws again\n                    if (this.imgStart !== this.dist) {\n\n                        this.draw();\n                    } else {\n                        //Stops typed text from running only when photo stops into place\n                        _('text-field').textContent = '';\n                        updateText.updateImgText(this.images[0]); //Starts the typed text function\n\n                        if (_('button-inlarge').style.opacity !== '1') {\n\n                            _('button-inlarge').style.opacity = 1;\n                        }\n\n                        this.cloneImage(this.images[0]);\n                    }\n                    return this.j++;\n                }\n            }\n            requestAnimationFrame(animateSlider.draw.bind(this));\n        },\n        animateData: function animateData(e) {\n            var target = this.target.innerText;\n            var newStart = this.newStart(0);\n            this.partialDist = newStart;\n\n            //If user clicks before image done animating, updates current location and starts again\n            if (newStart !== 0 && !isNaN(newStart)) {\n\n                if (target === '<') {\n                    //If user double clicks same button right away\n                    if (newStart < 0) {\n                        this.imgStart = newStart;\n                        this.dist = this.containerWidth() + newStart;\n                    } else {\n                        this.j = 0;\n                        this.dist = newStart;\n                        this.imgStart = newStart;\n                    }\n                }\n                if (target === '>') {\n\n                    if (newStart < 0) {\n                        this.j = 0;\n                        this.imgStart = newStart;\n                        this.dist = newStart;\n                        //If user double clicks same button right away\n                    } else {\n                        this.imgStart = newStart;\n                        this.dist = -this.containerWidth() + newStart;\n                    }\n                }\n                this.start = 0;\n            } else {\n                this.start = 0;\n\n                if (target === '<') {\n                    //first click starts image outside the head\n                    this.j >= 1 ? this.imgStart = 0 : this.imgStart = this.containerWidth();\n                    this.dist = this.containerWidth();\n                } else {\n                    //first click starts image outside the head\n                    this.j >= 1 ? this.imgStart = 0 : this.imgStart = -this.containerWidth();\n                    this.dist = -this.containerWidth();\n                }\n\n                this.draw();\n            }\n        },\n        // load images into array to be used for slider\n        loadImages: function loadImages() {\n            for (var i = 0; i < designImages.length; i++) {\n                var element = designImages[i];\n                this.images.push(element);\n            }\n        }\n    };\n\n    // Keeps from resize event loading click handler\n    if (e.type !== 'resize' && e.type !== 'scroll') {\n\n        _('btnContainer').addEventListener('click', function (e) {\n            e.stopPropagation();\n            animateSlider.target = e.target;\n            animateSlider.animateData(e);\n\n            checkForClasses();\n            addElectricity();\n            updateText.toggleFalse();\n            _('text-field').textContent = '';\n        });\n    }\n\n    return [animateSlider, animateStars]; // To be used in the window.onload section\n};\n\nfunction DesignSlider() {\n    var img_container = document.getElementsByClassName('image-container')[0];\n    var img_container_rect = img_container.getBoundingClientRect();\n    this.ellipse = document.getElementsByClassName('clip-ellipse')[0];\n    this.rec = document.getElementsByClassName('screen-path')[0].getBoundingClientRect();\n    this.sectionContainer = document.getElementsByClassName('section-three-robot')[0].getBoundingClientRect();\n\n    var actualTop = this.rec.top - this.sectionContainer.top; //when page not fully scrolled into view it's the actual top\n\n    this.setEllipseAttributes = function () {\n        this.ellipse.setAttribute('rx', this.rec.width / 2);\n        this.ellipse.setAttribute('ry', this.rec.height / 2);\n        this.ellipse.setAttribute('cx', this.rec.left + this.rec.width / 2 - 5);\n        this.ellipse.setAttribute('cy', actualTop + this.rec.height / 2);\n    };\n    this.setImgContainer = function () {\n        var container_Width = this.rec.width / 9 + this.rec.width;\n        var img_containerY = actualTop - (img_container_rect.height - this.rec.height) / 2;\n        img_container.style.transform = 'translate(-50%,' + img_containerY + 'px)'; //-48% to make up for 53% robot-svg offset\n        img_container.style.width = container_Width + 'px';\n    };\n    this.setButtonLocation = function () {\n\n        var addedWidth = window.innerWidth < 768 ? 70 : 200; //Distance bigger than robot head\n\n        var x = (window.innerWidth - (this.rec.width + addedWidth)) / 2;\n        var y = window.innerWidth > 768 ? actualTop + this.rec.height / 2 - 25 : this.rec.bottom - this.sectionContainer.top; // - 25 for the btnContainer height / 2\n\n        _('btnContainer').style.width = this.rec.width + addedWidth + 'px';\n        _('btnContainer').style.transform = 'translate(' + x + 'px,' + y + 'px)';\n    };\n    return function () {\n\n        return [this.setEllipseAttributes(), this.setImgContainer(), this.setButtonLocation()];\n    }.bind(this);\n}\n\nwindow.addEventListener('resize', function (e) {\n\n    var updateRobot = robotSection(e);\n\n    var designSlider = new DesignSlider();\n    designSlider(); //updates canvas size\n    updateRobot[1](); //updates button, image location , attributes of robot\n});\n\n// **** ASSEMBLY LINE SECTION ****\n\nvar AssemblyLine = function () {\n    function AssemblyLine() {\n        _classCallCheck(this, AssemblyLine);\n\n        this.mainSVG = _('assembly-line-svg');\n        this.sliders = _('roller_unit');\n        this.codeContainers = _('code-container');\n    }\n\n    _createClass(AssemblyLine, [{\n        key: \"getRect\",\n        value: function getRect(el) {\n            var rect = el.getBoundingClientRect();\n            var bBox = el.getBBox();\n            return { rect: rect, bBox: bBox };\n        }\n    }, {\n        key: \"getElemValue\",\n        value: function getElemValue(pos) {\n            var _$exec = /[1-9].*/.exec(this.mainSVG.getAttribute('viewBox')),\n                _$exec2 = _slicedToArray(_$exec, 1),\n                size = _$exec2[0];\n\n            var regEx = /^(\\d{4})\\s(\\d{3})$/ig;\n            var values = [];\n            values.length = 0;\n            var length = this.sliders.length;\n            var rollerUnit = this.sliders;\n            var codeElements = this.codeContainers;\n            for (var i = 0; i < length; i++) {\n                var rollerElem = rollerUnit[i];\n                var codeElem = codeElements[i];\n\n                switch (pos) {\n                    case 'container':\n                        return slidersContainer;\n                    case 'viewBoxWidth':\n                        return size.replace(regEx, '$1');\n                    case 'viewBoxHeight':\n                        return size.replace(regEx, '$2');\n                    case 'el':\n                        values.push(rollerElem);\n                        break;\n                    case 'rectX':\n                        values.push(this.getRect(rollerElem).rect.x); // not in use\n                        break;\n                    case 'codeBox.x':\n                        values.push(this.getRect(codeElem).rect.x);\n                        break;\n                    case 'codebBox.x':\n                        values.push(this.getRect(codeElem).bBox.x);\n                        break;\n                    case 'bBoxX':\n                        values.push(this.getRect(rollerElem).bBox.x); // not in use\n                        break;\n                    case 'y':\n                        values.push(this.getRect(rollerElem).bBox.y);\n                        break;\n                    case 'width':\n                        values.push(this.getRect(rollerElem).bBox.width);\n                        break;\n                    case 'height':\n                        values.push(this.getRect(rollerElem).bBox.height);\n                        break;\n                }\n            }\n            return values;\n        }\n    }]);\n\n    return AssemblyLine;\n}();\n\n;\n\nvar RollerUnit = function (_AssemblyLine) {\n    _inherits(RollerUnit, _AssemblyLine);\n\n    function RollerUnit() {\n        _classCallCheck(this, RollerUnit);\n\n        var _this4 = _possibleConstructorReturn(this, (RollerUnit.__proto__ || Object.getPrototypeOf(RollerUnit)).call(this));\n\n        _this4.getRect = _this4.getRect;\n        _this4.draw = _this4.draw.bind(_this4);\n        _this4.beginPos = [];\n        _this4.dist = [];\n        _this4.lessThan = '';\n        _this4.start = 0;\n        _this4.time = 1000;\n        _this4.current = {};\n        _this4.click = 0;\n        _this4.beltClick = 0;\n        _this4.foreinObjs = _('assembly-img-foreignObj');\n        _this4.foreinGroup = _('assembly-img-wrap');\n        _this4.belts = _('belt');\n        return _this4;\n    }\n\n    _createClass(RollerUnit, [{\n        key: \"startPos\",\n        value: function startPos(elem) {\n            var arr = [];\n            var el = elem;\n            var length = el.length;\n            for (var i = 0; i < length; i++) {\n                if (el[i].hasAttribute('style')) {\n                    arr.push(parseInt(el[i].style.transform.replace(/^([\\w]*)\\(([?-\\d].*)px\\)/ig, \"$2\")));\n                } else {\n                    arr.push(0);\n                }\n            }\n            return arr;\n        }\n    }, {\n        key: \"min\",\n        value: function min(start) {\n            var actual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n            var rect = Math.min.apply(Math, _toConsumableArray(start));\n            var dist = Math.min.apply(Math, _toConsumableArray(actual));\n            var index = start.indexOf(rect);\n            return { index: index, dist: dist };\n        }\n    }, {\n        key: \"max\",\n        value: function max(start, actual) {\n            var rect = Math.max.apply(Math, _toConsumableArray(start));\n            var dist = Math.max.apply(Math, _toConsumableArray(actual));\n            var index = start.indexOf(rect);\n            return { index: index, dist: dist };\n        }\n    }, {\n        key: \"getDistance\",\n        value: function getDistance() {\n            var _this5 = this;\n\n            var width = this.getElemValue('width')[0];\n            var arr = [];\n            var startingPoint = this.getElemValue('codeBox.x');\n            var actualDist = this.getElemValue('codebBox.x');\n\n            var maxElement = this.max(startingPoint, actualDist);\n            var minElement = this.min(startingPoint, actualDist);\n\n            var moveEnd = function moveEnd(k) {\n                var dist = _this5.left ? 431 : -431; // moveBeginning dist * 2    \n                arr.push({ dist: dist, index: k });\n            };\n\n            var moveBeginning = function moveBeginning(k) {\n                var dist = _this5.left ? minElement.dist + width : -(minElement.dist + width);\n                var rightPageStart = _this5.left ? actualDist.reverse()[k] + width : -actualDist[k] - width;\n\n                _this5.lessThan = k; //Updates the smallest distance\n                arr.push({ dist: dist * 2, index: k, rightPageStart: rightPageStart, pageRight: true });\n            };\n\n            for (var k = 0; k < 3; k++) {\n\n                if (minElement.index === k) {\n                    this.right ? moveEnd(k) : moveBeginning(k);\n                } else if (maxElement.index === k) {\n                    this.right ? moveBeginning(k) : moveEnd(k);\n                } else {\n                    var dist = this.left ? 431 : -431; // moveBeginning dist * 2\n                    arr.push({ dist: dist, index: k });\n                }\n            }\n            arr.sort = function (a, b) {\n                return a.place - b.place;\n            };\n            return arr;\n        }\n\n        // Add and remove foreignObjects into slider\n\n    }, {\n        key: \"foreinObjArr\",\n        value: function foreinObjArr() {\n            // let length =  this.foreinObjs.length\n            var length = this.foreinGroup.length;\n            var arr = new Array(length);\n\n            // Puts image foreignobjects into array\n            while (length) {\n                length--;\n                arr[length] = this.foreinGroup[length];\n            }\n\n            var startingPoint = this.getElemValue('codeBox.x');\n            var index = this.min(startingPoint).index;\n\n            var add = arr.splice(3, 1);\n            var removed = arr.splice(index, 1);\n\n            var removedChild = removed[0].childNodes[1];\n            var addChild = add[0].childNodes[1];\n            arr.splice(index, 0, add[0]);\n            arr.push(removed[0]);\n\n            //Add and remove just transforms first\n            var styleTransform = removed[0].attributes[1];\n            removed[0].removeAttribute(styleTransform.name);\n            add[0].setAttribute(styleTransform.name, styleTransform.value);\n\n            //Strips attributes of removed and add same attributes to added foreignobject\n            while (removedChild.attributes.length > 1) {\n\n                var attrName = removedChild.attributes[1].name;\n                var attrValue = removedChild.attributes[1].value;\n\n                addChild.setAttribute(attrName, attrValue);\n                removedChild.removeAttribute(removedChild.attributes[1].name);\n            }\n\n            this.foreinGroup = arr;\n        }\n\n        // Ran once when page reloads\n\n    }, {\n        key: \"positionForiegnObject\",\n        value: function positionForiegnObject(_this) {\n            var sliders = this.codeContainers;\n            var foreignObjects = this.foreinObjs;\n            var length = sliders.length;\n\n            for (var i = 0; i < length; i++) {\n\n                var slider_x = this.getRect(this.codeContainers[i]).bBox.x;\n                var slider_y = this.getRect(this.codeContainers[i]).bBox.y;\n                var slider_width = this.getRect(this.codeContainers[i]).bBox.width;\n                var slider_height = this.getRect(this.codeContainers[i]).bBox.height;\n\n                foreignObjects[i].setAttribute('x', slider_x);\n                foreignObjects[i].setAttribute('y', slider_y);\n                foreignObjects[i].setAttribute('width', slider_width);\n                foreignObjects[i].setAttribute('height', slider_height);\n            }\n            //Inputs image into container\n            _this.targetElem();\n        }\n    }, {\n        key: \"moreThanHalf\",\n        value: function moreThanHalf(dist, positiveCurrent, startDist) {\n            return dist - (startDist - positiveCurrent);\n        }\n    }, {\n        key: \"lessThanHalf\",\n        value: function lessThanHalf(current, dist, startDist) {\n            var d = dist.dist < 0 ? dist.dist * -1 : dist.dist;\n\n            if (startDist === 0) {\n                if (dist.rightPageStart) {\n                    var diff = current - startDist;\n                    var totalDiff = d - (current - startDist);\n                    return diff + totalDiff;\n                }\n                return d - current;\n            } else {\n                if (dist.rightPageStart) {\n                    var _diff2 = current - startDist;\n                    var _totalDiff = d - Math.abs(current - startDist);\n                    return _diff2 + _totalDiff;\n                }\n                var _diff = d - Math.abs(current - startDist);\n                return _diff;\n            }\n        }\n    }, {\n        key: \"oppisiteDir\",\n        value: function oppisiteDir(current, startDist) {\n            if (startDist === 0) {\n                return current;\n            } else {\n                if (current > startDist) {\n                    // more than half\n                    return current - startDist;\n                }\n                return startDist - current; //less than half    \n            }\n        }\n    }, {\n        key: \"handleRightPageStart\",\n        value: function handleRightPageStart(d, rightPageStart, posCurrent, startDist) {\n\n            if (startDist < 0) {\n                //more than half\n                if (d > posCurrent) {\n                    var _distance = posCurrent;\n                    return { distance: _distance, pageRight: false\n                        //less than half\n                    };\n                }\n                var difference = 1141.2 - posCurrent;\n                var totalDif = d - (1141.2 - posCurrent);\n                var distance = difference + totalDif;\n                return { distance: distance, pageRight: true };\n            } else {\n\n                //less than half only element with a rightPageStart of 1141.2\n                if (rightPageStart > 1160) {\n                    //1160\n                    var _difference = d / 2 - posCurrent;\n                    var _totalDif = d - _difference;\n                    var _distance2 = _totalDif + _difference;\n                    return { distance: _distance2, pageRight: true\n                        //more than half\n                    };\n                } else if (posCurrent < startDist) {\n                    var _distance3 = startDist - posCurrent;\n                    return { distance: _distance3, pageRight: false\n                        //less than half \n                    };\n                } else {\n                    var diff = posCurrent - startDist;\n                    var totalDiff = d - (posCurrent - startDist);\n                    var _distance4 = diff + totalDiff;\n                    return { distance: _distance4, pageRight: true };\n                }\n            }\n        }\n        // ** RIGHT BUTTON IS NEGATIVE DIST, LEFT BUTTON IS POSITIVE DIST**\n\n    }, {\n        key: \"handleDoubleClick\",\n        value: function handleDoubleClick(current, dist, beginPos) {\n            //Updates how many times back and forth before animation finishes\n            this.click++;\n\n            var currentDirection = Math.sign(this.currentDist[1].dist);\n            var distDirection = Math.sign(dist[1].dist);\n\n            for (var i = 0; i < 3; i++) {\n\n                //Middle dist not equal both negative or positives then use current dist\n                var dist_i = currentDirection !== distDirection ? this.currentDist[i] : dist[i];\n                var d = dist_i.dist < 0 ? dist_i.dist * -1 : dist_i.dist; //changed this\n\n                //Starts off with positive variables\n                var rightPageStart = dist_i.rightPageStart < 0 ? dist_i.rightPageStart * -1 : dist_i.rightPageStart;\n                var startDist = beginPos[i] < 0 ? beginPos[i] * -1 : beginPos[i];\n                var posCurrent = current[i] < 0 ? current[i] * -1 : current[i];\n\n                // When clicked opposite direction\n                if (currentDirection !== distDirection) {\n\n                    if (rightPageStart) {\n                        var rightStart = this.right ? -rightPageStart : rightPageStart;\n\n                        var cur = this.handleRightPageStart(d, rightPageStart, posCurrent, startDist, this.currentDist[i].index);\n                        var curDist = this.right ? -cur.distance : cur.distance;\n                        var pageRight = cur.pageRight;\n\n                        this.dist.push({ dist: curDist, index: dist_i.index, rightPageStart: rightStart, pageRight: pageRight });\n                        this.beginPos.push(current[i]);\n                    } else {\n                        var distance = this.oppisiteDir(posCurrent, startDist);\n                        var _dist = this.right && distance > 0 ? -distance : distance;\n\n                        this.dist.push({ dist: _dist, index: dist_i.index, rightPageStart: dist_i.rightPageStart, pageRight: false });\n                        this.beginPos.push(current[i]);\n                    }\n                    //Clicked same direction\n                } else {\n                    //After element starts from hidden part of page\n                    if (this.right && rightPageStart && current[i] < 0 || this.left && current[i] > 0 && rightPageStart) {\n\n                        this.lessThan = dist_i.index; //have to update rightPageStart again due to running this.getDistance() twice\n                        var _distance5 = d / 2 - (rightPageStart - posCurrent);\n                        var PosOrNegDistance = this.right && _distance5 > 0 ? _distance5 * -1 : _distance5;\n\n                        this.dist.push({ dist: PosOrNegDistance, index: dist_i.index, rightPageStart: dist_i.rightPageStart, pageRight: false });\n                        this.beginPos.push(current[i]);\n                    } else {\n                        var lessThanhalf = startDist < posCurrent || startDist && posCurrent < d ? true : false;\n                        var _distance6 = lessThanhalf ? this.lessThanHalf(posCurrent, dist_i, startDist) : this.moreThanHalf(d, posCurrent, startDist);\n                        var _PosOrNegDistance = this.right ? -_distance6 : _distance6;\n\n                        this.dist.push({ dist: _PosOrNegDistance, index: dist_i.index, rightPageStart: dist_i.rightPageStart, pageRight: true });\n                        this.beginPos.push(current[i]);\n                    }\n                }\n            }\n            //Removes prior values in arrays\n            this.dist.splice(0, 3), this.beginPos.splice(0, 3);\n        }\n        //Updates sliders positions\n\n    }, {\n        key: \"updatePos\",\n        value: function updatePos() {\n            // Handles back and forth clicking\n            if (this.start) {\n                this.start = 0;\n\n                this.currentDist = this.getDistance();\n                this.currentBeginPos = this.startPos(this.sliders);\n                return this.handleDoubleClick(this.current, this.dist, this.beginPos);\n            } else {\n                this.updateBeltPos();\n                this.beginPos.length = 0;\n                this.dist.length = 0;\n                var dist = this.getDistance();\n                var beginPos = this.startPos(this.sliders);\n                // 3 is length of slider elements\n                for (var i = 0; i < 3; i++) {\n\n                    this.beginPos.push(beginPos[i]);\n                    this.dist.push(dist[i]);\n                }\n                requestAnimationFrame(this.draw);\n            }\n        }\n    }, {\n        key: \"animateBelts\",\n        value: function animateBelts(topGears, bottomGears) {\n            _('teeth-wrapper-top').style.transform = \"translate(\" + topGears + \"px)\";\n            _('teeth-wrapper-bottom').style.transform = \"translate(\" + bottomGears + \"px)\";\n        }\n    }, {\n        key: \"animate\",\n        value: function animate(sliders, imgGroup, value) {\n            sliders.style.transform = \"translate(\" + value + \"px)\";\n            imgGroup.style.transform = \"translate(\" + value + \"px)\";\n        }\n    }, {\n        key: \"draw\",\n        value: function draw(timestamp) {\n            var time = this.time;\n            if (!this.start) this.start = timestamp;\n            this.runtime = timestamp - this.start;\n            var progress = Math.min(this.runtime / time, 1);\n\n            var j = this.lessThan;\n\n            for (var i = 0; i < 3; i++) {\n\n                var num = i !== j ? i : j;\n                var sliders = this.sliders[num];\n\n                var imgGroup = this.foreinGroup[num];\n\n                var beginPos = this.beginPos[num];\n                var dist = this.dist[num].dist;\n                var rightStart = this.dist[num].rightPageStart;\n                var pageRight = this.dist[num].pageRight;\n                //Right or Left side element animate to other side of screen\n                if (num === j && pageRight) {\n\n                    if (progress <= .5) {\n                        var value = beginPos - dist * progress;\n                        this.current[num] = value;\n                        this.animate(sliders, imgGroup, value);\n                    } else {\n                        var _value = rightStart - dist * (progress - .5);\n                        this.current[num] = _value;\n                        this.animate(sliders, imgGroup, _value);\n                    }\n                } else {\n                    var _value2 = beginPos - dist * progress;\n                    this.current[num] = _value2;\n                    this.animate(sliders, imgGroup, _value2);\n                }\n            }\n            // Belts Animation\n            var topGears = this.beltPos.startPos[0] + this.beltPos.dist * progress;\n            var bottomGears = this.beltPos.startPos[1] - this.beltPos.dist * progress;\n            this.animateBelts(topGears, bottomGears);\n            if (progress < 1) {\n                requestAnimationFrame(this.draw);\n            } else {\n                this.foreinObjArr();\n                this.start = 0;\n                this.beltClick++;\n                this.click = 0;\n                imgInlarge.targetElem();\n                return;\n            }\n        }\n        //Stars gears inline left or right depending on left or right click\n\n    }, {\n        key: \"beltDirections\",\n        value: function beltDirections() {\n            var beltWidth = _('bottom-main').getBBox().width;\n\n            if (this.right) {\n                _('bottom-teeth').style.transform = \"translate( \" + beltWidth + \"px )\";\n                _('top-teeth').style.transform = \"translate( \" + -beltWidth + \"px )\";\n            } else {\n                _('bottom-teeth').style.transform = \"translate( \" + -beltWidth + \"px )\";\n                _('top-teeth').style.transform = \"translate( \" + beltWidth + \"px )\";\n            }\n        }\n    }, {\n        key: \"updateBeltPos\",\n        value: function updateBeltPos() {\n            var belts = this.startPos(this.belts);\n            var startPos = void 0,\n                dist = void 0;\n\n            // Starts gears on one side of the page or the other \n            if (this.beltClick === 0 || this.beltClick && belts[0] === 0) this.beltDirections();\n\n            if (this.right) {\n                startPos = belts;\n                dist = _('top-teeth').getBBox().width / 3;\n            }\n            if (this.left) {\n                startPos = belts;\n                dist = -(_('top-teeth').getBBox().width / 3);\n            }\n\n            //Keeps Gears always looking like their never ending\n            if (this.beltClick === 3) {\n                this.beltClick = 0;\n                this.animateBelts(0, 0);\n                this.beltDirections();\n                startPos = [0, 0];\n            }\n            this.beltPos = { dist: dist, startPos: startPos };\n        }\n    }]);\n\n    return RollerUnit;\n}(AssemblyLine);\n\nvar InLargeImg = function (_RollerUnit) {\n    _inherits(InLargeImg, _RollerUnit);\n\n    function InLargeImg() {\n        _classCallCheck(this, InLargeImg);\n\n        var _this6 = _possibleConstructorReturn(this, (InLargeImg.__proto__ || Object.getPrototypeOf(InLargeImg)).call(this));\n\n        _this6.container = _('img-inlarge-container');\n        _this6.animateClipPath = _this6.animateClipPath.bind(_this6);\n        _this6.img = document.querySelector('.inlarge-img-wrap img');\n        _this6.imgWrap = document.getElementsByClassName('inlarge-img-wrap')[0];\n        _this6.mouseMove = _this6.mouseMove.bind(_this6);\n        _this6.removeListener = _this6.removeListener.bind(_this6);\n        _this6.mouseY = 0;\n        _this6.imageClose = _this6.imageClose.bind(_this6);\n        _this6.targetElem = _this6.targetElem;\n        _this6.checkForDuplicates = _this6.checkForDuplicates;\n        _this6.moveElement = _this6.moveElement;\n        _this6.Y = 0;\n        return _this6;\n    }\n\n    _createClass(InLargeImg, [{\n        key: \"addClickListener\",\n        value: function addClickListener() {\n            console.log('listener added');\n            _('img-inlarge-container').addEventListener('click', this.imageClose);\n        }\n    }, {\n        key: \"removeClickListener\",\n        value: function removeClickListener() {\n            console.log('removed click listener');\n            _('img-inlarge-container').removeEventListener('click', this.imageClose);\n        }\n    }, {\n        key: \"checkForDuplicates\",\n        value: function checkForDuplicates(clssName) {\n            var imgs = this.imgWrap.children;\n            var length = imgs.length;\n            while (length--) {\n                if (imgs[length].className === clssName) {\n                    this.img = imgs[length];\n                    this.removeImg();\n                }\n            }\n        }\n        //Recursion\n\n    }, {\n        key: \"targetElem\",\n        value: function targetElem(elemX) {\n\n            var length = this.foreinObjs.length;\n            var arr = [];\n            var groupArr = [];\n\n            for (var i = length - 1; i >= 0; i--) {\n\n                // 1st pushes only elements with style attribtues of x\n                if (!elemX && this.foreinObjs[i].hasAttribute('x')) {\n\n                    arr.push(this.foreinObjs[i].getBoundingClientRect().x);\n                    groupArr.push(this.foreinObjs[i].parentNode);\n                }\n                // Scaling image only\n                if (this.foreinObjs[i].parentNode.getBoundingClientRect().x === elemX && this.toggleMoveElement) {\n                    this.group = this.foreinObjs[i].parentNode;\n                    return;\n                }\n                if (this.foreinObjs[i].getBoundingClientRect().x === elemX) {\n                    this.checkForDuplicates('webVisible');\n                    var imgNode = this.foreinObjs[i].childNodes[1];\n                    var clonedImg = imgNode.cloneNode(true);\n                    return this.moveElement(clonedImg, 'webVisible');\n                }\n            }\n            // Middle element which is the median of the three elements\n            var sorted = arr.sort(function (a, b) {\n                return a - b;\n            })[1];\n            this.targetElem(sorted);\n        }\n    }, {\n        key: \"insertText\",\n        value: function insertText(img) {\n            var imgContent = _('img-content');\n            var url = img.attributes[2].value;\n            var text = img.attributes[1].textContent;\n            imgContent.textContent = text;\n            imgContent.innerHTML += '<br>' + '<a href=\"' + url + '\"> ' + url + ' </a>' + '</br>';\n        }\n    }, {\n        key: \"moveElement\",\n        value: function moveElement(el, cls) {\n            this.img = el; //updates image to be used elsewhere \n            el.classList.add(cls);\n            var img_content = _('img-content');\n            var fragment = document.createDocumentFragment();\n            fragment.appendChild(el);\n            this.imgWrap.insertBefore(fragment, img_content);\n            this.imgWrap.classList.add('show-img');\n            this.imgWrap.classList.remove('hide-img');\n        }\n    }, {\n        key: \"removeImg\",\n        value: function removeImg(e) {\n            var _this7 = this;\n\n            //Only ran to exit out of image from click handler\n            if (e) {\n                this.container.style.opacity = 0;\n                this.imgWrap.classList.replace('show-img', 'hide-img');\n                setTimeout(function () {\n                    _this7.imgWrap.classList.replace('hide-img', 'show-img');\n                    _this7.container.removeAttribute('style');\n                    _this7.img.style.display = 'none';\n                }, 1100);\n            } else {\n\n                _('img-content').textContent = '';\n                this.img.parentNode.removeChild(this.img);\n            }\n        }\n        // Removes images \n\n    }, {\n        key: \"imageClose\",\n        value: function imageClose(e) {\n            console.log(e.target.tagName);\n\n            if (e.target.tagName !== 'IMG') {\n                this.removeClickListener();\n                this.removeImg(e);\n            }\n        }\n        // Displays image\n\n    }, {\n        key: \"showImage\",\n        value: function showImage(clssName) {\n            this.img = document.getElementsByClassName(clssName)[0];\n            this.insertText(this.img);\n            this.img.style.display = 'block';\n            this.addClickListener();\n            this.container.style.display = 'flex';\n            this.container.style.opacity = 1;\n        }\n        // **  REMOVE ANIMATECLIPPATH IF I DON'T REALLLY HAVE TO USE IT FOR FIREFOX **\n        //Firefox only\n\n    }, {\n        key: \"animateClipPath\",\n        value: function animateClipPath(timestamp) {\n            if (!this.start) this.start = timestamp;\n            this.runtime = timestamp - this.start;\n            var progress = Math.min(this.runtime / 1000, 1);\n            this.imgWrap.style.clipPath = \"circle(\" + (this.clipStart + this.clipValue * progress) + \"%)\";\n\n            if (progress < 1) {\n                requestAnimationFrame(this.animateClipPath);\n            } else {\n\n                if (this.container.style.opacity == 0) {\n\n                    // Removes flex and opacity, sets back to display none\n                    this.container.removeAttribute('style');\n                    // this.img.parentNode.removeChild(this.img)\n                }\n                this.start = 0;\n            }\n        }\n    }, {\n        key: \"getTransform\",\n        value: function getTransform() {\n            var regEx = /^scale/g;\n            var transform = this.group.style.transform.replace(/^(\\w*\\(-?\\d*.\\w*\\))(.*)/ig, \"$1\");\n            var checkForScale = transform.match(regEx);\n            //So two scale values don't get added to element when translate doesn't exist\n            if (checkForScale) {\n                return '';\n            } else {\n                return transform;\n            }\n        }\n    }, {\n        key: \"scalePhoto\",\n        value: function scalePhoto(dist, scale, translate) {\n            document.getElementById('slider_1_').style.transform = \"translateY(\" + dist + \"px)\";\n            this.group.style.transform = translate + (\"scale( \" + (1 + scale) + \" )\");\n        }\n    }, {\n        key: \"mouseMove\",\n        value: function mouseMove(e) {\n            // multipy by 1.5 because of the lag, so I speed it up just a bit\n            var dist = e.clientY - this.mouseY;\n            var value = dist / this.Y;\n            var scale = Math.min(value < 0 ? -value : -value, 1);\n            var translate = this.getTransform();\n            var translateValue = +translate.replace(/[^-\\d.]/ig, \"\");\n\n            //Checks if element is either -431 or 431 so the correct transform origin can be added\n            if (translateValue > 2) {\n                this.group.style.transformOrigin = 165 + \"px \" + 450 + \"px\";\n            } else if (translateValue < -1) {\n                this.group.style.transformOrigin = 1034 + \"px \" + 458 + \"px\";\n            }\n            //scale is 1 when clicked somewhere else\n            if (scale < 1 && dist <= 6) this.scalePhoto(dist, scale, translate);\n        }\n    }, {\n        key: \"mouseDown\",\n        value: function mouseDown(e) {\n\n            _('slide-group').addEventListener('mouseup', this.removeListener, true);\n\n            this.toggleMoveElement = true;\n            this.targetElem();\n            var verPiece = document.getElementById('vert_piece');\n            var vertY = verPiece.getBBox().y;\n            var handleY = _('img-scale').getBBox().y;\n\n            //Gets distance slider needs to go  \n            this.Y = handleY - vertY;\n\n            //Start position for distance\n            if (!this.mouseY) this.mouseY = e.clientY;\n            _('slide-group').addEventListener('mousemove', this.mouseMove, true);\n        }\n    }, {\n        key: \"removeListener\",\n        value: function removeListener(e) {\n            _('slide-group').removeEventListener('mousemove', this.mouseMove, true);\n\n            var translate = this.getTransform();\n            this.scalePhoto(0, 0, translate);\n\n            _('slide-group').removeEventListener('mouseup', this.removeListener, true);\n            _('img-scale').removeEventListener('mousedown', this.mouseDown, true);\n\n            //Updates position when mouseUp\n            this.mouseY = 0;\n            this.toggleMoveElement = false;\n        }\n    }]);\n\n    return InLargeImg;\n}(RollerUnit);\n\nvar rollerUnit = new RollerUnit();\nvar imgInlarge = new InLargeImg();\nrollerUnit.positionForiegnObject(imgInlarge);\n\n_('img-scale').addEventListener('mousedown', function (e) {\n    imgInlarge.mouseDown(e);\n}, true);\n\n_('buttons').addEventListener('click', function (e) {\n\n    e.stopPropagation();\n    var target = e.target.parentElement.classList[0];\n\n    if (target === 'img-left' || target === 'img-right') {\n        if (rollerUnit.click === 1) return;\n\n        rollerUnit.left = target === 'img-left' ? true : false;\n        rollerUnit.right = target === 'img-right' ? true : false;\n        rollerUnit.updatePos();\n    } else if (target === 'img-inlarge') {\n        imgInlarge.showImage('webVisible');\n    }\n});\n\n_('button-inlarge').addEventListener('click', function (e) {\n    imgInlarge.showImage('designVisible');\n});\n\n// **** GRAPH SECTION ****\n\nvar random = function random(min, max) {\n    return Math.random() * (max - min) + min;\n};\n\nvar toggleRobot = {\n    toggle: false,\n    flight: false, //Toggles when scrolled out of screen view\n    direction: 'up'\n};\n\nfunction startRobotFlight() {\n    // *** Burners ***\n\n    var flames = _('robot-flame');\n    var length = flames.length;\n\n    var from = { x: 1, y: 1 };\n    var to = {};\n    var distance = {};\n    var keys = Object.keys(from);\n\n    var next = function next(timestamp) {\n        //starts all over from gets starting point of the last size\n        Object.assign(from, to);\n        var length = keys.length;\n        for (var i = 0; i < length; i++) {\n            var axis = keys[i];\n            to[axis] = random(.8, 1);\n            distance[axis] = from[axis] - to[axis];\n        }\n\n        time.start = timestamp;\n    };\n\n    var time = {\n        total: 40\n    };\n\n    var drawBurners = function drawBurners(timestamp) {\n        if (toggleRobot.flight) return;\n        if (time.runtime > time.total || !to.x) next(timestamp);\n\n        time.runtime = timestamp - time.start;\n        var progress = time.runtime / time.total;\n\n        var _keys$map = keys.map(function (axis) {\n            return from[axis] - progress * distance[axis];\n        }),\n            _keys$map2 = _slicedToArray(_keys$map, 2),\n            x = _keys$map2[0],\n            y = _keys$map2[1];\n\n        for (var i = 0; i < length; i++) {\n            var flame = flames[i];\n            flame.style.transform = \"scale(\" + x + \", \" + y + \")\";\n        }\n        requestAnimationFrame(drawBurners);\n    };\n\n    //*** Draws Stars ***\n    var graphs = document.getElementsByClassName('graph-st20');\n    var recClip = document.getElementsByClassName('rec-clip')[0];\n    var fragment = document.createDocumentFragment();\n    var robotRect = _('floating_robot').getBoundingClientRect();\n    var graph = document.getElementById('graph-svg');\n\n    var _$exec3 = /[1-9].*/.exec(graph.getAttribute('viewBox')),\n        _$exec4 = _slicedToArray(_$exec3, 1),\n        size = _$exec4[0];\n\n    var regEx = /([1-9.]*)\\s([1-9.].*)/ig;\n    var graphWidth = size.replace(regEx, '$1');\n    var graphHeight = size.replace(regEx, '$2');\n\n    var robotHeight = robotRect.height;\n    var robotWidth = robotRect.width;\n    var startY = graphHeight - robotHeight;\n    var startX = robotRect.x - (window.innerWidth - graphWidth) / 2;\n\n    //starts stars randomly\n    var randomInterval = function randomInterval(callback, data, min, max) {\n\n        var time = {\n            start: performance.now(),\n            total: random(min, max)\n        };\n        var draw = function draw(timestamp) {\n            if (toggleRobot.flight) return;\n            if (time.total <= timestamp - time.start) {\n                time.start = timestamp;\n                time.total = random(min, max);\n                callback(data);\n            }\n            requestAnimationFrame(draw);\n        };\n        requestAnimationFrame(draw);\n    };\n\n    var createStar = function createStar(cx, cy, radius) {\n        var star = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n        star.setAttribute(\"r\", radius);\n        star.setAttribute(\"cy\", cy);\n        star.setAttribute(\"cx\", cx);\n        star.setAttribute(\"fill\", \"white\");\n        star.setAttribute(\"fill-opacity\", 0);\n        return star;\n    };\n\n    var FallingStars = function FallingStars(data) {\n\n        var attr = new data(toggleRobot.direction);\n\n        var radius = attr.radius;\n        var cx = attr.cx;\n        var cy = attr.cy;\n        var dist = attr.dist;\n        var star = createStar(cx, cy, radius);\n\n        var time = {\n            start: performance.now(),\n            total: random(1900, 2000)\n        };\n\n        var draw = function draw(timestamp) {\n            if (toggleRobot.toggle || toggleRobot.flight) {\n                graph.removeChild(star);\n                return;\n            }\n            time.elapsed = timestamp - time.start;\n            var progress = Math.min(time.elapsed / time.total, 1);\n\n            var opacity = progress * 2;\n\n            star.setAttribute(\"cy\", cy + progress * dist);\n            star.setAttribute(\"fill-opacity\", progress < .5 ? opacity : 2 - opacity);\n            time.elapsed < time.total ? requestAnimationFrame(draw) : graph.removeChild(star);\n        };\n        requestAnimationFrame(draw);\n\n        //Inserts new star based on randomInterval runing throughStars()\n        fragment.appendChild(star);\n        graph.insertBefore(fragment, graph.firstChild);\n    };\n\n    var flyIntoPlace = {\n        beginY: graphHeight - robotHeight / 12,\n        hiddenX: function hiddenX() {\n            var difference = graphWidth - wW;\n            if (!wW < graphWidth) {\n\n                return robotRect.width + robotRect.x + difference;\n            }\n        },\n        hideRobot: function hideRobot(size) {\n            if (size === 1.3) {\n                var beginX = this.hiddenX();\n                _('floating_robot').style.transform = \"translate(\" + 0 + \"px, -\" + this.beginY + \"px)\";\n            }\n        },\n        createStars: function createStars() {\n            var attributes = function attributes(direction) {\n\n                if (direction === 'down') {\n\n                    toggleRobot.toggle = false;\n                    var radius = random(.5, 2.7);\n                    var cx = random(startX - 100, startX + robotWidth + 100);\n                    var cy = random(startY - 120, startY - 175);\n                    var dist = 100 + robotHeight;\n\n                    return { radius: radius, cx: cx, cy: cy, dist: dist };\n                } else if (direction === 'up') {\n\n                    var _radius = random(1.5, 3.7);\n                    var _cx = random(0 - 25, graphWidth + 25);\n                    var _cy = random(graphHeight - 80, graphHeight + 50);\n                    var _dist2 = -graphHeight;\n\n                    return { radius: _radius, cx: _cx, cy: _cy, dist: _dist2 };\n                }\n            };\n            //Every 80ms through 180ms of time.total it will draw a star\n            //**** STARTS STARS MOVING *****\n            randomInterval(FallingStars, attributes, 80, 180);\n        }\n    };\n\n    var graphData = {\n        start: 0,\n        total: 2000\n    };\n    var subtractRay = function subtractRay() {\n        _('left-text-panel').removeAttribute('clip-path');\n        _('rec-clip').style.transform = \"translate(485px, 520px)\";\n    };\n    var getStrokeLength = function getStrokeLength() {\n        var i = graphs.length;\n        var value = new Array(i);\n        function getLength() {\n            while (i--) {\n                value[i] = graphs[i].getTotalLength();\n            }\n        }\n        return {\n            runValue: function runValue() {\n                getLength();\n            },\n            getValue: function getValue() {\n                return value;\n            }\n        };\n    };\n    var strokeLength = getStrokeLength();\n    strokeLength.runValue();\n\n    var drawPercentStroke = function drawPercentStroke(progress) {\n        var stroke = strokeLength.getValue();\n        var i = graphs.length;\n        while (i--) {\n            graphs[i].style.stroke = 'url(#design-gradient)';\n\n            graphs[0].style.strokeDashoffset = stroke[0] + stroke[0] * progress;\n            graphs[1].style.strokeDashoffset = stroke[1] - stroke[1] * progress;\n        }\n    };\n    var animateGraph = function animateGraph(timestamp) {\n        if (!graphData.start) graphData.start = timestamp;\n        var runtime = timestamp - graphData.start;\n        var progress = Math.min(runtime / graphData.total, 1);\n\n        _('graph-percentage-top').textContent = Math.round(0 + 90 * progress) + ' %';\n        _('graph-percentage-bottom').textContent = Math.round(0 + 70 * progress) + ' %';\n        _('graph-rect').style.transform = 'translate(' + 412 * progress + 'px)';\n        drawPercentStroke(progress);\n\n        if (progress < 1) requestAnimationFrame(animateGraph);else return subtractRay();\n    };\n\n    var startAnimateGraph = function startAnimateGraph() {\n        if (_('rec-clip').style.transform) return;\n\n        recClip.style.transform = 'translate(0px, 0px)';\n        _('graph-clipping').classList.add('show-graphs');\n\n        //Animate graphs after recClip transform is done\n        setTimeout(function () {\n            requestAnimationFrame(animateGraph);\n        }, 2500);\n    };\n\n    var begin = {\n        start: 0,\n        total: 4000\n    };\n\n    var flyIn = function flyIn(timestamp) {\n        if (!begin.start) begin.start = timestamp;\n        begin.runtime = timestamp - begin.start;\n        var progress = Math.min(begin.runtime / begin.total, 1);\n        var curve = 624.9 / 2;\n        var ease = easeOut(progress);\n        var increment = curve * progress / 50;\n\n        var y = -flyIntoPlace.beginY + flyIntoPlace.beginY * progress;\n        var x = -Math.cos(increment + Math.PI / 180) * curve + curve;\n        // !begin.toggle\n        _('floating_robot').style.transform = \"translate(\" + -x + \"px, \" + y + \"px)\";\n        // : document.querySelector('#section-five-web .container-lg').style.transform = `scale(${1.3 - .3 * ease})`\n\n        if (progress === 1) {\n            // toggleRobot.toggle = true;\n            toggleRobot.direction = 'down';\n\n            //Resizes the whole container so robot fits into screen\n            if (wW > 1050) {\n                setTimeout(startAnimateGraph, 600);\n                document.querySelector('#section-five-web .container-lg').classList.add('scale-container');\n            } else {\n\n                startAnimateGraph();\n            }\n            return;\n        }\n        requestAnimationFrame(flyIn);\n    };\n    return { flyIn: flyIn, flyIntoPlace: flyIntoPlace, drawBurners: drawBurners };\n}\n\nvar navToggle = {\n    toggle: true\n};\n\nvar Navigation = function () {\n    function Navigation() {\n        _classCallCheck(this, Navigation);\n\n        this.navItems = document.querySelectorAll('.nav-list button');\n        this.scrollTo = this.scrollTo.bind(this);\n        this.animateScroll = this.animateScroll.bind(this);\n        this.start = 0;\n    }\n\n    _createClass(Navigation, [{\n        key: \"getDistance\",\n        value: function getDistance(el) {\n\n            var top = el.getBoundingClientRect().top;\n            var height = el.getBoundingClientRect().height;\n            var bottom = el.getBoundingClientRect().bottom;\n            return { top: top, height: height, bottom: bottom };\n        }\n    }, {\n        key: \"getScrolltoElement\",\n        value: function getScrolltoElement(target, regEx) {\n            var section = document.getElementsByTagName('section');\n            var length = section.length;\n            while (length--) {\n                if (target === section[length].id.replace(regEx, \"$1\")) {\n                    return {\n                        el: section[length],\n                        index: length\n                    };\n                }\n            }\n        }\n    }, {\n        key: \"outExpo\",\n        value: function outExpo(n) {\n            return 1 == n ? n : 1 - Math.pow(2, -10 * n);\n        }\n    }, {\n        key: \"animateScroll\",\n        value: function animateScroll(timestamp) {\n            if (!this.start) this.start = timestamp;\n            var runtime = timestamp - this.start;\n            var progress = this.outExpo(Math.min(runtime / 1200, 1));\n            var y = this.startPos + this.elDist * progress;\n\n            window.scroll(0, y);\n            if (progress < 1) {\n                requestAnimationFrame(this.animateScroll);\n            } else return navToggle.toggle = true;\n        }\n    }, {\n        key: \"toggleOpenBtn\",\n        value: function toggleOpenBtn() {\n            var i = this.navItems.length;\n            while (i--) {\n\n                if (this.navItems[i].style.transform) {\n                    this.navItems[i].removeAttribute('style');\n                }\n            }\n        }\n    }, {\n        key: \"scrollTo\",\n        value: function scrollTo(e) {\n            this.toggleOpenBtn();\n            if (e.target.className === 'contact-modal') return;\n            var regEx = /(\\w+\\-\\w+)\\-\\w+/ig;\n            var sectionId = e.target.className.replace(regEx, \"$1\");\n            var scrollToElem = this.getScrolltoElement(sectionId, regEx).el;\n            var index = this.getScrolltoElement(sectionId, regEx).index;\n            var elDist = this.getDistance(scrollToElem, index).top;\n            this.elDist = elDist;\n            this.startPos = window.pageYOffset;\n            this.start = 0;\n\n            requestAnimationFrame(this.animateScroll);\n        }\n    }, {\n        key: \"scrollTo768\",\n        value: function scrollTo768(e) {\n            var targetBtn = e.target.parentNode.parentNode;\n\n            if (targetBtn.hasAttribute('style')) {\n                return this.toggleOpenBtn();\n            }\n            this.toggleOpenBtn();\n            targetBtn.style.pointerEvents = 'auto';\n            targetBtn.style.transform = \"translateX(\" + -132 + \"px)\";\n        }\n    }, {\n        key: \"controller\",\n        value: function controller() {\n            var _this8 = this;\n\n            _('nav-list').addEventListener('click', function (e) {\n                console.log(e.target);\n                navToggle.toggle = false;\n                if (e.target.nodeName === \"BUTTON\") {\n\n                    _this8.scrollTo(e);\n                }\n                // Only @ screen size 768 and smaller\n                if (e.target.parentNode.classList[1] === 'nav-icon') {\n\n                    _this8.scrollTo768(e);\n                }\n            });\n        }\n    }]);\n\n    return Navigation;\n}();\n\nvar navigation = new Navigation();\nnavigation.controller();\n\nvar toggleAnimate = {\n    stars: true,\n    flightStars: true,\n    circuit: true\n};\n\nvar robot = new robotSection('event');\nvar robotFlight = startRobotFlight();\n\nvar triggerStars = function triggerStars(e) {\n    var update = robot[1](e).update;\n    var star_count = wW > 540 ? 25 : 15;\n    var makeStars = robot[1]();\n    makeStars.createStars(star_count, update);\n};\n\nvar ScrollAnimate = function (_Navigation) {\n    _inherits(ScrollAnimate, _Navigation);\n\n    function ScrollAnimate() {\n        _classCallCheck(this, ScrollAnimate);\n\n        var _this9 = _possibleConstructorReturn(this, (ScrollAnimate.__proto__ || Object.getPrototypeOf(ScrollAnimate)).call(this));\n\n        _this9.sections = document.querySelectorAll('#section-one-digital, #section-two-popups, .section-three-robot, #section-five-web  ');\n        return _this9;\n    }\n\n    _createClass(ScrollAnimate, [{\n        key: \"checkElemTop\",\n        value: function checkElemTop(e) {\n            var length = this.sections.length;\n\n            while (length--) {\n                var dist = this.getDistance(this.sections[length]);\n                var elmTop = dist.top;\n                var elmHeight = dist.height;\n                var elmBottom = dist.bottom;\n\n                //Digital Hand\n                if (length === 0) {\n\n                    if (elmBottom < 300) {\n                        if (wW < 768) document.getElementById('digital_shake').style.willChange = \"auto\";\n                        digital.removeDigitalAnimation();\n                        toggleAnimate.circuit = false;\n                    }\n                }\n                //Map\n                if (length === 1) {\n                    var pointerLocation = _('oval-pointer').getBoundingClientRect().x;\n\n                    //Stops scroll from running hovermap function over and over\n                    if (pointerLocation > 0) {\n                        var hovermap = hoverMap();\n                        var _dist3 = hovermap[1](e)[0]; // Position distance of show-icon gooey\n                        hovermap[0](_dist3, true); // handler(e) function remove gooey\n                    }\n                }\n                // Robot Design stars element\n                if (length === 2) {\n\n                    //Page in view start animate stars\n                    if (elmTop <= elmHeight && elmBottom >= elmHeight && toggleAnimate.stars) {\n\n                        toggleAnimate.stars = false;\n                        toggleStars.toggle = false;\n                        triggerStars(e);\n                    }\n                    //Page out of view start stop animate\n                    if (!toggleAnimate.stars && (elmTop > elmHeight || elmBottom <= 0)) {\n                        toggleAnimate.stars = true;\n                        toggleStars.toggle = true;\n                    }\n                }\n                //Flying Robot / Graph element\n                if (length === 3) {\n\n                    if (elmTop < elmHeight) {\n\n                        if (!_('floating_robot').style.willChange) {\n                            _('floating_robot').style.willChange = 'transform';\n                        }\n                    }\n\n                    if (elmTop < elmHeight / 2 && elmBottom >= elmHeight && toggleAnimate.flightStars) {\n                        toggleRobot.flight = false;\n                        toggleAnimate.flightStars = false;\n                        requestAnimationFrame(robotFlight.drawBurners);\n                        robotFlight.flyIntoPlace.createStars('up');\n                        requestAnimationFrame(robotFlight.flyIn);\n                    }\n                    if (!toggleAnimate.flightStars && (elmTop > elmHeight - 75 || elmBottom <= 0)) {\n\n                        //Removes ray\n                        _('floating_robot').style.willChange = 'auto';\n                        // _('rec-clip').style.display = 'none'\n                        toggleAnimate.flightStars = true;\n                        toggleRobot.flight = true;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"scroll\",\n        value: function scroll() {\n            var _this10 = this;\n\n            window.addEventListener('scroll', function (e) {\n                // If nav item is clicked that scroll event will run and not trigger this scroll event\n                if (navToggle.toggle) {\n\n                    _this10.checkElemTop(e);\n                }\n            });\n        }\n    }]);\n\n    return ScrollAnimate;\n}(Navigation);\n\nvar scrollAnimate = new ScrollAnimate();\nscrollAnimate.scroll();\n\n//*** HAND SHAKE ***\n\nvar Digital = function () {\n    function Digital() {\n        _classCallCheck(this, Digital);\n\n        this.path = document.querySelectorAll('.stroke');\n        this.watch = document.getElementById('rotate_watch');\n    }\n\n    _createClass(Digital, [{\n        key: \"startHandAnimation\",\n        value: function startHandAnimation() {\n            var _this11 = this;\n\n            document.getElementById('digital_shake').classList.add('shake-hand');\n            this.watch.classList.add('rotateWatch');\n            setTimeout(function () {\n                for (var i = 0; i < _this11.path.length; i++) {\n                    if (i < 3) _('circle-path')[i].style.opacity = 1;\n                    _this11.path[i].classList.add('path');\n                }\n            }, 2000);\n        }\n    }, {\n        key: \"removeDigitalAnimation\",\n        value: function removeDigitalAnimation() {\n            this.watch.classList.remove('rotateWatch');\n            for (var i = 0; i < this.path.length; i++) {\n                this.path[i].classList.remove('path');\n            }\n        }\n    }]);\n\n    return Digital;\n}();\n\nvar circuitToggle = {\n    toggleAnim: true\n    //brad-joshua\n};\nvar Circuit = function (_Digital) {\n    _inherits(Circuit, _Digital);\n\n    function Circuit() {\n        _classCallCheck(this, Circuit);\n\n        var _this12 = _possibleConstructorReturn(this, (Circuit.__proto__ || Object.getPrototypeOf(Circuit)).call(this));\n\n        _this12.animCircuit = _('animate-circuit');\n        _this12.startAnimation = _this12.startAnimation.bind(_this12);\n        _this12.data = [];\n        _this12.elements = [];\n        _this12.index = [];\n        _this12.pathLength = [];\n        return _this12;\n    }\n    //SVG .getTotalLength() fix\n\n\n    _createClass(Circuit, [{\n        key: \"getSvgPolylineLength\",\n        value: function getSvgPolylineLength(el) {\n            var totalLength = 0;\n            var prevPos = void 0;\n            for (var i = 0; i < el.points.numberOfItems; i++) {\n                var pos = el.points.getItem(i);\n                if (i > 0) {\n\n                    totalLength += Math.sqrt(Math.pow(pos.x - prevPos.x, 2) + Math.pow(pos.y - prevPos.y, 2));\n                }\n                prevPos = pos;\n            }\n            return totalLength;\n        }\n        //SVG .getTotalLength() fix\n\n    }, {\n        key: \"getSvgEementLength\",\n        value: function getSvgEementLength(el) {\n\n            var constructor = el.constructor;\n\n            switch (constructor) {\n                case SVGPolylineElement:\n                    return this.getSvgPolylineLength(el);\n                case SVGLineElement:\n                    return function (x1, x2, y1, y2) {\n                        return Math.sqrt((x2 -= x1) * x2 + (y2 -= y1) * y2);\n                    }(el.getAttribute('x1'), el.getAttribute('x2'), el.getAttribute('y1'), el.getAttribute('y2'));\n                case SVGRectElement:\n                    return el.getAttribute('width') * 2 + el.getAttribute('height') * 2;\n                case SVGPathElement:\n                    return el.getTotalLength();\n            }\n        }\n        //3rd method ran\n\n    }, {\n        key: \"getDashStroke\",\n        value: function getDashStroke(el) {\n            var length = el.length;\n\n            while (length--) {\n                var index = el[length];\n                // Fix for SVG.getTotalLength()  not working on some paths. \n                this.pathLength.unshift(this.getSvgEementLength(_('animate-circuit')[index]));\n            }\n        }\n    }, {\n        key: \"addClasses\",\n        value: function addClasses() {\n            var length = this.elements.length;\n            while (length--) {\n                this.elements[length].classList.add('animatePath');\n            }\n        }\n        //2nd method ran\n\n    }, {\n        key: \"getRandomPath\",\n        value: function getRandomPath(paths) {\n            var i = 0;\n            var length = paths;\n\n            while (i < length) {\n                // item is the long-path which is at index 0 if count === 1, else run random \n                var item = paths === 1 ? 10 : Math.floor(Math.random() * 10);\n\n                //Checks first to make sure no duplicate items in array\n                var notInArray = this.index.indexOf(item) === -1;\n\n                if (notInArray) {\n                    i++;\n                    this.index.push(item);\n                    this.elements.push(this.animCircuit[item]);\n                }\n            }\n\n            this.animCircuit = this.elements;\n            return this.index;\n        }\n        //4th method ran\n\n    }, {\n        key: \"addData\",\n        value: function addData(index) {\n\n            while (index--) {\n                this.data.push({ speed: 0, j: 0, delay: index * 150, start: 0, startTime: 0 });\n            }\n            this.startAnimation();\n        }\n        //1st method ran\n\n    }, {\n        key: \"setDashArray\",\n        value: function setDashArray(count) {\n            var paths = wW < 768 ? 1 : count;\n            if (wW < 768) this.startHandAnimation();\n            var index = this.getRandomPath(paths);\n            this.getDashStroke(index);\n\n            while (paths--) {\n                this.animCircuit[paths].style.stroke = 'orange';\n                this.animCircuit[paths].style.strokeDashoffset = -this.pathLength[paths];\n                this.animCircuit[paths].style.strokeDasharray = this.pathLength[paths];\n            }\n            this.addData(wW < 768 ? 3 : 6);\n        }\n\n        //Ran last\n\n    }, {\n        key: \"startAnimation\",\n        value: function startAnimation() {\n            var circle = _('circle-path');\n            var dist = this.pathLength;\n            var el = this.animCircuit;\n            var data = this.data;\n            var length = el.length;\n            var countSpeed = 7;\n            var dataLength = data.length;\n            var delay = 0;\n\n            function startCircleAnimation(timestamp) {\n\n                for (var i = 0; i < dataLength; i++) {\n\n                    if (delay > data[i].delay) {\n\n                        if (!data[i].startTime) data[i].startTime = timestamp;\n                        var run = timestamp - data[i].startTime;\n                        var prog = Math.min(run / 30000, 1);\n\n                        var _el$0$getPointAtLengt = el[0].getPointAtLength(dist[0] * prog),\n                            x = _el$0$getPointAtLengt.x,\n                            y = _el$0$getPointAtLengt.y;\n\n                        circle[i].style.transform = \"translate(\" + x + \"px, \" + y + \"px)\";\n                        if (prog === 1) data[i].startTime = 0;\n                    }\n                }\n                delay++;\n\n                requestAnimationFrame(startCircleAnimation);\n            }\n\n            function startLineAnimation() {\n                //Removes Animation\n                if (!toggleAnimate.circuit) {\n                    var i = el.length;\n\n                    while (i--) {\n                        el[i].removeAttribute('style');\n                    }\n                    return;\n                }\n\n                for (var _i3 = length - 1; _i3 >= 0; _i3--) {\n                    var dashArray = el[_i3].style.strokeDasharray;\n                    var dashOffset = el[_i3].style.strokeDashoffset;\n\n                    // StrokeDashoffset is less then 0 runs same direction \n                    if (dashOffset >= 0 && !data[_i3].j) {\n                        data[_i3].speed = 0;\n                        data[_i3].j = 1;\n                        _iterator4 = 0;\n                    }\n\n                    var speed = data[_i3].speed += countSpeed;\n                    var _iterator4 = dashOffset <= 0 ? -dist[_i3] : 0;\n\n                    //Stops strokedasharray at about a 3rd to keep the length that size\n                    if (dashArray >= dist[_i3] / 1.8) {\n\n                        el[_i3].style.strokeDasharray = dist[_i3] - speed;\n                    }\n\n                    el[_i3].style.strokeDashoffset = _iterator4 + speed;\n                }\n                requestAnimationFrame(startLineAnimation);\n            }\n            requestAnimationFrame(wW < 768 ? startCircleAnimation : startLineAnimation);\n        }\n    }]);\n\n    return Circuit;\n}(Digital);\n\nvar digital = new Digital();\nvar circuit = new Circuit();\n\nwindow.onload = function (e) {\n    setTimeout(function () {\n        circuit.setDashArray(6);\n    }, 300);\n\n    var newTechnologies = new Technologies();\n    newTechnologies.loadImages();\n\n    document.querySelector('.technologies .start-canvas').addEventListener('click', function () {\n        Technologies.prototype.toggle = true;\n        requestAnimationFrame(newTechnologies.draw.bind(newTechnologies));\n    }.bind(this));\n\n    document.querySelector('.technologies .stop-canvas').addEventListener('click', function () {\n        Technologies.prototype.toggle = false;\n        requestAnimationFrame(newTechnologies.draw.bind(newTechnologies));\n    }.bind(this));\n\n    var starryNight = new StarryNight();\n    starryNight.loadImages();\n\n    hoverMap();\n\n    var designSlider = new DesignSlider();\n    designSlider();\n\n    robot[1](); //updates robot location\n    robot[0].loadImages(); //then loades images into slider\n\n    robotFlight.flyIntoPlace.hideRobot(1.3); //Hides flying robot out of screen view\n}.bind(undefined);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbWFpbi5qcz8yZWUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqKioqKiAgR0xPQkFMIFZBUklBQkxFUyAgKioqKioqKi8gXG5jb25zdCBhbmltYXRlNzY4ID0gXCJNNTY1LjEsMHY5MDBIMGMwLDAsMC03NS4zLDAtMTkyLjRjMC0yMTEuNywwLTMwMy43LDAtNTMzLjFDMCw1MC41LDAsMCwwLDBINTY1LjF6O1wiK1xuICAgICAgICAgICAgICAgICBcIk01NjUuMSwwdjkwMEgxODIuN2MwLDAtNDQtNzIuNS00NC0xOTEuN2MwLTEwNy41LDEyMS44LTM5Ni4xLDEyMS44LTUzMy44QzI2MC41LDQxLDI0NS45LDAsMjQ1LjksMEg1NjUuMXo7XCIrXG4gICAgICAgICAgICAgICAgIFwiTTU3MS44LDB2OTAwSDM4Ni43YzAsMC0zMS40LTQyLjctMzEuNC0xOTEuN0MzNTUuMyw1NjgsNTU1LDI4NSw1NTUsODAuN0M1NTUsMjAsNTUxLjUsMCw1NTEuNSwwSDU3MS44ejtcIitcbiAgICAgICAgICAgICAgICAgXCJNNTczLDB2OTAwaC0yLjNjMCwwLDAuNC02NS4yLDAuNC0xOTIuNGMwLTE3Ni44LTAuMi0zNDcuOS0wLjItNTMzLjRjMC0xMjQtMC4yLTE3NC4yLTAuMi0xNzQuMkg1NzN6XCI7XG5cbmNvbnN0IGFuaW1hdGU0MDAgPSBcIk0zOTAsODAwSDZjMCwwLTYtNDUuOS02LTE2MS4zQzAsNDQzLjYsNSwyODYuMSw1LDQ3LjNDNSwxMC43LDMsMCwzLDBoMzg3VjgwMHo7XCIrXG4gICAgICAgICAgICAgICAgIFwiTTM5MCw4MDBIOTZjMCwwLTQ2LTQ1LjktNDYtMTYxLjNjMC0xOTUuMSwxMzAtMzUyLjYsMTMwLTU5MS4zYzAtMzYuNy0zLTQ3LjMtMy00Ny4zaDIxM1Y4MDB6O1wiK1xuICAgICAgICAgICAgICAgICBcIk0zOTAsODAwSDI0M2MwLDAtMzctNDUuOS0zNy0xNjEuM2MwLTE5NS4xLDE3Ni0zNTIuNiwxNzYtNTkxLjNjMC0zNi43LTEtNDcuMy0xLTQ3LjNoOVY4MDB6O1wiK1xuICAgICAgICAgICAgICAgICBcIk0zOTAsODAwaC03YzAsMCwwLTQ1LjksMC0xNjEuM2MwLTE5NS4xLDUtMzUyLjYsNS01OTEuM2MwLTM2LjctMS00Ny4zLTEtNDcuM2gzVjgwMHpcIjtcblxuY29uc3QgaXNGaXJlZm94ID0gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJztcbmNvbnN0IGlzU2FmYXJpID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKFwiU2FmYXJpXCIpICE9IC0xICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIkNocm9tZVwiKSA9PT0gLTE7XG4vL0lmIHVzZXIgaXMgb24gaXBhZCAvIGlwaG9uZSAvIGlwb2RcbmxldCBpc0lPUyA9IGZ1bmN0aW9uKCl7XG4gICAgbGV0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQgfHwgbmF2aWdhdG9yLnZlbmRvciB8fCB3aW5kb3cub3BlcmE7XG4gICAgcmV0dXJuIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KHVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbVxufVxuXG5jb25zdCB3VyA9IHdpbmRvdy5pbm5lcldpZHRoO1xuY29uc3Qgd0ggPSB3aW5kb3cuaW5uZXJIZWlnaHQ7XG5sZXQgbGFzdERpc3Q7XG5cblxuXG5cbi8vRmlyZWZveCBCdWcsIHRyYW5zZm9ybXMgbm90IHdvcmtpbmcsIHNvIHNldHMgYXR0cmlidXRlIHRvIDAgaW5zdGVhZFxuaWYoaXNGaXJlZm94KXtcbiAgICAvL3N2ZyBtb3JmaW5nIHByb2JsZW1cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZmVHYXVzc2lhbkJsdXInKVswXS5zZXRBdHRyaWJ1dGUoJ3N0ZERldmlhdGlvbicsICc2JylcbiAgICAvL3N2ZyBjc3MgcHJvYmxlbVxuICAgIF8oJ3N2Zy1jaXJjbGUnKS5zZXRBdHRyaWJ1dGUoJ3InLCAwKTtcbiAgICBfKCdzdmctY2lyY2xlJykuc3R5bGUudHJhbnNmb3JtID0gJ3NjYWxlKDEpJ1xufSBcblxuaWYoaXNTYWZhcmkpIF8oJ3N2Zy1wYWdlJykuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCJcblxuZnVuY3Rpb24gXyhjbHNzKXtcblxuICAgIGxldCBjbGFzc2VzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbHNzKTtcblxuICAgIGlmKGNsYXNzZXMubGVuZ3RoID09PSAxKXtcbiAgICAgICAgcmV0dXJuIGNsYXNzZXNbMF1cbiAgICB9XG4gICAgaWYoY2xhc3Nlcy5sZW5ndGggPiAxKXtcbiAgICAgICAgcmV0dXJuIGNsYXNzZXNcbiAgICB9ZWxzZSByZXR1cm4gXCJOb3QgYSB3b3JraW5nIGNsYXNzXCJcbn07XG5cbnZhciBlYXNlT3V0ID0gZnVuY3Rpb24ocHJvZ3Jlc3Mpe1xuICAgIHJldHVybiBNYXRoLnBvdygtLXByb2dyZXNzLCA1KSArIDE7XG59O1xuXG4vL1N0cmluZzogaW5kaWNhdGVzIG5ldyBzaXplIG9mIHdpZHRoIG9yIGhlaWdodCB0aGF0IHlvdSB3YW50LiBTaXplOiBvZiB0aGUgbmV3IHNpemUgb2YgdGhlIHN0cmluZy4gRWw6IHRoZSBlbGVtZW50IHlvdSB3YW50IGl0IGZvclxudmFyIG5ld1NpemUgPSBmdW5jdGlvbihzdHJpbmcsIHNpemUsIGVsKXtcbiAgICBpZih0eXBlb2YgZWwgICE9PSAndW5kZWZpbmVkJyl7XG4gICAgICAgIFxuXG4gICAgICAgIHZhciBvZ1dpZHRoID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcbiAgICAgICAgdmFyIG9nSGVpZ2h0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gICAgICAgIGlmKG9nV2lkdGggPT09IDAgfHwgb2dIZWlnaHQgPT09IDApe1xuICAgICAgICAgICAgb2dXaWR0aCA9IGVsLmdldEF0dHJpYnV0ZSgnd2lkdGgnKVxuICAgICAgICAgICAgb2dIZWlnaHQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpXG4gICAgICAgIH1cbiAgICB9ZWxzZXtcbiAgICAgICAgdmFyIG9nV2lkdGggPSA3NjIuMjJcbiAgICAgICAgdmFyIG9nSGVpZ2h0ID0gNjY4Ljk3XG4gICAgfVxuICAgIFxuICAgIGlmKHN0cmluZyA9PT0gJ2hlaWdodCcgKXtcbiAgICAgICAgbGV0IHJhdGlvID0gb2dIZWlnaHQgLyBzaXplXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IHNpemUsXG4gICAgICAgICAgICB3aWR0aDogb2dXaWR0aCAvIHJhdGlvXG4gICAgICAgIH1cblxuICAgIH1lbHNlIGlmKHN0cmluZyA9PT0gJ3dpZHRoJyApe1xuICAgICAgICBsZXQgcmF0aW8gPSBvZ1dpZHRoIC8gc2l6ZVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHNpemUsXG4gICAgICAgICAgICBoZWlnaHQ6IG9nSGVpZ2h0IC8gcmF0aW9cbiAgICAgICAgfVxuICAgIH1lbHNlIGNvbnNvbGUubG9nKCdjaGVjayBwYXJhbWV0ZXJzJyk7XG59XG5cblxuV2ViRm9udC5sb2FkKHtcbiAgICBnb29nbGU6IHtcbiAgICAgIGZhbWlsaWVzOiBbJ0RvIEh5ZW9uJywgJ09yYml0cm9uJ11cbiAgICB9LFxuICAgIGFjdGl2ZTogZnVuY3Rpb24oKXtcbiAgICAgICAgLy9TdGFydHMgd2hlbiBnb29nbGUgZm9udHMgYXJlIGxvYWRlZCAgICAgXG4gICAgICAgIHNsb3RNYWNoaW5lKCk7XG4gICAgICAgIFN0cmV0Y2goKTtcbiAgICB9XG59KVxuXG5mdW5jdGlvbiBzbG90TWFjaGluZSgpe1xuXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzbG90LW1hY2hpbmUnKTtcbiAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBcbiAgICB2YXIgU2xvdCA9IGZ1bmN0aW9uKCl7XG5cdCAgICB0aGlzLnggPSAwO1xuXHRcdHRoaXMud2lkdGggPSBjYW52YXMud2lkdGggPSB3VyA8IDk3MCA/IDM2MCA6IDQ3NTtcblx0ICAgIHRoaXMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IHdXIDwgOTcwID8gMzYwIDogNDc1O1xuXHRcdHRoaXMudGV4dCA9ICdQSE9UTydcblx0ICAgIHRoaXMubGV0dGVycyA9IFtdO1xuXG5cdCAgICB0aGlzLmFkZExldHRlciA9IGZ1bmN0aW9uKG4pe1xuXG5cdCAgICAgICAgdmFyIGxldHRlckhlaWdodCA9IHdXIDwgOTcwID8gLTEyNCA6IC0xNTg7XG5cblx0ICAgICAgICAvL1BsYWNlcyBsZXR0ZXJzIGF0IHRvcCBpbmRleCAxLDMsNVxuXHQgICAgICAgIHZhciBib3R0b20gPSB3VyA8IDk3MCA/IHRoaXMuaGVpZ2h0ICsgNjAgOiB0aGlzLmhlaWdodCArIDk2O1xuXHQgICAgICAgIGZvcih2YXIgaiA9IDA7IGogPCBuOyBqKysgKXtcblx0ICAgICAgICAgICAgLy9SZXNldHMgeCBldmVyeSBpdGVyYXRpb25cblx0ICAgICAgICAgICAgdGhpcy54ID0gMFxuXHQgICAgICAgICAgICAvL0FkanVzdCBib3R0b20gYW5kIGhlaWdodCBhbGwgbGV0dGVyc1xuXHQgICAgICAgICAgICBsZXR0ZXJIZWlnaHQgPSB3VyA8IDk3MCA/IGxldHRlckhlaWdodCArIDEyMSA6IGxldHRlckhlaWdodCArIDE1OFxuXHQgICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy50ZXh0Lmxlbmd0aDsgaSsrKXtcblxuXHQgICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdG9wOiBsZXR0ZXJIZWlnaHQsXG5cdCAgICAgICAgICAgICAgICAgICAgbGV0dGVyOiB0aGlzLnRleHRbaV0sXG5cdCAgICAgICAgICAgICAgICAgICAgeDogaSA9PT0gMCA/IC01IDogd1cgPCA5NzAgPyB0aGlzLngrPTc0IDogdGhpcy54Kz0xMDAuOCxcblx0ICAgICAgICAgICAgICAgICAgICBzcGVlZDogOSwgXG5cdCAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBib3R0b20gLSBsZXR0ZXJIZWlnaHQsXG5cdCAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGkgJSAyID09PSAwID8gXCJ1cFwiIDogXCJkb3duXCJcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG4gPT09IDQgPyB0aGlzLmxldHRlcnMucHVzaChkYXRhKSA6IHRoaXMubGV0dGVycy51bnNoaWZ0KGRhdGEpXG5cblx0ICAgICAgICAgICAgICAgIHZhciBsZXR0ZXIgPSBkYXRhXG5cdCAgICAgICAgXG5cdCAgICAgICAgICAgICAgICBpZihpJTIgPT09IDApe1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd1VwKGxldHRlcilcblx0ICAgICAgICAgICAgICAgIH1lbHNle1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiggd1cgPCA5NzAgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2ZpeGVzIHNwYWNpbmcgaXNzdWUgT3JiaXRyb24gZm9udFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPT09IDMgPyBsZXR0ZXIueCArPSAzIDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgPT09IDEgPyBsZXR0ZXIueCAtPSAzIDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhd0Rvd24obGV0dGVyKVxuXHQgICAgICAgICAgICAgICAgfSBcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH1cblx0ICAgdGhpcy5hZGRMZXR0ZXIoNClcblx0fVxuXG4gICAgU2xvdC5wcm90b3R5cGUuZHJhd1VwID0gZnVuY3Rpb24odGV4dCl7XG4gICAgICBcbiAgICAgICAgY3R4LmZvbnQgPSB3VyA8IDk3MCA/ICBcIkJvbGQgNjJwdCBPcmJpdHJvblwiIDogXCIxMDVwdCBEbyBIeWVvblwiO1xuICAgICAgICBjdHguZmlsbFRleHQodGV4dC5sZXR0ZXIsdGV4dC54LCB0ZXh0LmJvdHRvbSlcbiAgICB9XG4gICAgU2xvdC5wcm90b3R5cGUuZHJhd0Rvd24gPSBmdW5jdGlvbih0ZXh0KXtcbiAgICAgICAgXG5cdFx0Y3R4LmZpbGxTdHlsZSA9IFwiIzBEMUI1NlwiO1xuICAgICAgICAgY3R4LmZvbnQgPSB3VyA8IDk3MCA/IFwiQm9sZCA2MnB0IE9yYml0cm9uXCIgOiBcIjEwNXB0IERvIEh5ZW9uXCI7XG4gICAgICAgIGN0eC5maWxsVGV4dCh0ZXh0LmxldHRlcix0ZXh0LngsIHRleHQudG9wKVxuXG4gICAgfVxuXG4gICAgU2xvdC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oKXtcblxuICAgICAgICAvLyB2YXIgcHVzaCA9IHdXIDwgOTcwID8gLTYxIDogLTc0XG4gICAgICAgIHZhciBwdXNoID0gd1cgPCA5NzAgPyAtNjEgOiAtNzVcbiAgICBcdGlmKCFzbG90TWFjaGluZS5wcm90b3R5cGUudG9nZ2xlKSByZXR1cm47XG4gICAgXG4gICAgICAgIC8vTmV3IHNldCBpZiBsZXR0ZXJzIGRyYXduIGJhc2VkIG9uIHNwYWNpbmdcbiAgICAgICAgaWYodGhpcy5sZXR0ZXJzWzE5XS5ib3R0b20gPD0gcHVzaCApe1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMubGV0dGVycy5zcGxpY2UoMTUsNSlcbiAgICAgICAgICAgIHRoaXMuYWRkTGV0dGVyKDEpXG4gICAgICAgIH1cblxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsMCxjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG4gICAgICAgIFxuICAgIFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGV0dGVycy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbGV0dGVyID0gdGhpcy5sZXR0ZXJzW2ldXG5cbiAgICAgICAgICAgIGxldHRlci50b3AgKz0gbGV0dGVyLnNwZWVkIFxuICAgICAgICAgICAgbGV0dGVyLmJvdHRvbSAtPSBsZXR0ZXIuc3BlZWQgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKGxldHRlci5zdGFydCA9PT0gXCJ1cFwiKXtcblxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd1VwKGxldHRlcilcblxuICAgICAgICAgICAgfWVsc2UgdGhpcy5kcmF3RG93bihsZXR0ZXIpXG4gICAgXHR9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKVxuICAgIH1cbiAgICB2YXIgc2xvdCA9IG5ldyBTbG90KClcbiAgICBcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGhvdG8gLnN0YXJ0LWNhbnZhcycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgICAgXG4gICAgXHQvL1N0YXJ0IENhbnZhc1xuICAgIFx0c2xvdE1hY2hpbmUucHJvdG90eXBlLnRvZ2dsZSA9IHRydWVcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHNsb3QudXBkYXRlLmJpbmQoc2xvdCkpXG4gICAgfSk7XG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcucGhvdG8gLnN0b3AtY2FudmFzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgXHQvL1N0b3AgQ2FudmFzXG4gICAgXHRzbG90TWFjaGluZS5wcm90b3R5cGUudG9nZ2xlID0gZmFsc2VcbiAgICB9KTtcblxufVxuXG5cblxuZnVuY3Rpb24gU3RyZXRjaCgpe1xuXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdHJldGNoJyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBcbiAgICBpZih3VyA8IDk3MCl7XG4gICAgICAgIHZhciB3aWR0aCA9IDQwMFxuICAgICAgICB2YXIgaGVpZ2h0ID0gIDM3NVxuICAgICAgICB2YXIgc3RydGNoID0gMTVcbiAgICAgICAgdmFyIGxldHRlckRpc3QgPSA1M1xuICAgICAgICB2YXIgeCA9IDY1XG4gICAgICAgIHZhciBzdHJldGNoWCA9IDVcbiAgICAgICAgdmFyIG1peGVkTnVtID0gNVxuICAgIH1cbiAgICBpZih3VyA8IDQwMCl7XG4gICAgICAgIHZhciB3aWR0aCA9IDM2MFxuICAgICAgICB2YXIgaGVpZ2h0ID0gIDM3NVxuICAgICAgICB2YXIgeCA9IDUwXG4gICAgICAgIHZhciBtaXhlZE51bSA9IC0xMFxuICAgIH1cbiAgICBpZih3VyA+IDk3MCl7XG4gICAgICAgIHZhciB3aWR0aCA9IDY1MFxuICAgICAgICB2YXIgaGVpZ2h0ID0gIDQ1MFxuICAgICAgICB2YXIgc3RydGNoID0gMzBcbiAgICAgICAgdmFyIGxldHRlckRpc3QgPSA2NVxuICAgICAgICB2YXIgeCA9IDEyNVxuICAgICAgICB2YXIgbWl4ZWROdW0gPSA1XG4gICAgfVxuICAgIC8qKiBDSEFOR0UgTlVNQkVSIEZPUiBsaW5lQ291bnQgVE8gQUREIE9SIFNVQlRSQUNUIEhPVyBNQU5ZIExJTkVTIE9GIFdPUkRTICoqL1xuICAgIHZhciBsaW5lQ291bnQgPSA3O1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIHQgPSBsaW5lQ291bnQgLSAxO1xuICAgIHZhciBjb2xvcnMgPSBbXCIjREFGN0E2XCIsIFwiI0ZGQzMwMCBcIiwgXCIjRkY1NzMzXCIsIFwiI0M3MDAzOVwiLCBcIiM5MDBDM0ZcIiwgXCIjNTgxODQ1XCIsIFwiIzM3MTAyYlwiXVxuICAgIHZhciBMZXR0ZXJzID0gZnVuY3Rpb24oKXtcbiAgICAgICAgLy8gdGhpcy50ZXh0ID0gJ1NPTFVUSU9OUydcbiAgICAgICAgdGhpcy5sZXR0ZXJzID0gW107XG4gICAgICAgIHRoaXMudG90YWwgPSB0aGlzLmxldHRlcnMubGVuZ3RoIC0gMVxuICAgICAgICB0aGlzLnRvdGFsID0gMDtcbiAgICAgICAgdGhpcy55ID0gMDtcblxuICAgICAgICBcbiAgICAgICAgdGhpcy53aWR0aCA9IGNhbnZhcy53aWR0aCA9IHdpZHRoXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IGhlaWdodFxuICAgICAgICB0aGlzLnRleHQgPSAnREVWRUxPUEVSJ1xuICAgICAgICBcbiAgICAgICAgdGhpcy5wdXNoTGV0dGVycyA9IGZ1bmN0aW9uKHgsIGRpc3Qpe1xuICAgICAgICAgICAgLy9JZiBwdXNoTGV0dGVycyBpcyByYW4gYWdhaW4gbWFrZXMgc3VyZSB0aGlzLnkgPSAwXG4gICAgICAgICAgICBpZih0aGlzLnkpIHRoaXMueSA9IDBcbiAgICAgICAgICAgIHZhciBjYW52YXNIZWlnaHQgPSB0aGlzLmhlaWdodFxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGxpbmVDb3VudDsgaSsrKXtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVyOiB0aGlzLnRleHQsXG4gICAgICAgICAgICAgICAgICAgIHN0cmV0Y2g6IHN0cnRjaCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHNwZWVkOiBpLFxuICAgICAgICAgICAgICAgICAgICBkaXN0OiB0eXBlb2YgZGlzdCA9PT0gJ251bWJlcicgPyBkaXN0IDogMCxcbiAgICAgICAgICAgICAgICAgICAgLy9MZXR0ZXJzIGRpc3RhbmNlIGJldHdlZW4gZWFjaCBvdGhlciB2aXJ0aWNsZSBcbiAgICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiB0aGlzLnkgKz0gbGV0dGVyRGlzdCxcbiAgICAgICAgICAgICAgICAgICAgIC8vTGV0dGVycyBzdGFydCBvbiB0aGUgYm90dG9tXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogd1cgPCA5NzAgPyBjYW52YXNIZWlnaHQgKyA0NSA6IGNhbnZhc0hlaWdodCArIDYyLFxuICAgICAgICAgICAgICAgICAgICBiZWdpbjogMSxcbiAgICAgICAgICAgICAgICAgICAgLy9XaGVuIHRoZSBuZXh0IHJvdGF0aW9uIHN0YXJ0c1xuICAgICAgICAgICAgICAgICAgICBiZWdpblk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHNjYWxlVG90YWw6IDQsXG4gICAgICAgICAgICAgICAgICAgIGRpc3RZOiAwLFxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3JzW2ldXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubGV0dGVycy5wdXNoKGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdXNoTGV0dGVycyh4KVxuICAgIH1cblxuICAgIHZhciBkcmF3VXAgPSBmdW5jdGlvbihsZXR0ZXIsIGRpc3Qpe1xuXG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsIGxldHRlci5zY2FsZSxsZXR0ZXIueCwgbGV0dGVyLmJvdHRvbSAtIGRpc3QgKVxuICAgICAgICBjdHguZm9udCA9IHdXIDwgOTcwID8gXCI0MHB0IERvIEh5ZW9uXCIgOiBcIjYwcHQgRG8gSHllb25cIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxldHRlci5jb2xvclxuICAgICAgICBjdHguZmlsbFRleHQobGV0dGVyLmxldHRlciwgMCwgbGV0dGVyLnRleHRZKTtcbiAgICAgICAgLy8gdmFyIHRleHQgPSBjdHgubWVhc3VyZVRleHQobGV0dGVyLmxldHRlcilcbiAgICB9XG4gICAgdmFyIHN0cmV0Y2ggPSBmdW5jdGlvbih0ZXh0KXtcbiAgICAgICAgY3R4LmNhbnZhcy5zdHlsZS5sZXR0ZXJTcGFjaW5nID0gdGV4dC5kaXN0ICsncHgnXG4gICAgICAgIGN0eC5mb250ID0gd1cgPCA5NzAgPyBcIjQwcHQgRG8gSHllb25cIiA6IFwiNjBwdCBEbyBIeWVvblwiO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGV4dC5jb2xvclxuICAgICAgICBjdHguZmlsbFRleHQodGV4dC5sZXR0ZXIsIHRleHQueCwgdGV4dC5ib3R0b20gLSB0ZXh0LmRpc3RhbmNlIClcbiAgICB9XG5cbiAgICB2YXIgZHJhd0Rvd24gPSBmdW5jdGlvbihsZXR0ZXIpe1xuICAgICAgICBjdHguZm9udCA9IHdXIDwgOTcwID8gXCI0MHB0IERvIEh5ZW9uXCIgOiBcIjYwcHQgRG8gSHllb25cIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxldHRlci5jb2xvclxuICAgICAgICBjdHguZmlsbFRleHQobGV0dGVyLmxldHRlciwgbGV0dGVyLngsIGxldHRlci55KVxuICAgIH1cblxuICAgIHZhciBkcmF3QmFja0ZsaXAgPSBmdW5jdGlvbihsZXR0ZXIpe1xuICAgICAgICBjdHguZm9udCA9IHdXIDwgOTcwID8gXCI0MHB0IERvIEh5ZW9uXCIgOiBcIjYwcHQgRG8gSHllb25cIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGxldHRlci5jb2xvclxuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsMCwwLCBsZXR0ZXIuc2NhbGUsbGV0dGVyLngsIGxldHRlci55IClcbiAgICAgICAgY3R4LmZpbGxUZXh0KGxldHRlci5sZXR0ZXIsIDAsIGxldHRlci50ZXh0WSk7XG4gICAgfVxuICAgIFxuICAgIExldHRlcnMucHJvdG90eXBlLmFkZExldHRlcnMgPSBmdW5jdGlvbih0aW1lc3RhbXApe1xuXG4gICAgXHRpZighU3RyZXRjaC5wcm90b3R5cGUudG9nZ2xlKSByZXR1cm47XG4gICAgICAgXHR2YXIgaiA9IDA7XG5cdFxuICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLXVuZGVyJztcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCk7XG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwwLGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodClcblxuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZXR0ZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGxldHRlciA9IHRoaXMubGV0dGVyc1tpXTtcbiAgICAgICAgICAgIGxldHRlci55ID0gbGV0dGVyLmJvdHRvbSAtIGxldHRlci5kaXN0YW5jZVxuXG4gICAgICAgICAgICAvL0ZPVVJUSCBBTkQgTEFTVCBDQUxMLCBSRU1PVkUgV09SRFNcbiAgICAgICAgICAgIGlmKGNvdW50ID09PSAzICYmIGkgPT09IHQpIHtcblxuICAgICAgICAgICAgICAgIGlmKCFsZXR0ZXIuc3RhcnQpIGxldHRlci5zdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgIHZhciBydW50aW1lID0gdGltZXN0YW1wIC0gbGV0dGVyLnN0YXJ0XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gTWF0aC5taW4ocnVudGltZSAvIDYwMCwgMSlcbiAgICAgICAgICAgICAgICBsZXR0ZXIueSArPSAobGV0dGVyLmRpc3RhbmNlICogcHJvZ3Jlc3MpXG5cbiAgICAgICAgICAgICAgICBsZXR0ZXIuc2NhbGUgPSAwIHx8IChsZXR0ZXIuYmVnaW4gLSAoIGxldHRlci5zY2FsZVRvdGFsICogcHJvZ3Jlc3MpICkudG9GaXhlZCgyKVxuICAgICAgICAgICAgICAgIGxldHRlci50ZXh0WSA9ICAobGV0dGVyLmJlZ2luWSArICggbGV0dGVyLmRpc3RZICogcHJvZ3Jlc3MpICkudG9GaXhlZCgyKVxuICAgICAgICAgICAgICAgIGRyYXdCYWNrRmxpcChsZXR0ZXIpXG5cbiAgICAgICAgICAgICAgICAgaWYobGV0dGVyLnNjYWxlID09IC0xIHx8IGxldHRlci5zY2FsZSA8IC0xKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVyLmJlZ2luWSA9IDEwXG4gICAgICAgICAgICAgICAgICAgIGxldHRlci5kaXN0WSA9IHdXIDwgOTcwID8gLTUgOiAtMTBcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVyLnNjYWxlVG90YWwgPSAtNFxuICAgICAgICAgICAgICAgICAgICBsZXR0ZXIuYmVnaW4gPSAtM1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKCBwcm9ncmVzcyA9PT0gMSApe1xuICAgICAgICAgICAgICAgICAgICAvL1JlbW92ZXMgaXRlbSBmcm9tIGFycmF5IGFmdGVyIGVhY2ggd29yZCBpcyBmaW5pc2hlZCBhbmltYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZXR0ZXJzLnNwbGljZSh0LDEpXG4gICAgICAgICAgICAgICAgICAgIHQtLVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiggdCA9PT0gLTEgKXtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50b3RhbCA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGxpbmVDb3VudCAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGV0dGVycy5sZW5ndGggPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hMZXR0ZXJzKHgpXG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgMjAwKVxuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiggY291bnQgPT09IDMgJiYgaSAhPT0gdCApIGRyYXdEb3duKGxldHRlcilcblxuXG4gICAgICAgICAgICAvL1RISVJELCBMRVRURVIgU1RSRVRDSCBJTlxuICAgICAgICAgICAgaWYoIGNvdW50ID09PSAyICYmIGkgPT09IHQgKSB7XG4gICAgICAgICAgICAgICAgaWYoIWxldHRlci5zdGFydCkgbGV0dGVyLnN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgdmFyIHJ1bnRpbWUgPSB0aW1lc3RhbXAgLSBsZXR0ZXIuc3RhcnRcbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBNYXRoLm1pbihydW50aW1lIC8gMTI1LCAxKVxuICAgICAgICAgICAgICAgIGxldHRlci5kaXN0ID0gbGV0dGVyLnN0cmV0Y2ggLSAobGV0dGVyLnN0cmV0Y2ggKiBwcm9ncmVzcylcblxuICAgICAgICAgICAgICAgIGxldHRlci54ID0gbWl4ZWROdW0gKyAobGV0dGVyLnN0cmV0Y2ggKiBwcm9ncmVzcykgKiA0XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3RyZXRjaChsZXR0ZXIpXG5cbiAgICAgICAgICAgICAgIGlmKHByb2dyZXNzID09PSAxICl7XG4gICAgICAgICAgICAgICAgICAgIHQtLVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL1JFU0VUUyBWQVJJQUJMRVMsIENBTExTIEZVTkNUSU9OIEFMTCBPVkVSIEFHQUlOXG4gICAgICAgICAgICAgICAgaWYodCA9PT0gLTEpe1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrXG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gbGluZUNvdW50IC0gMVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sZXR0ZXJzLmxlbmd0aCA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHVzaExldHRlcnMoeCwgMClcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCAyMDApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoY291bnQgPT09IDIgJiYgaSAhPT0gdCkge1xuXG4gICAgICAgICAgICAgICAgc3RyZXRjaChsZXR0ZXIpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgICAvL1NFQ09ORCwgTEVUVEVSIFNUUkVUQ0ggT1VUXG4gICAgICAgICAgICBpZiggY291bnQgPT09IDEgJiYgaSA9PT0gaiApIHtcblxuICAgICAgICAgICAgICAgIGlmKCFsZXR0ZXIuc3RhcnQpIGxldHRlci5zdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgIHZhciBydW50aW1lID0gdGltZXN0YW1wIC0gbGV0dGVyLnN0YXJ0XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gTWF0aC5taW4ocnVudGltZSAvIDE1MCwgMSk7XG5cbiAgICAgICAgICAgICAgICBsZXR0ZXIuZGlzdCA9IGxldHRlci5zdHJldGNoICogcHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgbGV0dGVyLnggPSB4IC0gKGxldHRlci5kaXN0ICogNClcbiAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3RyZXRjaChsZXR0ZXIpXG5cbiAgICAgICAgICAgICAgICBpZiggcHJvZ3Jlc3MgPT09IDEgKXtcbiAgICAgICAgICAgICAgICAgICAgaisrXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYoIGogPT09IHRoaXMubGV0dGVycy5sZW5ndGggKXtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxldHRlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gLTUgYmVjYXVzZSBsZXR0ZXJzIHN0cmV0Y2hlZCB0byBmYXIsIG5lZWQgdG8gZml4IG51bWJlcnNcbiAgICAgICAgICAgICAgICAgICAgLy8gd1cgPCA5NzAgPyB0aGlzLnB1c2hMZXR0ZXJzKDUsIDE1KSA6IHRoaXMucHVzaExldHRlcnMoNSwgMzApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hMZXR0ZXJzKG1peGVkTnVtLCB3VyA8IDk3MCA/IDE1IDogMzAgKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCBjb3VudCA9PSAxICYmIGkgIT09IGogKSB7XG4gICAgICAgICAgICAgICAgbGV0dGVyLnggPSBsZXR0ZXIueFxuICAgICAgICAgICAgICAgIGxldHRlci5kaXN0ID0gbGV0dGVyLmRpc3RcbiAgICAgICAgICAgICAgICBzdHJldGNoKGxldHRlcilcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9GSVJTVCwgTEVUVEVSIENMSU1CRVxuICAgICAgICAgICAgaWYoIGkgPT09IGogJiYgY291bnQgPT09IDAgKXtcblxuICAgICAgICAgICAgICAgIGlmKCFsZXR0ZXIuc3RhcnQpIGxldHRlci5zdGFydCA9IHRpbWVzdGFtcCBcbiAgICAgICAgICAgICAgICB2YXIgcnVudGltZSA9IHRpbWVzdGFtcCAtIGxldHRlci5zdGFydFxuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IE1hdGgubWluKHJ1bnRpbWUgLyA2MDAsIDEpXG4gICAgICAgICAgICAgICAgdmFyIGRpc3QgPSBsZXR0ZXIuZGlzdGFuY2UgKiBwcm9ncmVzcztcbiAgICBcbiAgICAgICAgICAgICAgICBsZXR0ZXIuc2NhbGUgPSAwIHx8IChsZXR0ZXIuYmVnaW4gLSAoIGxldHRlci5zY2FsZVRvdGFsICogcHJvZ3Jlc3MpICkudG9GaXhlZCgyKVxuICAgICAgICAgICAgICAgIGxldHRlci50ZXh0WSA9ICAobGV0dGVyLmJlZ2luWSArICggbGV0dGVyLmRpc3RZICogcHJvZ3Jlc3MpICkudG9GaXhlZCgyKVxuICAgXG4gICAgICAgICAgICAgICAgZHJhd1VwKGxldHRlciwgZGlzdClcbiAgXG4gICAgICAgICAgICAgICAgLy9BZGRzIHNlY29uZCBmbGlwIHRvIG1ha2UgdXByaWdodCB0ZXh0IGhhbGYgd2F5IHVwIGNhbnZhc1xuICAgICAgICAgICAgICAgIGlmKGxldHRlci5zY2FsZSA9PSAtMSB8fCBsZXR0ZXIuc2NhbGUgPCAtMSl7XG4gICAgICAgICAgICAgICAgICAgIC8vV2hlbiB0aGUgbmV4dCByb3RhdGlvbiBzdGFydHMgZm9yIGJlZ2luWSBhbmQgZGlzdFlcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVyLmJlZ2luWSA9IHdXIDwgOTcwID8gNSA6IDEwXG4gICAgICAgICAgICAgICAgICAgIGxldHRlci5kaXN0WSA9IHdXIDwgOTcwID8gLTUgOiAtMTBcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVyLnNjYWxlVG90YWwgPSAtNFxuICAgICAgICAgICAgICAgICAgICBsZXR0ZXIuYmVnaW4gPSAtM1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiggcHJvZ3Jlc3MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgaisrXG4gICAgICAgICAgICAgICAgfSAgICAgIFxuICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiggaiA9PT0gdGhpcy5sZXR0ZXJzLmxlbmd0aCApe1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGV0dGVycy5sZW5ndGggPSAwO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hMZXR0ZXJzKHgsIDApXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYWRkTGV0dGVycy5iaW5kKHRoaXMpKVxuICAgIH1cbiAgICB2YXIgbGV0dGVycyA9IG5ldyBMZXR0ZXJzKClcblxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kZXZlbG9wZXIgLnN0YXJ0LWNhbnZhcycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG5cbiAgICAgICAgU3RyZXRjaC5wcm90b3R5cGUudG9nZ2xlID0gdHJ1ZVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIGxldHRlcnMuYWRkTGV0dGVycy5iaW5kKGxldHRlcnMpIClcbiBcbiAgICB9KTsgICBcblxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kZXZlbG9wZXIgLnN0b3AtY2FudmFzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuXG4gICAgICAgU3RyZXRjaC5wcm90b3R5cGUudG9nZ2xlID0gZmFsc2VcblxuICAgIH0pXG59O1xuXG5mdW5jdGlvbiBJbWFnZVNoYXR0ZXIoKXtcbiAgICB2YXIgc2l6aW5nID0gZnVuY3Rpb24oY29udGVudCl7XG4gICAgICAgIGlmKGNvbnRlbnQgPT09ICdkdXInKXtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA8IDYwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gMi42XG4gICAgICAgICAgICBlbHNlIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+IDYwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gMy41XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgaWYoY29udGVudCA9PT0gJ2ltZycpe1xuICAgICAgICAgICAgaWYod2luZG93LmlubmVyV2lkdGggPD0gNjAwKSBcbiAgICAgICAgICAgICAgICByZXR1cm4gNDAwXG4gICAgICAgICAgICBlbHNlIGlmICh3aW5kb3cuaW5uZXJXaWR0aCA+IDEyMDApXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gNTgwXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIDUwMFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgdmFyIGN0eCwgY2FudmFzO1xuICAgIHZhciBwYXJ0aWNsZUNhbnZhcywgcGFydGljbGVDdHg7XG4gICAgdmFyIGNhbnZhc1BhcmVudFdpZHRoO1xuICAgIHZhciBjYW52YXNQYXJlbnRIZWlnaHQ7XG4gICAgdmFyIGVuZGluZyA9IFtdXG4gICAgdmFyIHJldHJhY3RTdGFydCA9IDA7XG4gICAgdmFyIGltZ0NhbnZhcyA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIGltZyxjYWxsYmFjayl7XG4gICAgICAgIC8vV2F0Y2ggd2hlcmUgdGhpcyBpcyBsb2FkZWQgaW50byB3aGVuIHBvcnRmb2xpbyBkb25lXG4gICAgICAgIC8vIGRvY3VtZW50LmJvZHkuaW5uZXJIVE1MICs9ICc8Y2FudmFzIGlkPVwiaW1nLWNhbnZhc1wiPjwvY2FudmFzPic7XG4gICAgICAgIC8vIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbWctY2FudmFzJylcbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhcnRpY2xlJylcbiAgICAgICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcblxuICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aFxuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0XG4gICAgICAgIGNhbnZhc1BhcmVudFdpZHRoID0gXygnc3ZnLXBhZ2UnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aFxuICAgICAgICBjYW52YXNQYXJlbnRIZWlnaHQgPSBfKCdzdmctcGFnZScpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCB3aWR0aCxoZWlnaHQpXG5cbiAgICAgICAgLy9DYWxscyBmdW5jdGlvbiBmb3IgY2xpY2thYmxlIGV2ZW50IGxpc3RlbmVyIHRvIHJ1biBhbmQgYXBwZW5kcyBiYWNrZ3JvdW5kIGNhbnZhc1xuICAgICAgICBjYWxsYmFjayhjYW52YXMsY3JlYXRlUGFydGljbGVDYW52YXMoKSlcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhcnRpY2xlQ2FudmFzKCkge1xuXG4gICAgICAgIC8vIENyZWF0ZSBvdXIgY2FudmFzXG4gICAgICAgIHBhcnRpY2xlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgcGFydGljbGVDdHggPSBwYXJ0aWNsZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgLy8gU2l6ZSBvdXIgY2FudmFzIHdpdGggYWRkaXRpb25hbCBzaXppbmdcbiAgICAgICAgcGFydGljbGVDYW52YXMud2lkdGggPSBjYW52YXNQYXJlbnRXaWR0aFxuICAgICAgICBwYXJ0aWNsZUNhbnZhcy5oZWlnaHQgPSBjYW52YXNQYXJlbnRIZWlnaHRcbiAgICAgIFxuICAgICAgICAvLyBQb3NpdGlvbiBvdXQgY2FudmFzXG4gICAgICAgIHBhcnRpY2xlQ2FudmFzLnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgICAgICBwYXJ0aWNsZUNhbnZhcy5zdHlsZS50b3AgPSBcIjBcIjtcbiAgICAgICAgcGFydGljbGVDYW52YXMuc3R5bGUubGVmdCA9IFwiMFwiO1xuICAgICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBpdCdzIG9uIHRvcCBvZiBvdGhlciBlbGVtZW50c1xuICAgICAgICBwYXJ0aWNsZUNhbnZhcy5zdHlsZS56SW5kZXggPSBcIjUwMFwiO1xuICAgICAgICBcbiAgICAgICAgLy8gTWFrZSBzdXJlIG90aGVyIGVsZW1lbnRzIHVuZGVyIGl0IGFyZSBjbGlja2FibGVcbiAgICAgICAgcGFydGljbGVDYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICB2YXIgZm9yZWlnbk9iamVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggbnMsIFwiZm9yZWlnbk9iamVjdFwiKTtcbiAgICAgICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgXCJwYXJ0aWNsZU9iamVjdFwiKVxuICAgICAgICBmb3JlaWduT2JqZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBjYW52YXNQYXJlbnRXaWR0aClcbiAgICAgICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGNhbnZhc1BhcmVudEhlaWdodClcbiAgICAgICAgZm9yZWlnbk9iamVjdC5hcHBlbmRDaGlsZChwYXJ0aWNsZUNhbnZhcylcbiAgICAgICBcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZy5kZXNpZ24nKS5hcHBlbmRDaGlsZChmb3JlaWduT2JqZWN0KVxuXG4gICAgfVxuXG4gICAgXG4gICAgICAgIFxuICAgIC8vSW1hZ2UgY29tZXMgYXBwYXJ0XG4gICAgdmFyIEV4cGxvZGluZ1BhcnRpY2xlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYmVnaW4gPSAwXG5cbiAgICAgICAgLy8gU2V0IGhvdyBsb25nIHdlIHdhbnQgb3VyIHBhcnRpY2xlIHRvIGFuaW1hdGUgZm9yXG4gICAgICAgIHRoaXMuYW5pbWF0aW9uRHVyYXRpb24gPSAxMDAwOyAvLyBpbiBtc1xuXG4gICAgICAgIC8vIFNldCB0aGUgc3BlZWQgLyBkaXN0YW5jZSBmb3Igb3VyIHBhcnRpY2xlXG4gICAgICAgIHRoaXMuc3BlZWQgPSB7XG4gICAgICAgICAgICB4OiB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OCA/IC01ICsgTWF0aC5yYW5kb20oKSAqIDEwIDogLTEwICsgTWF0aC5yYW5kb20oKSAqIDIwLFxuICAgICAgICAgICAgeTogd2luZG93LmlubmVyV2lkdGggPCA3NjggPyAtNSArIE1hdGgucmFuZG9tKCkgKiAxMCA6IC0xMCArIE1hdGgucmFuZG9tKCkgKiAyMFxuICAgICAgICB9O1xuICAgICAgXG4gICAgICAgIC8vIFNpemUgb3VyIHBhcnRpY2xlXG4gICAgICAgIHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4ID8gdGhpcy5yYWRpdXMgPSAzICsgTWF0aC5yYW5kb20oKSAqIDMgOiB0aGlzLnJhZGl1cyA9IDQgKyBNYXRoLnJhbmRvbSgpICogNDtcbiAgICAgIFxuICAgICAgXG4gICAgICAgIC8vIFNldCBhIG1heCB0aW1lIHRvIGxpdmUgZm9yIG91ciBwYXJ0aWNsZVxuICAgICAgICB0aGlzLmxpZmUgPSAzMCArIE1hdGgucmFuZG9tKCkgKiAxMDtcbiAgICAgICAgdGhpcy5yZW1haW5pbmdMaWZlID0gdGhpcy5saWZlXG5cbiAgICAgICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBieSBvdXIgYW5pbWF0aW9uIGxvZ2ljIGxhdGVyIG9uXG4gICAgICAgIHRoaXMuZHJhdyA9IGN0eCA9PiB7XG5cbiAgICAgICAgICAgIGxldCBwID0gdGhpc1xuICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYodGhpcy5yZW1haW5pbmdMaWZlID4gMCAmJiB0aGlzLnJhZGl1cyA+IDApIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBEcmF3IGEgY2lyY2xlIGF0IHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgY3R4LmFyYyhwLnN0YXJ0WCwgcC5zdGFydFksIHAucmFkaXVzLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwicmdiYShcIiArIHRoaXMucmdiQXJyYXlbMF0gKyAnLCcgKyB0aGlzLnJnYkFycmF5WzFdICsgJywnICsgdGhpcy5yZ2JBcnJheVsyXSArIFwiLCAxKVwiXG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKVxuICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgcGFydGljbGUncyBsb2NhdGlvbiBhbmQgbGlmZVxuICAgICAgICAgICAgICAgIHAucmVtYWluaW5nTGlmZS0tXG4gICAgICAgICAgICAgICAgcC5yYWRpdXMgLT0gMC4yNVxuICAgICAgICAgICAgICAgIHAuc3RhcnRYICs9IHAuc3BlZWQueFxuICAgICAgICAgICAgICAgIHAuc3RhcnRZICs9IHAuc3BlZWQueVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucmV0cmFjdCA9IChiZWdpbiwgZmluYWxlLCB0aW1lc3RhbXApID0+IHtcblxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoIXJldHJhY3RTdGFydCkgcmV0cmFjdFN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBydW50aW1lID0gdGltZXN0YW1wIC0gcmV0cmFjdFN0YXJ0XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gTWF0aC5taW4ocnVudGltZSAvIDMwMDAsIDEpXG4gICAgICAgIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIGNhbnZhcy5zdHlsZS5vcGFjaXR5ID0gMSAtIHByb2dyZXNzXG4gICAgICAgICAgICAgICAgcGFydGljbGVDdHguY2xlYXJSZWN0KDAsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuXG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgYmVnaW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBiZWdpbltpXVxuICAgICAgICAgICAgICAgIHZhciBlbmQgPSBmaW5hbGVbaV1cbiAgICAgICAgICAgICAgICBcbiAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGRpc3RYID0gTWF0aC5hYnMoc3RhcnQuc3RhcnRYICAtIGVuZC54KVxuICAgICAgICAgICAgICAgIHZhciBkaXN0WSA9IE1hdGguYWJzKHN0YXJ0LnN0YXJ0WSAtIGVuZC55KVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vSWYgZW5kIHggb3IgeSBpcyBncmVhdGVyIHRoYW4geCBvciB5IHN1YnRyYWN0IGVsc2UgYWRkXG4gICAgICAgICAgICAgICAgc3RhcnQueCA9IHN0YXJ0LnN0YXJ0WCA+IGVuZC54ID8gc3RhcnQuc3RhcnRYIC0gKGRpc3RYICogcHJvZ3Jlc3MpIDogc3RhcnQuc3RhcnRYICsgKGRpc3RYICogcHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgc3RhcnQueSA9IHN0YXJ0LnN0YXJ0WSA+IGVuZC55ID8gc3RhcnQuc3RhcnRZIC0gKGRpc3RZICogcHJvZ3Jlc3MpIDogc3RhcnQuc3RhcnRZICsgKGRpc3RZICogcHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgc3RhcnQucmFkID0gc3RhcnQuYmVnaW4gKyAoZW5kLnJhZCAqIHByb2dyZXNzKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHBhcnRpY2xlQ3R4LmJlZ2luUGF0aCgpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcGFydGljbGVDdHguYXJjKHN0YXJ0LngsIHN0YXJ0LnksIHN0YXJ0LnJhZCwgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlQ3R4LmZpbGxTdHlsZSA9IFwicmdiYShcIiArIHN0YXJ0LnJnYkFycmF5WzBdICsgJywnICsgc3RhcnQucmdiQXJyYXlbMV0gKyAnLCcgKyBzdGFydC5yZ2JBcnJheVsyXSArICcsJysgc3RhcnQucmdiQXJyYXlbM10rXCIpXCJcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHBhcnRpY2xlQ3R4LmZpbGwoKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYocHJvZ3Jlc3MgPT09IDEgKXtcbiAgICAgICAgICAgIC8vcmV0dXJucyB0aGUgcGhvdG8gYmFjayBpZiByYW4gYWdhaW5cbiAgICAgICAgICAgIHJldHVybiBcbiAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKHRpbWVzdGFtcCl7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyYWN0KGJlZ2luLCBmaW5hbGUsIHRpbWVzdGFtcClcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbiAgICB2YXIgcGFydGljbGVzID0gW107XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWNsZUF0UG9pbnQoeCwgeSwgY29sb3JEYXRhKSB7XG4gICAgICAgIGxldCBwYXJ0aWNsZSA9IG5ldyBFeHBsb2RpbmdQYXJ0aWNsZSgpO1xuICAgICAgICBcbiAgICAgICAgcGFydGljbGUucmdiQXJyYXkgPSBjb2xvckRhdGE7XG4gICAgICAgIHBhcnRpY2xlLnN0YXJ0WCA9IHg7XG4gICAgICAgIHBhcnRpY2xlLnN0YXJ0WSA9IHk7XG4gICAgICAgIHBhcnRpY2xlLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIFxuICAgICAgICBwYXJ0aWNsZXMucHVzaChwYXJ0aWNsZSk7XG4gICAgICAgIGxldCBlbmQgPSB7fVxuICAgICAgICBlbmQuc3RhcnQgPSAwO1xuICAgICAgICBlbmQucmFkID0gcGFydGljbGUucmFkaXVzO1xuICAgICAgICBlbmQueCA9IHg7XG4gICAgICAgIGVuZC55ID0geTtcbiAgICAgICAgZW5kaW5nLnB1c2goZW5kKVxuICAgICAgXG4gICAgfVxuXG4gICAgdmFyIG9wYWMgPSAxO1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYodHlwZW9mIHBhcnRpY2xlQ3R4ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBwYXJ0aWNsZUN0eC5jbGVhclJlY3QoMCwgMCwgd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgLy9pbWFnZSBmYWRlcyBhcyBpdCdzIGJyZWFraW5nIGFwYXJ0XG4gICAgICAgIGNhbnZhcy5zdHlsZS5vcGFjaXR5ID0gKG9wYWMgPSBvcGFjIC0gLjA4KVxuXG4gICAgICAgIC8vIERyYXcgYWxsIG9mIG91ciBwYXJ0aWNsZXMgaW4gdGhlaXIgbmV3IGxvY2F0aW9uXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBwYXJ0aWNsZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAgICAgcGFydGljbGVzW2ldLmRyYXcocGFydGljbGVDdHgpO1xuXG4gICAgICAgICAgICAvLyBXaGVuIHBhcnRpY2xlcyBcbiAgICAgICAgICAgIGlmKHBhcnRpY2xlc1tpXS5yYWRpdXMgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBlcmNlbnQgPSAoRGF0ZS5ub3coKSAtIHBhcnRpY2xlc1tpXS5zdGFydFRpbWUpIC8gcGFydGljbGVzW2ldLmFuaW1hdGlvbkR1cmF0aW9uICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxldCBkdXIgPSBzaXppbmcoJ2R1cicpXG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihwZXJjZW50ID4gZHVyKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJ0aWNsZSA9IG5ldyBFeHBsb2RpbmdQYXJ0aWNsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIHBhcnRpY2xlLnJldHJhY3QocGFydGljbGVzLCBlbmRpbmcpXG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpO1xuICAgIH1cblxuICAgIHZhciBjbGVhckRhdGEgPSBmdW5jdGlvbigpe1xuICAgICAgICByZXRyYWN0U3RhcnQgPSBudWxsXG4gICAgICAgIGNhbnZhcy5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJylcbiAgICAgICAgcGFydGljbGVDdHguY2xlYXJSZWN0KDAsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgICBlbmRpbmcgPSBbXVxuICAgICAgICBwYXJ0aWNsZXMgPSBbXVxuICAgIH1cblxuICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgd2lkdGggPSBzaXppbmcoJ2ltZycpXG4gICAgICAgIHZhciBoZWlnaHQgPSB3aWR0aDtcbiAgICAgICAgaW1nQ2FudmFzKHdpZHRoLGhlaWdodCx0aGlzLHJ1bkV2ZW50cylcbiAgICAgICAgXG4gICAgfVxuICAgIGltZy5zcmMgPSAnaW1hZ2VzL2Rlc2lnbi1pbWcucG5nJ1xuXG4gICAgZnVuY3Rpb24gcnVuRXZlbnRzKGltZ0NhbnZhcyl7XG4gICAgICAgIHZhciBmb3JlaWduT2JqZWN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmRlc2lnbiAuaXRlbS1jYW52YXMnKVxuICAgICBcbiAgICAgICAgbGV0IGltYWdlTGVmdCA9IHBhcnNlSW50KGZvcmVpZ25PYmplY3QuZ2V0QXR0cmlidXRlKCd4JykgKTtcbiAgICAgICAgbGV0IGltYWdlVG9wID0gcGFyc2VJbnQoZm9yZWlnbk9iamVjdC5nZXRBdHRyaWJ1dGUoJ3knKSApO1xuICAgICAgICAvLyBsZXQgcmVkdWN0aW9uRmFjdG9yID0gd2luZG93LndpZHRoIDw9IDQwMCA/IDE1IDogTWF0aC5yb3VuZChpbWdDYW52YXMud2lkdGggLyAxNSlcbiAgICAgICAgaWYod2luZG93LmlubmVyV2lkdGggPCA2MDApXG4gICAgICAgICAgICB2YXIgcmVkdWN0aW9uRmFjdG9yID0gMTVcbiAgICAgICAgaWYod2luZG93LmlubmVyV2lkdGggPj02MDApIFxuICAgICAgICAgICAgdmFyIHJlZHVjdGlvbkZhY3RvciA9IDIyXG4gICAgICAgIGlmKHdpbmRvdy5pbm5lcldpZHRoID49IDEyMDApXG4gICAgICAgICAgICB2YXIgcmVkdWN0aW9uRmFjdG9yID0gMzNcbiAgICAgICAgXG4gICAgICAgIC8vUmVtb3ZlcyBjYW52YXMgd2l0aCBwYXJ0aWNsZXMgbWFkZSBmcm9tIHdoZW4gY2xvc2luZyBzdmcgcGFnZVxuICAgICAgICBfKCdjbG9zZS1idG4nKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsZWFyRGF0YSlcblxuICAgICAgICBpbWdDYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIGlmKGUudGFyZ2V0LnN0eWxlLm9wYWNpdHkgKXtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsZWFyRGF0YSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgICAvL3dpZHRoIGZpcnN0IG9uZSBwaXhlbCwgdGhlbiBhbGwgb2YgaGVpZ2h0IHBpeGVscywgd2lkdGggYW5vdGhlciBwaXhlbCB0aGVuIGFsbCBvZiBoZWlnaHQgcGl4ZWxzIFxuICAgICAgICAgICAgbGV0IHJnYmFEYXRhID0gY3R4LmdldEltYWdlRGF0YSgwLDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KS5kYXRhO1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgIGZvcihsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4Kyspe1xuICAgICAgICAgICAgICAgIGZvcihsZXQgeSA9IDA7IHkgPCB0aGlzLmhlaWdodDsgeSsrKXtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoY291bnQgJSByZWR1Y3Rpb25GYWN0b3IgPT09IDApIHtcbiAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9ICh5ICogdGhpcy53aWR0aCArIHgpICogNDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJnYmFDb2xvckFyciA9IHJnYmFEYXRhLnNsaWNlKGluZGV4LCBpbmRleCArIDQpO1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBsZXQgZ2xvYmFsWCA9IGltYWdlTGVmdCArIHg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBnbG9iYWxZID0gaW1hZ2VUb3AgKyB5O1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjcmVhdGVQYXJ0aWNsZUF0UG9pbnQoZ2xvYmFsWCwgZ2xvYmFsWSwgcmdiYUNvbG9yQXJyKVxuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY291bnQrK1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZSgpXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkltYWdlU2hhdHRlcigpO1xuXG5cblxuZnVuY3Rpb24gU3RhcnJ5TmlnaHQoKXtcbiAgICAgICBcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXJyeU5pZ2h0Jyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciBkYXRhID0gW11cbiAgICB2YXIgdHJhaWxEYXRhID0gW11cbiAgICB2YXIgcmdiID0gIHRyYWlsRGF0YS5sZW5ndGggPiAxICYmIDE1MCAvIHRyYWlsRGF0YS5sZW5ndGhcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGhvdXNlV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OCA/IDM4MCA6IDYwMDtcbiAgICB2YXIgaG91c2VIZWlnaHQgPSBuZXdTaXplKCd3aWR0aCcsIGhvdXNlV2lkdGgpLmhlaWdodDtcbiAgICB0aGlzLndpZHRoID0gY2FudmFzLndpZHRoID0gXygnc3ZnLXBhZ2UnKS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgdGhpcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ID0gXygnc3ZnLXBhZ2UnKS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICAgIHRoaXMudG9nZ2xlID0gdHJ1ZTtcblxuICAgIHRoaXMuaW1hZ2VzID0gW11cblxuICAgIC8vTWVuIERhdGFcbiAgICB2YXIgbWVuRGF0YSA9IHtcbiAgICAgICAgaGVhZEFyYzogd2luZG93LmlubmVyV2lkdGggPCA3NjggPyA0IDogNixcbiAgICAgICAgc3RlcERvd246IHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4ID8gMTIgOiAxNyxcbiAgICAgICAgcm90YXRlZFBvczogMCxcbiAgICAgICAgcm90YXRlRGVncmVlOiAxNCxcbiAgICAgICAgajogMCwgLy9FYWNoIHBvaW50IG9mIGFuaW1hdGlvbiwgd2Fsaywgc3RhbmQgc3RpbGwsIHJvdGF0ZSAsZmFsbGluZ1xuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgYmVnaW46IDAsXG4gICAgICAgIGxhc3RQb3NYOiA5MCxcbiAgICAgICAgbGFzdFBvc1k6IHVuZGVmaW5lZCxcbiAgICAgICAgYXJjU3RhcnRYOiB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OCA/IDcgOiAxMCxcbiAgICAgICAgYXJjU3RhcnRZOiA1XG4gICAgfVxuXG4gICAgLy9Ib3VzZSBhbmltYXRpb24gRGF0YVxuICAgIHRoaXMuaG91c2UgPSB7XG4gICAgICAgIGhvdXNlSW1nOiB1bmRlZmluZWQsXG4gICAgICAgIHRvZ2dsZTogdW5kZWZpbmVkLFxuICAgICAgICBjdXJyZW50WTogdW5kZWZpbmVkLFxuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgcmlnaHQ6IHRoaXMud2lkdGggLSBob3VzZVdpZHRoLFxuICAgICAgICBib3R0b206IHRoaXMuaGVpZ2h0IC0gaG91c2VIZWlnaHQsXG4gICAgICAgIHN0YXJ0WTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdHRvbSArIGhvdXNlV2lkdGggLyAyLjRcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRYOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgYmVnaW46IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBtZW5EYXRhLmxhc3RQb3NZID0gKGhvdXNlSGVpZ2h0IC8gMi4yNCkgLSBzdGFycnlOaWdodC5pbWFnZXNbMF0uaGVpZ2h0XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuaG91c2VJbWcsIHRoaXMuc3RhcnRYKCksIHRoaXMuc3RhcnRZKCksIGhvdXNlV2lkdGgsIGhvdXNlSGVpZ2h0IClcbiAgICAgICAgfSxcbiAgICAgICAgcmlzZTogdGhpcy5oZWlnaHQgLyAyLFxuICAgICAgICBtb3ZlTGVmdDogd2luZG93LmlubmVyV2lkdGggPCA1MDAgPyB0aGlzLndpZHRoIC8gMjAgOiB0aGlzLndpZHRoIC8gOFxuICAgIH1cblxuICAgIC8vU3RhciBUcmFpbCBEYXRhXG4gICAgdmFyIGxhc3RQb3NpdGlvbiA9IGZ1bmN0aW9uKHhQb3MsIHlQb3MsIHJhZGl1cywgYWxwaGEpe1xuICAgICAgICB0cmFpbERhdGEucHVzaCh7XG4gICAgICAgICAgICB4OiB4UG9zLFxuICAgICAgICAgICAgeTogeVBvcyxcbiAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxuICAgICAgICAgICAgYWxwaGE6IGFscGhhXG4gICAgICAgIH0pXG4gICAgICAgIGlmKHRyYWlsRGF0YS5sZW5ndGggPiAyNSkgdHJhaWxEYXRhLnNoaWZ0KClcbiAgICB9XG5cbiAgICB0aGlzLnJhbmRvbU1heCA9IGZ1bmN0aW9uKG1pbiwgbWF4KXtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbiApXG4gICAgfVxuXG4gICAgLy9BZGRzIGRhdGEgZm9yIFNob290aW5nIHN0YXJcbiAgICB0aGlzLmFkZERhdGEgPSBmdW5jdGlvbigpe1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgODsgaSsrKXtcbiAgICAgICAgICAgIHZhciBtZWFzdXJlbWVudHMgPSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnRzIHJhbmRvbWx5IG9uIHRoZSB4IGF4aXNcbiAgICAgICAgICAgICAgICBkZWxheTogaSA9PT0gMCA/IDAgOiB0aGlzLnJhbmRvbU1heCgxLCAyKSxcbiAgICAgICAgICAgICAgICB4OiB0aGlzLnJhbmRvbU1heCgwLCB0aGlzLndpZHRoLzIpLFxuICAgICAgICAgICAgICAgIHk6IHRoaXMucmFuZG9tTWF4KDIwMCwgdGhpcy5oZWlnaHQpLFxuICAgICAgICAgICAgICAgIHJhZGl1czogd2luZG93LmlubmVyV2lkdGggPCA3NjggPyB0aGlzLnJhbmRvbU1heCg1LCAxMykgOiB0aGlzLnJhbmRvbU1heCg4LCAxNiksXG4gICAgICAgICAgICAgICAgZGlzdGFuY2U6IHRoaXMud2lkdGggKyAxMDAsXG4gICAgICAgICAgICAgICAgZ2xvYkFscGhhOiAxLFxuICAgICAgICAgICAgICAgIG9wYWM6IDEsXG4gICAgICAgICAgICAgICAgZW5kUG9zOiB0aGlzLnJhbmRvbU1heCgxMDAsIHRoaXMud2lkdGgpLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgIHRpbWU6IDAsXG4gICAgICAgICAgICAgICAgZXhwbG9kZVN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgIGV4cGxvZGVTaXplOiB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OCA/IDIwIDogMzVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEucHVzaChtZWFzdXJlbWVudHMpXG4gICAgICAgICAgIFxuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpXG5cbiAgICAvL1doZW4gcHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlIHRoaXMgYXV0b21hdGljYWxseSBnZXRzIHJhbiB0byBiZSBhYmxlIHRvIHJ1biBhbmltYXRpb24gYWdhaW5cbiAgICB0aGlzLnJlc3RvcmVEYXRhID0gZnVuY3Rpb24oKXtcbiAgICAgICAgZGF0YSA9IFtdXG4gICAgICAgIHRyYWlsRGF0YSA9IFtdXG4gICAgICAgIGogPSAwXG4gICAgICAgIHRoaXMuYWRkRGF0YSgpXG4gICAgICAgIG1lbkRhdGEuYmVnaW4gPSBudWxsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd0hvdXNlKGltYWdlLHRpbWVzdGFtcCl7XG4gICAgICAgIGlmKCFpbWFnZS5zdGFydCkgaW1hZ2Uuc3RhcnQgPSB0aW1lc3RhbXBcbiAgICAgICAgdmFyIHJ1bnRpbWUgPSB0aW1lc3RhbXAgLSBpbWFnZS5zdGFydFxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBydW50aW1lIC8gMjAwMFxuXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IGltYWdlLnJpc2UgKiBwcm9ncmVzc1xuICAgICAgICBcbiAgICAgICAgLy9GbG9hdGluZyBpbiBwbGFjZVxuICAgICAgICBpZihpbWFnZS5jdXJyZW50WSl7XG5cbiAgICAgICAgICAgIGltYWdlLnRvZ2dsZSA/IGltYWdlLnggPSBpbWFnZS5jdXJyZW50WCAtIGRpc3RhbmNlICA6IGltYWdlLnggPSBpbWFnZS5jdXJyZW50WCArIGRpc3RhbmNlXG4gICAgICAgICAgICBpbWFnZS50b2dnbGUgPyBpbWFnZS55ID0gaW1hZ2UuY3VycmVudFkgKyBkaXN0YW5jZSAgOiBpbWFnZS55ID0gaW1hZ2UuY3VycmVudFkgLSBkaXN0YW5jZVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZihkaXN0YW5jZSA+PSBpbWFnZS5yaXNlKXtcbiAgICAgICAgICAgIC8vTWFrZXMgY3VycmVudFkgdHJ1ZSBhbmQgdXBkYXRlcyBwb3N0aW9uIG9mIHRoZSBpbWFnZVxuICAgICAgICAgICAgaW1hZ2UuY3VycmVudFkgPSBpbWFnZS55XG4gICAgICAgICAgICBpbWFnZS5jdXJyZW50WCA9IGltYWdlLnhcbiAgICAgICAgICAgIGltYWdlLnRvZ2dsZSA/IGltYWdlLnRvZ2dsZSA9IGZhbHNlIDogaW1hZ2UudG9nZ2xlID0gdHJ1ZVxuICAgICAgICAgICAgaW1hZ2Uuc3RhcnQgPSAwXG4gICAgICAgICAgICBpbWFnZS5yaXNlID0gNTBcblxuICAgICAgICB9XG4gICAgICAgIC8vRW5kcyB0aGUgZmlyc3QgcmlzZSBvZiB0aGUgaW1hZ2VcbiAgICAgICAgaWYoIWltYWdlLmN1cnJlbnRZKSB7XG4gICAgICAgICAgICBpbWFnZS54ID0gaW1hZ2Uuc3RhcnRYKCkgLSAoaW1hZ2UubW92ZUxlZnQgKiBwcm9ncmVzcylcbiAgICAgICAgICAgIGltYWdlLnkgPSBpbWFnZS5zdGFydFkoKSAtIChpbWFnZS5yaXNlICogcHJvZ3Jlc3MpXG4gICAgICAgIH1cblxuICAgICAgICBjdHguZHJhd0ltYWdlKGltYWdlLmhvdXNlSW1nLCBpbWFnZS54LCBpbWFnZS55LCBob3VzZVdpZHRoLCBob3VzZUhlaWdodCApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd1N0YXJzKGNpcil7XG4gICAgICAgIGN0eC5zYXZlKClcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gY2lyLmFscGhhXG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguYXJjKGNpci54UG9zLCBjaXIueVBvcywgY2lyLnJhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMjU1LCAyNTUsIDczLCAnICsgY2lyLm9wYWNpdHkgKyAnKSdcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKVxuICAgICAgICBsYXN0UG9zaXRpb24oY2lyLnhQb3MsIGNpci55UG9zLCBjaXIucmFkaXVzLCBjaXIuYWxwaGEpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd1RyYWlsKHRyYWlsKXtcbiAgICAgICAgY3R4LnNhdmUoKVxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSAwLjJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguYXJjKHRyYWlsLngsIHRyYWlsLnksIHRyYWlsLnJhZCwgMCwgMiAqIE1hdGguUEksIHRydWUpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMjM4LCcrdHJhaWwuY29sb3IrJywgNiwgJyArIHRyYWlsLmZhZGUgKyAnKSdcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKVxuICAgIH1cbiAgICBmdW5jdGlvbiBkcmF3RXhwbG9zaW9uKGNpcmNsZSwgdGltZXN0YW1wKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgaWYoIWNpcmNsZS5leHBsb2RlU3RhcnQpIGNpcmNsZS5leHBsb2RlU3RhcnQgPSB0aW1lc3RhbXBcbiAgICAgICAgdmFyIHJ1bnRpbWUgPSB0aW1lc3RhbXAgLSBjaXJjbGUuZXhwbG9kZVN0YXJ0XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IHJ1bnRpbWUgLyA0MDBcbiAgICAgICAgdmFyIGVhc2UgPSBlYXNlT3V0KHByb2dyZXNzKVxuICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgY3R4LmFyYyhjaXJjbGUueFBvcywgY2lyY2xlLnlQb3MsIDAgKyAoY2lyY2xlLmV4cGxvZGVTaXplICogZWFzZSksIDAsIDIgKiBNYXRoLlBJLCB0cnVlKVxuICAgICAgICBjdHguZmlsbFN0eWxlID0gJ3JnYmEoMjQ5LCAyNTUsIDAsICcgKyAoMSAtICguOSAqIHByb2dyZXNzKSApICsgJyknXG4gICAgICAgIGN0eC5maWxsKClcbiAgICAgICAgICAgIFxuICAgIH1cbiAgICBmdW5jdGlvbiBkcmF3TWVuKG1lbil7XG5cbiAgICAgICAgaWYobWVuRGF0YS5qID49IDQgJiYgbWVuRGF0YS5qIDw9IDUpe1xuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShtZW4udHJhbnNsYXRlWCwgbWVuLnRyYW5zbGF0ZVkpO1xuICAgICAgICAgICAgY3R4LnJvdGF0ZShtZW4ucm90YXRlICogTWF0aC5QSSAvIDE4MCk7XG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKG1lbi5pbWcsIC1tZW4ud2lkdGgvMiwgLW1lbi5oZWlnaHQsIG1lbi53aWR0aCwgbWVuLmhlaWdodClcbiAgICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApXG4gICAgICAgIH1lbHNleyBcbiAgICAgICAgICAgIGN0eC5zYXZlKClcbiAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG1lbi5vcGFjXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHguYXJjKG1lbi5hcmNYLCBtZW4uYXJjWSwgbWVuLmFyY1JhZGl1cywgMCwgMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiIzAwMFwiXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShtZW4uaW1nLCBtZW4ueCwgbWVuLnksIG1lbi53aWR0aCwgbWVuLmhlaWdodClcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkcmF3ID0gZnVuY3Rpb24odGltZXN0YW1wKXtcbiAgICAgICAgaWYoIVN0YXJyeU5pZ2h0LnByb3RvdHlwZS50b2dnbGUpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzdG9yZURhdGEoKVxuICAgICAgICB9IFxuXG4gICAgICAgIC8vSG91c2VcbiAgICAgICAgdmFyIGltYWdlID0gdGhpcy5ob3VzZVxuXG4gICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpXG4gICAgICAgIFxuICAgICAgICAvL01lbiBydW5uaW5nIHN0YXJ0ICwgU3RhcnMgc3RhcnQgYWZ0ZXIgaG91c2UgZ2V0cyB0byB0b3AuIFxuICAgICAgICBpZihpbWFnZS5jdXJyZW50WSl7XG5cbiAgICAgICAgICAgIC8vKiogIFNUQVJUIE9GIFNUQVJTICAqKi9cblxuICAgICAgICAgICAgLy8gRHJhd3MgdGhlIHRyYWlsIG9wYWNpdHkgIFxuICAgICAgICAgICAgaWYobWVuRGF0YS5qID49IDEpe1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0cmFpbERhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhaWwgPSB0cmFpbERhdGFbaV1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGZhZGVTaXplID0gIGkgLyB0cmFpbERhdGEubGVuZ3RoXG5cbiAgICAgICAgICAgICAgICAgICAgLy9UcmFpbCB0YXBlcnMgYXMgaXQgZ29lcy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHJhZGl1c1RhcGVyID0gICAodHJhaWwucmFkaXVzLTIpIC8gdHJhaWxEYXRhLmxlbmd0aFxuICAgICAgICAgICAgICAgICAgICB0cmFpbC5jb2xvciA9IDI0MCAtIChpK2opXG4gICAgICAgICAgICAgICAgICAgIHRyYWlsLmZhZGUgPSBpIC8gdHJhaWxEYXRhLmxlbmd0aFxuXG4gICAgICAgICAgICAgICAgICAgIC8vVGFwZXJzIGRvd24gdGhlIHJhaWR1cyBvZiB0aGUgdHJhaWxcbiAgICAgICAgICAgICAgICAgICAgdHJhaWwucmFkID0gKHRyYWlsLnJhZGl1cyA9IHRyYWlsLnJhZGl1cyAtIHJhZGl1c1RhcGVyIClcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhaWwucmFkID0gdHJhaWwucmFkaXVzXG4gICAgICAgICAgICAgICAgICAgIGRyYXdUcmFpbCh0cmFpbClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvL0RyYXdzIHN0YXJzXG4gICAgICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2lyY2xlID0gZGF0YVtpXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKCBqID49IGkgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIWNpcmNsZS5zdGFydCkgY2lyY2xlLnN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcnVudGltZSA9IHRpbWVzdGFtcCAtIGNpcmNsZS5zdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHByb2dyZXNzID0gcnVudGltZSAvIDIwMDBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBlYXNlID0gZWFzZU91dChwcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS50aW1lID0gKGNpcmNsZS5kZWxheSAtIGVhc2UpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vSWYgdGhlIGN1cnJlbnQgY2lyY2xlIGRlbGF5ID0gcHJvZ3Jlc3MgZHJhd3MgbmV4dCBjaXJjbGUsIChyYW5kb20gZHJhd2luZyBsb29rKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2lyY2xlLnRpbWUgPD0gMCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2N1cnJlbnQgY2lyY2xlIHNldCB0byB1bmRlZmluZWQga2VlcCBmcm9tIHJ1bm5pbmcgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUuZGVsYXkgPSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqKytcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5hbHBoYSA9IGNpcmNsZS5nbG9iQWxwaGEgLSAoMSpwcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS5vcGFjaXR5ID0gY2lyY2xlLm9wYWMgLSAgKC45KnByb2dyZXNzKSBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNpcmNsZS5kdXJhdGlvbiA9IGVhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaiUzICE9PTAgJiYgbWVuRGF0YS5qID49IDEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS54UG9zID0gY2lyY2xlLnggKyAoY2lyY2xlLmVuZFBvcyAqIGVhc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lyY2xlLnlQb3MgPSAwICsgKGNpcmNsZS55ICogZWFzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLW92ZXInXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lyY2xlLnhQb3MgPSBjaXJjbGUueCArIChjaXJjbGUuZW5kUG9zICogZWFzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUueVBvcyA9IDAgKyAoY2lyY2xlLnkgKiBwcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdTdGFycyhjaXJjbGUpXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vRXhwbG9zaW9uIHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICBpZihjaXJjbGUueFBvcyA+IGltYWdlLnggJiYgY2lyY2xlLnlQb3MgPiBpbWFnZS55KXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdFeHBsb3Npb24oY2lyY2xlLCB0aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihqID09PSBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGogPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhaWxEYXRhID0gW11cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZERhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8qKiAgU1RBUlQgT0YgTUVOICAqKi9cbiAgICAgICAgICAgIHZhciBtZW5MZW5ndGggPSBzdGFycnlOaWdodC5pbWFnZXMubGVuZ3RoLTFcblxuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IG1lbkxlbmd0aDsgaSsrKXsgXG4gICAgICAgICAgICAgICAgdmFyIG1lbiA9IHN0YXJyeU5pZ2h0LmltYWdlc1tpXVxuICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoIW1lbkRhdGEuYmVnaW4pIG1lbkRhdGEuYmVnaW4gPSB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICB2YXIgcnVudGltZSA9IHRpbWVzdGFtcCAtIG1lbkRhdGEuYmVnaW5cbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBNYXRoLm1pbihydW50aW1lIC8gMjAwMCwgMSlcblxuICAgICAgICAgICAgICAgIC8vRmlyc3Qgd2FsayBvdXRcbiAgICAgICAgICAgICAgICBpZihtZW5EYXRhLmogPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5zdGFydCA9IHBhcnNlSW50KCAoIHByb2dyZXNzICogMTUpLnRvRml4ZWQoMCkgKTtcbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5kaXN0YW5jZVggPSB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OCA/IDk1IDogMjA1XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL1NlY29uZCBXYWxrIHN0YW5kcyBzdGlsbFxuICAgICAgICAgICAgICAgIGlmKG1lbkRhdGEuaiA9PT0gMSl7XG4gICAgICAgICAgICAgICAgICAgIC8vU3RhcnRzIGFuZCBlbmRzIHdpdGggbGFzdCBkdWRlXG4gICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuc3RhcnQgPSAxNVxuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwaW5nIGNvdW50IGF0IGxhc3QgbWFuIGluc3RlYWQgb2YgY291bnRpbmcgdGhyb3VnaCB0aGVtIHRvIGFuaW1hdGVcbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5kaXN0YW5jZVggPSAwXG4gICAgICAgICAgICAgICAgfSBcblxuICAgICAgICAgICAgICAgIC8vVGhpcmQgd2FsayBkb3duIGFuZCB0byB0aGUgZW5kXG4gICAgICAgICAgICAgICAgaWYobWVuRGF0YS5qID09PSAyKXtcbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5zdGFydCA9IHBhcnNlSW50KCAoIHByb2dyZXNzICogMTUpLnRvRml4ZWQoMCkgKTtcbiAgICAgICAgICAgICAgICAgICAgbWVuLndhbGtEb3duID0gTWF0aC5taW4oICggcHJvZ3Jlc3MgKiA2KSwgMSApICogbWVuRGF0YS5zdGVwRG93blxuICAgICAgICAgICAgICAgICAgICAvLyBtZW5EYXRhLmRpc3RhbmNlWCA9IDI1MFxuICAgICAgICAgICAgICAgICAgICBtZW5EYXRhLmRpc3RhbmNlWCA9IHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4ID8gMTU5IDogMjUwXG4gICAgICAgICAgICAgICAgfSBcblxuICAgICAgICAgICAgICAgIC8vTG9va3MgZG93blxuICAgICAgICAgICAgICAgIGlmKG1lbkRhdGEuaiA9PT0gMyl7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkSXRlcmF0ZSA9IE1hdGgubWluKHJ1bnRpbWUgLyAxMDAwLCAxKVxuXG4gICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlcyBtZW4ud2Fsa2Rvd24gdGhhdCBnZXRzIHJhbiBiZWZvcmUgYmFjayB0byAwXG4gICAgICAgICAgICAgICAgICAgIG1lbi53YWxrRG93biA9IDBcbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5zdGFydCA9IDE2XG4gICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuZGlzdGFuY2VYID0gMFxuICAgICAgICAgICAgICAgICAgICBtZW4uYXJjWCA9IChpbWFnZS54ICsgKCBtZW5EYXRhLmxhc3RQb3NYICsgKG1lbi53aWR0aC8yKzIpICkpICsgKCBtZW5EYXRhLmFyY1N0YXJ0WCAqIGhlYWRJdGVyYXRlIClcbiAgICAgICAgICAgICAgICAgICAgbWVuLmFyY1kgPSBpbWFnZS55ICsgKCBtZW5EYXRhLmxhc3RQb3NZKyA0KSArICggbWVuRGF0YS5hcmNTdGFydFkgKiBoZWFkSXRlcmF0ZSApXG4gICAgICAgICAgICAgICAgICAgIG1lbi5hcmNSYWRpdXMgPSBtZW5EYXRhLmhlYWRBcmMgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vUm90YXRlcyBiYWNrIGFuZCBmb3J0aFxuICAgICAgICAgICAgICAgIGlmKG1lbkRhdGEuaiA9PT0gNCl7XG4gICAgICAgICAgICAgICAgICAgIC8vMm5kIHJvdGF0ZWQgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1JvdGF0ZWRQb3MgPSBtZW5EYXRhLnJvdGF0ZWRQb3MgLSAoIChtZW5EYXRhLnJvdGF0ZURlZ3JlZSAqIGl0ZXJhdGUgKSAtIG1lbkRhdGEucm90YXRlZFBvcylcbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5zdGFydCA9IDE0XG5cbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5kaXN0YW5jZVggPSAwXG5cbiAgICAgICAgICAgICAgICAgICAgbWVuLnRyYW5zbGF0ZVggPSBpbWFnZS54ICsgKG1lbkRhdGEubGFzdFBvc1ggKyBtZW4ud2lkdGgvMS44KVxuICAgICAgICAgICAgICAgICAgICBtZW4udHJhbnNsYXRlWSA9IGltYWdlLnkgKyAobWVuRGF0YS5sYXN0UG9zWSArIG1lbi5oZWlnaHQpXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVyYXRlID0gTWF0aC5taW4oICggcHJvZ3Jlc3MgKiAzKSwgMyApXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZihtZW5EYXRhLnJvdGF0ZWRQb3MgPD0gbWVuRGF0YS5yb3RhdGVEZWdyZWUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5yb3RhdGVkUG9zID0gKG1lbkRhdGEucm90YXRlRGVncmVlICogaXRlcmF0ZSkgXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW4ucm90YXRlICA9ICBtZW5EYXRhLnJvdGF0ZWRQb3NcblxuICAgICAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1JvdGF0ZSBiYWNrIGFuZCBmb3J0aFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYobmV3Um90YXRlZFBvcyA+PSAwKSBtZW4ucm90YXRlID0gbmV3Um90YXRlZFBvc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYobmV3Um90YXRlZFBvcyA8PSAwKSBtZW4ucm90YXRlID0gLW5ld1JvdGF0ZWRQb3M7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy91cGRhdGVzIHJvYXRlZFBvcyBmb3IgbWVuZGF0YS5qcyA9IDUgdG8gYmUgdXNlZCBiZWxvd1xuICAgICAgICAgICAgICAgICAgICBpZihwcm9ncmVzcyA9PT0gMSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZW4uYXJjUmFkaXVzID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5yb2F0ZWRQb3MgPSBtZW4ucm90YXRlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9GYWxscyBEb3duXG4gICAgICAgICAgICAgICAgaWYobWVuRGF0YS5qID09PSA1KXtcbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5zdGFydCA9IHBhcnNlSW50KCAoIHByb2dyZXNzICogMTApLnRvRml4ZWQoMCkgKTtcblxuICAgICAgICAgICAgICAgICAgICBtZW4udHJhbnNsYXRlWCA9IGltYWdlLnggKyAobWVuRGF0YS5sYXN0UG9zWCArIG1lbi53aWR0aCAvIDIpICsgKCAodGhpcy53aWR0aCAvIDYgKSAqIHByb2dyZXNzIClcbiAgICAgICAgICAgICAgICAgICAgbWVuLnRyYW5zbGF0ZVkgPSBpbWFnZS55ICsgKG1lbkRhdGEubGFzdFBvc1kgKyBtZW4uaGVpZ2h0KSAgKyAoICh0aGlzLmhlaWdodCAvIDIpICogcHJvZ3Jlc3MgKVxuICAgICAgICAgICAgICAgICAgICBtZW4ucm90YXRlID0gbWVuRGF0YS5yb2F0ZWRQb3MgKyAoMTgwICogcHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuZGlzdGFuY2VYID0gMFxuICAgICAgICAgICAgICAgICAgICBpZihwcm9ncmVzcyA9PT0gMSkgbWVuLm9wYWNpdHkgPSAwXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKG1lbkRhdGEuaiA9PT0gNil7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBtZW4ub3BhYyA9IG1lbi5vcGFjaXR5ICsgKDEgKiBwcm9ncmVzcylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYobWVuLnN0YXJ0UG9zID09PSBtZW5EYXRhLnN0YXJ0KXsgXG5cbiAgICAgICAgICAgICAgICAgICAgLy9Db25zdGFuYXRseSB1cGRhdGVzIG1lbiBsb2NhdGlvbiBvbiB0aGUgSG91c2VcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RYID0gbWVuRGF0YS5sYXN0UG9zWCArICggbWVuRGF0YS5kaXN0YW5jZVggKiBwcm9ncmVzcyApO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGFzdFkgPSBtZW5EYXRhLmxhc3RQb3NZICsgKCBtZW4ud2Fsa0Rvd24gfHwgMCApXG5cbiAgICAgICAgICAgICAgICAgICAgbWVuLnggPSBpbWFnZS54ICsgKG1lbkRhdGEubGFzdFBvc1ggKyAoIG1lbkRhdGEuZGlzdGFuY2VYICogcHJvZ3Jlc3MpIClcbiAgICAgICAgICAgICAgICAgICAgbWVuLnkgPSBpbWFnZS55ICArIChtZW5EYXRhLmxhc3RQb3NZICsgKG1lbi53YWxrRG93biB8fCAwKSApXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGRyYXdNZW4obWVuKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKHByb2dyZXNzIDwgMSl7XG5cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vUmVzZXRzIG9yIHVwZGF0ZXMgcG9zaXRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW5EYXRhLmxhc3RQb3NYID0gbGFzdFhcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbkRhdGEubGFzdFBvc1kgPSBsYXN0WVxuICAgICAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5qKytcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuYmVnaW4gPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW5EYXRhLnN0YXJ0PTBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgZHJhd0hvdXNlKGltYWdlLHRpbWVzdGFtcClcblxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhdylcblxuICAgIH0uYmluZCh0aGlzKTtcblxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hbmltYXRpb25zIC5zdGFydC1jYW52YXMnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgU3RhcnJ5TmlnaHQucHJvdG90eXBlLnRvZ2dsZSA9IHRydWVcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXcpXG5cbiAgICB9LmJpbmQodGhpcykpXG5cbiAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmFuaW1hdGlvbnMgLnN0b3AtY2FudmFzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuXG4gICAgICAgIFN0YXJyeU5pZ2h0LnByb3RvdHlwZS50b2dnbGUgPSBmYWxzZVxuICAgIH0pXG59XG5cblN0YXJyeU5pZ2h0LnByb3RvdHlwZS5sb2FkSW1hZ2VzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgaGVpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggPCA3NjggPyA2MCA6IDgwXG4gICAgdmFyIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGggPCA3NjggPyA0OCA6IDY0XG4gICAgdmFyICR0aGlzID0gdGhpc1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGltYWdlcyA9IFtdXG4gICAgdmFyIGV4dCA9IGlzRmlyZWZveCA/IFwicG5nXCIgOiBcInN2Z1wiO1xuIFxuICAgIHZhciBtZW4gPSBbICAgICAgICAgXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi96ZXJvLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi9vbmUuXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL3R3by5cIitleHQsIGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGh9LFxuICAgICAgICB7c3JjOiBcImltYWdlcy9tZW4vdGhyZWUuXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL2ZvdXIuXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL2ZpdmUuXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL3NpeC5cIitleHQsIGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGh9LFxuICAgICAgICB7c3JjOiBcImltYWdlcy9tZW4vc2V2ZW4uXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL2VpZ2h0LlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi9uaW5lLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi90ZW4uXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL2VsZXZlbi5cIitleHQsIGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGh9LFxuICAgICAgICB7c3JjOiBcImltYWdlcy9tZW4vdHdlbHZlLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi90aGlydGVlbi5cIitleHQsIGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGh9LFxuICAgICAgICB7c3JjOiBcImltYWdlcy9tZW4vZm91cnRlZW4uXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL2ZpZnRlZW4uXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL2hlYWRsZXNzLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi9ob3VzZS1mbG9hdGluZy5cIitleHR9XG4gICAgXTtcblxuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBtZW4ubGVuZ3RoOyBpKyspe1xuICAgICAgICBcbiAgICAgICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgdGhyb3cgaVxuICAgICAgICB9Y2F0Y2goaSl7XG4gICAgICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgIFxuICAgICAgICAgICAgICAgIGltYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaW1nOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IG1lbltpXS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBtZW5baV0ud2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgICAgICBzdGFydFBvczogaVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCsrY291bnQgPT09IG1lbi5sZW5ndGgpe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9Tb3J0cyB0aGUgbWVuIGFycmF5IGluIG9yZGVyIGR1ZSB0byBsb2FkaW5nIGltYWdlcyBkaWZmZXJlbnRseVxuICAgICAgICAgICAgICAgICAgICBpbWFnZXMuc29ydChmdW5jdGlvbihhLGIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuc3RhcnRQb3MgLSBiLnN0YXJ0UG9zO1xuICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgICAgIHN0YXJyeU5pZ2h0LmltYWdlcyA9IGltYWdlcztcbiAgICAgICAgICAgICAgICAgICAgLy91cGRhdGVzIHRoZSB1bmRlZmluZWQgaG91c2UgcHJvcGVydHkgd2l0aCB0aGlzIGltZ1xuICAgICAgICAgICAgICAgICAgICAkdGhpcy5ob3VzZS5ob3VzZUltZyA9IGltZztcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuYWRkRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmhvdXNlLmJlZ2luKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbWcuc3JjID0gbWVuW2ldLnNyY1xuICAgICAgICB9XG4gICAgfVxufTtcbmZ1bmN0aW9uIHNldFRlY2hub2xvZ2llc1dpZHRoKGNhbnZhc1dpZHRoLCBzdmdIZWlnaHQpe1xuICAgIFxuICAgICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RlY2hJY29ucycpO1xuICAgICAgICBpZih3VyA8IDc2OCkgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGNhbnZhc1dpZHRoICogLjkwICsgJ3B4J1xuICAgICAgICBpZih3VyA8IDU0MCkgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGNhbnZhc1dpZHRoICogLjc1ICsgJ3B4J1xuICAgICAgICBjYW52YXMuc3R5bGUudG9wID0gc3ZnSGVpZ2h0IC0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCArICdweCdcbiAgICBcbn1cbnZhciBUZWNobm9sb2dpZXMgPSBmdW5jdGlvbigpIHsgXG4gICAgdmFyIHN2Z1BhZ2VXaWR0aCA9ICBfKCdzdmctcGFnZScpLmdldEF0dHJpYnV0ZSgnd2lkdGgnKVxuICAgIHZhciBzdmdQYWdlSGVpZ2h0ID0gXygnc3ZnLXBhZ2UnKS5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpXG4gICAgdmFyIHdpZHRoID0gc3ZnUGFnZVdpZHRoIDwgOTcwICB8fCBzdmdQYWdlSGVpZ2h0IDwgODAwO1xuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RlY2hJY29ucycpO1xuICAgIFxuICAgIHRoaXMuY3R4ID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLndpZHRoID0gdGhpcy5jYW52YXMud2lkdGggPSBzdmdQYWdlV2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSBzdmdQYWdlSGVpZ2h0O1xuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuc3RhcnQ7XG4gICAgdGhpcy5kdXJhdGlvbiA9IDEwMDA7XG4gICAgdGhpcy5ib2R5RGF0YSA9IFtdO1xuICAgIHRoaXMuaWNvbnM7XG4gICAgdGhpcy5qID0gMDtcbiAgICB2YXIgbmV3VGVjaG5vbG9naWVzID0gdGhpcztcbiAgICAvL1NldHMgY2FudmFzIHdpZHRoIGFnYWluXG4gICAgaWYod1cgPCA3NjgpIHNldFRlY2hub2xvZ2llc1dpZHRoKHRoaXMud2lkdGgsIHN2Z1BhZ2VIZWlnaHQpXG4gICAgdGhpcy5kYXRhID0ge1xuICAgICAgICBhZGRCb2R5RGF0YTogIGZ1bmN0aW9uKCl7XG4gICAgXG4gICAgICAgICAgICBpZih3aWR0aCl7XG4gICAgICAgICAgICAgICAgLy9Cb2R5IGxvY2F0aW9uIFggYW5kIFlcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4IDogbmV3VGVjaG5vbG9naWVzLndpZHRoLzIgIC0gKG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS53aWR0aCAvIDIuMiksXG4gICAgICAgICAgICAgICAgICAgIHkgOiAobmV3VGVjaG5vbG9naWVzLmhlaWdodCAtIG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS5oZWlnaHQpICxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWDogbmV3VGVjaG5vbG9naWVzLndpZHRoLzIgLSAobmV3VGVjaG5vbG9naWVzLmJvZHlEYXRhWzNdLndpZHRoLzIpKzYwLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiAobmV3VGVjaG5vbG9naWVzLmhlaWdodCAtIG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS5oZWlnaHQpICs3MCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZFg6IG5ld1RlY2hub2xvZ2llcy53aWR0aC8yICAtIChuZXdUZWNobm9sb2dpZXMuYm9keURhdGFbMV0ud2lkdGggLyAyLjIpICsgNDEsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRZOiAobmV3VGVjaG5vbG9naWVzLmhlaWdodCAtIG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS5oZWlnaHQpIC0gNjFcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB4IDogbmV3VGVjaG5vbG9naWVzLndpZHRoLzIgIC0gKG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS53aWR0aCAvIDIuMiksXG4gICAgICAgICAgICAgICAgICAgIHkgOiAobmV3VGVjaG5vbG9naWVzLmhlaWdodCAtIG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS5oZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICAvL1RyYW5zbGF0ZSBoZWFkIHJvdGF0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVg6IG5ld1RlY2hub2xvZ2llcy53aWR0aC8yIC0gKG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVszXS53aWR0aC8yKSs4NSxcbiAgICAgICAgICAgICAgICAgICAgLy9UcmFuc2xhdGUgaGVhZCByb3RhdGlvblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVZOiAobmV3VGVjaG5vbG9naWVzLmhlaWdodCAtIG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS5oZWlnaHQpICsgMTAwLFxuICAgICAgICAgICAgICAgICAgICBoZWFkWDogbmV3VGVjaG5vbG9naWVzLndpZHRoLzIgIC0gKG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS53aWR0aCAvIDIuMikgKyA1NyxcbiAgICAgICAgICAgICAgICAgICAgaGVhZFk6IChuZXdUZWNobm9sb2dpZXMuaGVpZ2h0IC0gbmV3VGVjaG5vbG9naWVzLmJvZHlEYXRhWzFdLmhlaWdodCkgLSA4N1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcm90YXRlOiAtMTQwLFxuICAgICAgICBqOiAwLFxuICAgICAgICBib29rSGVpZ2h0OiAyMDBcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zcHJpdGVzID0gW11cbiAgICAgICBcbiAgICAgICAgdmFyIGV4dCA9IGlzRmlyZWZveCA/IFwicG5nXCIgOiBcInN2Z1wiO1xuXG4gICAgICAgIHZhciBib2R5V2lkdGggPSB3aWR0aCA/IDEuMyA6IDEuODtcbiAgICAgICAgdmFyIGJvZHlIZWlnaHQgPSB3aWR0aCA/IDEuMyA6IDEuODtcbiAgICAgICAgdmFyIHNyYyA9IFtcImltYWdlcy90b3AtaGVhZC5cIitleHQsIFwiaW1hZ2VzL2ZhY2UtYm9keS5cIitleHQsIFwiaW1hZ2VzL2Jvb2suXCIrZXh0LCBcImltYWdlcy9mdWxsLWJvZHkuXCIrZXh0XVxuXG4gICAgICAgIGlmKHdpZHRoKXtcbiAgICAgICAgICAgIHZhciBpbWdXaWR0aCA9IFsyODQuNSAsNDAwLCAzMjAuOTYsIDQwMF1cbiAgICAgICAgICAgIHZhciBpbWdIZWlnaHQgPSBbMTcwLjksIDQ4My43LCAyMjYuOCwgNTY0LjY2XVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHZhciBpbWdXaWR0aCA9IFs1NTMuNSwgNzc4LjIsIDYyOS45LCA3NzhdXG4gICAgICAgICAgICB2YXIgaW1nSGVpZ2h0ID0gWzMzMi40OSwgOTQxLCA0NDMuMjcsIDEwOTguOV1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICB0aGlzLmltZ0ljb25zID0gW1xuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL2Fkb2JlLTUwLTUwLlwiK2V4dCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQwfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9hZnRlci1lZmZlY3RzLTUyLTUyLlwiK2V4dCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQwfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9hcnRpc3RpYy01Mi01NC5cIitleHQsIHdpZHRoOiA0MCwgaGVpZ2h0OiA0Mn0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvYm9vdHN0cmFwLTUwLTUwLlwiK2V4dCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQwfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9jYW1lcmEtNTItNTIuXCIrZXh0LCB3aWR0aDogNDAsIGhlaWdodDogNDB9LFxuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL2Nsb3VkLTY0LTQ5LjUuXCIrZXh0LCB3aWR0aDogNDIsIGhlaWdodDogMzIuNX0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvY29kZS02MC01My5cIitleHQsIHdpZHRoOiA0MywgaGVpZ2h0OiAzOH0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvY3NzLTU1LTUyLlwiK2V4dCwgd2lkdGg6IDQyLCBoZWlnaHQ6IDM5Ljh9LFxuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL2Rlc2lnbi01Mi01Mi5cIitleHQsIHdpZHRoOiA0MCwgaGVpZ2h0OiA0MH0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvZ2l0LWh1Yi01NS01NS5cIitleHQsIHdpZHRoOiA0MywgaGVpZ2h0OiA0M30sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvZ29vZ2xlLWRyaXZlLTcyLTY0LlwiK2V4dCwgd2lkdGg6IDQ2LCBoZWlnaHQ6IDQwLjh9LFxuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL2lsbHVzdHJhdG9yLTUyLTUyLlwiK2V4dCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQwfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9qcy01NS01Ni5cIitleHQsIHdpZHRoOiA0MSwgaGVpZ2h0OiA0Mn0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvbm9kZS01MC01MC5cIitleHQsIHdpZHRoOiA0MCwgaGVpZ2h0OiA0MH0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvbm9kZWpzLTYwLjUtMzcuXCIrZXh0LCB3aWR0aDogNTUsIGhlaWdodDogMzMuNn0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvbnBtLTcwLTI3LjIuXCIrZXh0LCB3aWR0aDogNjUsIGhlaWdodDogMjUuMn0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvcGhvdG9zaG9wLTUyLTUyLlwiK2V4dCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQwfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9waHAtNjUtMzUuXCIrZXh0LCB3aWR0aDogNDUsIGhlaWdodDogMjQuMn0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvcHl0aG9uLTU3LTU4LlwiK2V4dCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQwLjd9LFxuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL3JlYWN0LTU5LTUyLlwiK2V4dCwgd2lkdGg6IDQyLCBoZWlnaHQ6IDM3fSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9zZXJ2ZXItNTUtNTguXCIrZXh0LCB3aWR0aDogNDAsIGhlaWdodDogNDB9XG4gICAgICAgIF1cblxuICAgIHRoaXMubG9vcEltZ3MgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgbG9hZCA9IFtdXG5cbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKyl7XG4gICAgICAgICAgICBsb2FkLnB1c2goe1xuICAgICAgICAgICAgICAgIHNyYzogc3JjW2pdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBpbWdXaWR0aFtqXSAvIGJvZHlXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGltZ0hlaWdodFtqXSAvIGJvZHlIZWlnaHRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGljb25zID0gdGhpcy5pbWdJY29uc1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpY29ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgdyA9ICF3aWR0aCA/IGljb25zW2ldLnNyYy5yZXBsYWNlKC9eKFthLXpcXC9dKylcXC8oW2Etei0/XSspLShcXGRcXGQpKC4rKS9pZyxcIiQzXCIpIDogaWNvbnNbaV0ud2lkdGhcbiAgICAgICAgICAgIHZhciBoID0gIXdpZHRoID8gaWNvbnNbaV0uc3JjLnJlcGxhY2UoL14oLispKFxcZHsyfSkoLispL2lnLFwiJDJcIikgOiBpY29uc1tpXS5oZWlnaHRcblxuICAgICAgICAgICAgbG9hZC5wdXNoKHtcbiAgICAgICAgICAgICAgICBzcmM6IGljb25zW2ldLnNyYyxcbiAgICAgICAgICAgICAgICB3aWR0aDogcGFyc2VJbnQodyksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJzZUludChoKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9hZFxuICAgIH07XG4gICAgZnVuY3Rpb24gcmFuZG9tKG1pbiwgbWF4KXtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqICAobWF4IC0gbWluICkgKyBtaW4pXG4gICAgfTtcbiAgICB0aGlzLmFkZERhdGEgPSBmdW5jdGlvbihuKXtcbiAgICAgICAgdmFyIGljb25zID0gdGhpcy5pY29uc1xuICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgbjsgaSsrICl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAvL0VhY2ggaWNvbiBkcmF3cyBmb3IgZXZlciAzMCBtaWwgc2VjXG4gICAgICAgICAgICAgICAgdGltaW5nOiAgMzAsXG4gICAgICAgICAgICAgICAgZW5kWDogcmFuZG9tKDAsIHRoaXMud2lkdGgvMiApLFxuICAgICAgICAgICAgICAgIGVuZFk6IHJhbmRvbSgwLCB0aGlzLmhlaWdodCAtICh0aGlzLmJvZHlEYXRhWzFdLmhlaWdodCArIDUwKSApLFxuICAgICAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgIHNwZWVkOiByYW5kb20oNDAwMCwgOTAwMCksXG4gICAgICAgICAgICAgICAgeDogdGhpcy53aWR0aCAvIDIsXG4gICAgICAgICAgICAgICAgeTogdGhpcy5kYXRhLmFkZEJvZHlEYXRhKCkueSArIDE1LCAvLyBwbHVzIDEwMCB0aGUgc3ByaXRlIHNpemVcbiAgICAgICAgICAgICAgICBpbWc6IHRoaXMuaWNvbnNbaSVpY29ucy5sZW5ndGhdLmltZyxcbiAgICAgICAgICAgICAgICB3aWR0aDogdGhpcy5pY29uc1tpJWljb25zLmxlbmd0aF0ud2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLmljb25zW2klaWNvbnMubGVuZ3RoXS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgWDogMCxcbiAgICAgICAgICAgICAgICBZOiAwLFxuICAgICAgICAgICAgICAgIHN0YXRpY1NwZWVkOiAwLFxuICAgICAgICAgICAgICAgIHJvdGF0ZTogcmFuZG9tKDE4MCwgMTQ0MClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG59XG5cblRlY2hub2xvZ2llcy5wcm90b3R5cGUucm90YXRlSGVhZCA9IGZ1bmN0aW9uKHJvdGF0ZSwgcG9zKXtcbiAgICB2YXIgaW1nID0gdGhpcy5ib2R5RGF0YVxuICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLDAsdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodClcbiAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1nWzFdLmltZywgIHBvcy54LCBwb3MueSwgaW1nWzFdLndpZHRoLCBpbWdbMV0uaGVpZ2h0KSAvL0ZhY2UgYm9keVxuICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSggIHBvcy50cmFuc2xhdGVYLCBwb3MudHJhbnNsYXRlWSk7IC8vIFRyYW5zbGF0ZSBcbiAgICB0aGlzLmN0eC5yb3RhdGUocm90YXRlICogTWF0aC5QSS8xODApXG4gICAgdGhpcy5jdHgudHJhbnNsYXRlKCAtcG9zLnRyYW5zbGF0ZVgsLXBvcy50cmFuc2xhdGVZICk7IC8vIFRyYW5zbGF0ZSBiYWNrXG4gICAgdGhpcy5jdHguZHJhd0ltYWdlKGltZ1swXS5pbWcsICBwb3MuaGVhZFggLCAgcG9zLmhlYWRZLCBpbWdbMF0ud2lkdGgsIGltZ1swXS5oZWlnaHQpICAvL0hlYWQgZHJhdyBpbiB0cmFuc2xhdGVkIGNhbnZlc1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbn07XG5cblRlY2hub2xvZ2llcy5wcm90b3R5cGUuZHJhd0Jvb2sgPSBmdW5jdGlvbihkYXRhLCBwb3Mpe1xuICAgIHZhciBpbWcgPSB0aGlzLmJvZHlEYXRhXG4gICAgdGhpcy5jdHguY2xlYXJSZWN0KDAsMCx0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KVxuICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdmVyJ1xuICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWdbMV0uaW1nLCAgcG9zLngsIHBvcy55LCBpbWdbMV0ud2lkdGgsIGltZ1sxXS5oZWlnaHQpIC8vRmFjZSBib2R5XG4gICAgdGhpcy5jdHgudHJhbnNsYXRlKCAgcG9zLnRyYW5zbGF0ZVgsIHBvcy50cmFuc2xhdGVZKTsgLy8gVHJhbnNsYXRlIFxuICAgIHRoaXMuY3R4LnJvdGF0ZSgtMTQwICogTWF0aC5QSS8xODApXG4gICAgdGhpcy5jdHgudHJhbnNsYXRlKCAtcG9zLnRyYW5zbGF0ZVgsLXBvcy50cmFuc2xhdGVZICk7IC8vIFRyYW5zbGF0ZSBiYWNrXG4gICAgdGhpcy5jdHguZHJhd0ltYWdlKGltZ1swXS5pbWcsICBwb3MuaGVhZFggLCAgcG9zLmhlYWRZLCBpbWdbMF0ud2lkdGgsIGltZ1swXS5oZWlnaHQpICAvL0hlYWQgZHJhdyBpbiB0cmFuc2xhdGVkIGNhbnZlc1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCk7XG5cbiAgICB0aGlzLmN0eC50cmFuc2xhdGUoICBwb3MudHJhbnNsYXRlWCArIGltZ1syXS53aWR0aCAvIDIsIHBvcy50cmFuc2xhdGVZKTsgLy8gVHJhbnNsYXRlICBcbiAgICB0aGlzLmN0eC5zY2FsZShkYXRhLnNjYWxlLCBkYXRhLnNjYWxlKTsgLy9TY2FsZXMgYm9va1xuICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSggLXBvcy50cmFuc2xhdGVYIC0gaW1nWzJdLndpZHRoIC8gMiAsLXBvcy50cmFuc2xhdGVZICk7IC8vIFRyYW5zbGF0ZSBiYWNrIGZvclxuICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWdbMl0uaW1nLCBkYXRhLmJvb2tYLCBkYXRhLmJvb2tZLCBpbWdbMl0ud2lkdGgsIGltZ1syXS5oZWlnaHQpIC8vYm9vayBpbWFnZVxuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCk7XG59O1xuXG5UZWNobm9sb2dpZXMucHJvdG90eXBlLmRyYXdCb2R5ID0gZnVuY3Rpb24oZGF0YSwgcG9zICl7XG4gICAgdmFyIGltZyA9IHRoaXMuYm9keURhdGFcblxuICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWdbMV0uaW1nLCAgcG9zLngsIHBvcy55LCBpbWdbMV0ud2lkdGgsIGltZ1sxXS5oZWlnaHQpIC8vRmFjZSBib2R5XG4gICAgdGhpcy5jdHgudHJhbnNsYXRlKCAgcG9zLnRyYW5zbGF0ZVgsIHBvcy50cmFuc2xhdGVZKTsgLy8gVHJhbnNsYXRlIFxuICAgIHRoaXMuY3R4LnJvdGF0ZSgtMTQwICogTWF0aC5QSS8xODApXG4gICAgdGhpcy5jdHgudHJhbnNsYXRlKCAtcG9zLnRyYW5zbGF0ZVgsLXBvcy50cmFuc2xhdGVZICk7IC8vIFRyYW5zbGF0ZSBiYWNrXG4gICAgdGhpcy5jdHguZHJhd0ltYWdlKGltZ1swXS5pbWcsICBwb3MuaGVhZFggLCAgcG9zLmhlYWRZLCBpbWdbMF0ud2lkdGgsIGltZ1swXS5oZWlnaHQpICAvL0hlYWQgZHJhdyBpbiB0cmFuc2xhdGVkIGNhbnZlc1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMCk7XG4gICAgdGhpcy5jdHgudHJhbnNsYXRlKCAgcG9zLnRyYW5zbGF0ZVggKyBpbWdbMl0ud2lkdGggLyAyLCBwb3MudHJhbnNsYXRlWSk7IC8vIFRyYW5zbGF0ZSAgXG4gICAgdGhpcy5jdHguc2NhbGUoMS4wNSwgMS4wNSk7XG4gICAgdGhpcy5jdHgudHJhbnNsYXRlKCAtcG9zLnRyYW5zbGF0ZVggLSBpbWdbMl0ud2lkdGggLyAyICwtcG9zLnRyYW5zbGF0ZVkgKTsgLy8gVHJhbnNsYXRlIGJhY2tcbiAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1nWzJdLmltZywgZGF0YS5ib29rWCwgZGF0YS5ib29rWSwgaW1nWzJdLndpZHRoLCBpbWdbMl0uaGVpZ2h0KSAvL2Jvb2sgaW1hZ2VcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApO1xufTtcblxuVGVjaG5vbG9naWVzLnByb3RvdHlwZS5kcmF3SWNvbnMgPSBmdW5jdGlvbihzcHIpe1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLCBzcHIuWCwgc3ByLlkpO1xuICAgIHRoaXMuY3R4LnJvdGF0ZShzcHIudHVybiAqIE1hdGguUEkvMTgwKVxuICAgIHRoaXMuY3R4LmRyYXdJbWFnZShzcHIuaW1nLC1zcHIud2lkdGgvMiwgLXNwci5oZWlnaHQvMiwgc3ByLndpZHRoLCBzcHIuaGVpZ2h0ICk7XG4gICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKVxufTtcblxuVGVjaG5vbG9naWVzLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24odGltZXN0YW1wKXtcbiAgICBpZighdGhpcy50b2dnbGUpIHJldHVyblxuICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGggPCA5NzAgIHx8IHRoaXMuaGVpZ2h0IDwgODAwXG4gICAgdmFyIGltZyA9IHRoaXMuYm9keURhdGFcbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICB2YXIgcG9zID0gZGF0YS5hZGRCb2R5RGF0YSgpO1xuICAgIFxuICBcbiAgICBpZighdGhpcy5zdGFydClcblxuICAgICAgICB0aGlzLnN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgIHZhciBydW50aW1lID0gdGltZXN0YW1wIC0gdGhpcy5zdGFydFxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBNYXRoLm1pbihydW50aW1lIC8gMTAwMCwgMSlcblxuICAgICAgICBpZihwcm9ncmVzcyA8IDEgJiYgZGF0YS5qIDw9IDEpe1xuICAgICAgXG4gICAgICAgICAgICBpZih3aWR0aCl7XG4gICAgICAgICAgICAgICAgLy9VcGRhdGVzIHggbG9hY3Rpb25zIGFuZCB5IGxvY2F0aW9uIG9mIGJvb2tcbiAgICAgICAgICAgICAgICBkYXRhLmJvb2tYID0gKChwb3MudHJhbnNsYXRlWCktNDApIC0gKDApXG4gICAgICAgICAgICAgICAgZGF0YS5ib29rWSA9ICgocG9zLnRyYW5zbGF0ZVkpLTExMCkgLSAoNjAqcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgLy9VcGRhdGVzIHggbG9hY3Rpb25zIGFuZCB5IGxvY2F0aW9uIG9mIGJvb2tcbiAgICAgICAgICAgICAgICBkYXRhLmJvb2tYID0gKChwb3MudHJhbnNsYXRlWCktNjApIC0gKDApO1xuICAgICAgICAgICAgICAgIGRhdGEuYm9va1kgPSAoKHBvcy50cmFuc2xhdGVZKS0xODApIC0gKDYwKnByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vUm90YXRlIGhlYWRcbiAgICAgICAgICAgIGlmKGRhdGEuaiA9PT0gMCl7XG5cbiAgICAgICAgICAgICAgICB2YXIgcm90YXRlID0gZGF0YS5yb3RhdGUqcHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgdGhpcy5yb3RhdGVIZWFkKHJvdGF0ZSxwb3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1B1c2ggdXAgYm9va1xuICAgICAgICAgICAgaWYoZGF0YS5qID09PSAxKXtcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmR1cmF0aW9uID0gNTAwXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3JhbiBib29rJylcbiAgICAgICAgICAgICAgICBkYXRhLnNjYWxlID0gLjUgKyAoLjU1ICogcHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3Qm9vayhkYXRhLHBvcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG5cbiAgICAgICAgICAgIC8vRHJhdyBJY29uc1xuICAgICAgICAgICAgaWYoZGF0YS5qID09PSAyKXtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApO1xuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLDAsdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodClcbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdCb2R5KGRhdGEsIHBvcylcblxuICAgICAgICAgICAgICAgIHZhciBzcHJpdGVzID0gdGhpcy5zcHJpdGVzLmxlbmd0aFxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHNwcml0ZXM7IGkrKyApe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNwciA9IHRoaXMuc3ByaXRlc1tpXVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoaSA8PSB0aGlzLmope1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByLnN0YXRpY1NwZWVkKytcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZighc3ByLnN0YXJ0KSBzcHIuc3RhcnQgPSB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBydW4gPSB0aW1lc3RhbXAgLSBzcHIuc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9nID0gcnVuIC8gc3ByLnNwZWVkXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihpJTIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vbGVmdCB1cFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwci5YID0gc3ByLnggLSAoc3ByLmVuZFggKiBwcm9nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwci5ZID0gc3ByLnkgLSAoc3ByLmVuZFkgKiBwcm9nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwci50dXJuID0gLXNwci5yb3RhdGUgKiBwcm9nXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vcmlnaHQgdXA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByLlggPSBzcHIueCArIChzcHIuZW5kWCAqIHByb2cpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByLlkgPSBzcHIueSAtIChzcHIuZW5kWSAqIHByb2cpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ByLnR1cm4gPSBzcHIucm90YXRlICogcHJvZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByLnRvdGFsWCA9IHNwci5YXG4gICAgICAgICAgICAgICAgICAgICAgICBzcHIudG90YWxZID0gc3ByLllcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIChzcHIudG90YWxYK3Nwci53aWR0aCkgPD0gMCB8fCAoc3ByLnRvdGFsWStzcHIuaGVpZ2h0KSA8PSAwIHx8IHNwci50b3RhbFggPiB0aGlzLndpZHRoK3Nwci53aWR0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vUmVzZXRzIHZhbHVlcywgZm9yIHNhbWUgaWNvbiB0byBydW4gYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0uc3RhcnQgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdJY29ucyhzcHIpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihzcHIuc3RhdGljU3BlZWQgPT09IHNwci50aW1pbmcpIHRoaXMuaisrXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0gMFxuICAgICAgICAgICAgICAgIGRhdGEuaisrXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuZHJhdy5iaW5kKHRoaXMpKVxufTtcblxuXG5UZWNobm9sb2dpZXMucHJvdG90eXBlLmxvYWRJbWFnZXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciAkdGhpcyA9IHRoaXM7XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHZhciBsb2FkZWRJbWFnZXMgPSAwO1xuICAgIHZhciBpbWdzID0gW107XG4gICAgXG4gICAgdGhpcy5sb29wSW1ncygpLmZvckVhY2goZnVuY3Rpb24oaW1hZ2UsIGkpe1xuICAgICAgICBjb3VudGVyKys7XG4gICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKVxuXG4gICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAvL1dpZHRoIG9yIGhlaWdodCBkb2Vzbid0IGV4aXN0IHVwZGF0ZXMgMCBmb3IgaXRcbiAgICAgICAgICAgIGltZ3MucHVzaCh7aW1nOiB0aGlzLCBpLCB3aWR0aDogaW1hZ2Uud2lkdGggLCBoZWlnaHQ6IGltYWdlLmhlaWdodCB9KVxuXG4gICAgICAgICAgICBpZigrK2xvYWRlZEltYWdlcyA+PSBjb3VudGVyKXsgICAgIFxuICAgICAgICAgICAgICAgIGltZ3Muc29ydChmdW5jdGlvbihhLGIpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5pIC0gYi5pXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAvL1doZW4gSWNvbnMgbG9hZCBmdWxsIGJvZHkgaW1hZ2UgZ2V0cyBhZGRlZFxuICAgICAgICAgICAgICAgICR0aGlzLmN0eC5kcmF3SW1hZ2UoaW1nc1szXS5pbWcsICgkdGhpcy53aWR0aC8yKSAtIGltZ3NbMV0ud2lkdGggLyAyLjIsICgkdGhpcy5oZWlnaHQpIC0gaW1nc1szXS5oZWlnaHQsIGltZ3NbM10ud2lkdGgsIGltZ3NbM10uaGVpZ2h0KSAvL0Z1bGwtYm9keSBpbWFnZVxuICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgYm9keUltZ3MgPSBpbWdzLnNwbGljZSgwLDQpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgJHRoaXMuYm9keURhdGEgPSBib2R5SW1nc1xuICAgICAgICAgICAgICAgICR0aGlzLmljb25zID0gaW1nc1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9JY29uIGRhdGFcbiAgICAgICAgICAgICAgICAkdGhpcy5hZGREYXRhKGltZ3MubGVuZ3RoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGltZy5zcmMgPSBpbWFnZS5zcmM7XG4gICAgfSlcbn07XG5cblxuZnVuY3Rpb24gU3ZnUGFnZSgpe1xuICAgIHZhciBzdmdDbG9zZUJ1dHRvbiA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2Nsb3NlLWJ0biBzdmctYnV0dG9uJylbMF1cbiAgICB2YXIgc3ZnQ2lyY2xlID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc3ZnLWNpcmNsZScpWzBdXG4gICAgdmFyIHRvZ2dsZSwgYnRuT3BlbjtcbiAgICB2YXIgaG92ZXJtYXAgPSBob3Zlck1hcCgpXG4gICAgXG4gICAgdmFyIHJlbW92ZUdvb2V5ID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIHNldFRpbWVvdXQoICgpID0+IHtcbiAgICAgICAgICAgIGhvdmVybWFwWzFdKGUpXG4gICAgICAgIH0sMTQwMClcbiAgICAgICAgXG4gICAgICAgIC8vICAgICB2YXIgZGlzdCA9IGhvdmVybWFwWzFdKGUpWzBdOyAvLyBQb3NpdGlvbiBkaXN0YW5jZSBvZiBzaG93LWljb24gZ29vZXlcbiAgICAgICAgLy8gICAgIGhvdmVybWFwWzBdKCBkaXN0LCB0cnVlICkgIC8vIGhhbmRsZXIoZSkgZnVuY3Rpb25cblxuICAgIH1cbiAgICB0aGlzLnN0YXJ0O1xuICAgIC8vUGFnZSBhbmltYXRlZCBkb3duIHJlbW92ZXMgY2lyY2xlIHRvIGJlIGFuaW1hdGVkIGFnYWluXG4gICAgdGhpcy5hbmltYXRlRW5kID0gZnVuY3Rpb24oZSl7XG4gICAgICAgICBfKCdpbnRlcmFjdGl2ZS1jb250YWluZXInKS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nIFxuXG4gICAgICAgIGlmKHRvZ2dsZSl7XG4gICAgICAgICAgICAvL1NhZmFyaSBvbmx5XG4gICAgICAgICAgICBfKCdzdmctcGFnZScpLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgICAgICAgICAgc3ZnQ2lyY2xlLmNsYXNzTGlzdC5yZW1vdmUoJ2NpcmNsZS1hbmltYXRlJyk7XG5cbiAgICAgICAgICAgIF8oYnRuT3BlbilbMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZy4nK2J0bk9wZW4rJyAuaXRlbXMnKS5jbGFzc0xpc3QucmVtb3ZlKCdpdGVtcy1hY3RpdmUnKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0b2dnbGUgPSBmYWxzZVxuICAgICAgICB9ICAgXG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRlQ2lyY2xlID0gZnVuY3Rpb24odGltZXN0YW1wLCBlbGVtKXtcbiAgICAgICAgXG4gICAgICAgIGlmKCF0aGlzLnN0YXJ0KSB0aGlzLnN0YXJ0ID0gdGltZXN0YW1wO1xuXG4gICAgICAgICAgICB2YXIgcnVudGltZSA9IHRpbWVzdGFtcCAtIHRoaXMuc3RhcnQ7XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBNYXRoLm1pbihydW50aW1lIC8gdGhpcy5zcGVlZCwgMSlcbiAgICAgICAgICAgIGlzRmlyZWZveCA/IHN2Z0NpcmNsZS5zZXRBdHRyaWJ1dGUoJ3InLCAxNTAwICogcHJvZ3Jlc3MpIDogc3ZnQ2lyY2xlLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgnKyAoMCArICgxKnByb2dyZXNzKSApKyAnKSdcbiAgICAgICBcbiAgICAgICAgaWYocHJvZ3Jlc3MgPCAxKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24odGltZXN0YW1wKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGVDaXJjbGUodGltZXN0YW1wLCBlbGVtKVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAvL0NhbnZhcyBmYWRlcyBpbiBhZnRlciBwYWdlIGlzIGFuaW1hdGVkIG9wZW5cbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2cuJytlbGVtKycgLml0ZW1zJykuY2xhc3NMaXN0LmFkZCgnaXRlbXMtYWN0aXZlJylcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZWxlbSlbMV0ucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzaG93Q2FudmFzJylcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBudWxsO1xuICAgICAgICB9IFxuICAgIH1cbiAgICB2YXIgY2xvc2VCdXR0b25TaG93ID0gZnVuY3Rpb24obnVtKXtcbiAgICAgICAgdmFyIG9wcG9zaXRlID0gIW51bSA/IC01NiA6IDBcbiAgICAgICAgIF8oJ3gtY2lyY2xlJykuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVgoJysgbnVtICsncHgpJ1xuICAgICAgICAgXygnbGluZScpWzBdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKCcrIG9wcG9zaXRlICsncHgpIHJvdGF0ZSgtNDVkZWcpJ1xuICAgICAgICAgXygnbGluZScpWzFdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKCcrIG9wcG9zaXRlICsncHgpIHJvdGF0ZSg0NWRlZyknXG4gICAgfVxuXG4gICAgLy8gT3BlbiBwYWdlIGZ1bmN0aW9uXG4gICAgdGhpcy5vcGVuTW9kYWxzID0gZnVuY3Rpb24oZSl7XG4gICAgICAgIFxuICAgICAgICB0cnl7XG4gICAgICAgICAgICBidG5PcGVuID0gZS50YXJnZXQuaWRcbiAgICAgICAgfWNhdGNoKGVycil7XG4gICAgICAgICAgICBidG5PcGVuID0gZVxuICAgICAgICB9XG4gIFxuICAgICAgICBfKCdpbnRlcmFjdGl2ZS1jb250YWluZXInKS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnIFxuICAgICAgICBldmVudCA9IGU7XG4gICAgICAgIF8oYnRuT3BlbilbMF0uc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgY2xvc2VCdXR0b25TaG93KC01NilcbiAgICAgICAgLy9Hb29nbGUgJ0RvIEh5ZW9uJyBmb250IGJ1ZywgZnVuY3Rpb24gaGFzIHRvIGJlIHJhbiBhZ2FpbiBpbiB2aWV3XG4gICAgICAgIGlmKGJ0bk9wZW4gPT09ICdwaG90bycpIHNsb3RNYWNoaW5lKClcbiAgICAgICAgLy9UaHJvYmJpbmcgRmluZ2VyIGltYWdlIGljb25cbiAgICAgICAgaWYoYnRuT3BlbiA9PT0gJ2Rlc2lnbicpIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaW5nZXInKS5jbGFzc0xpc3QuYWRkKCdmaW5nZXItc2NhbGUnKVxuXG4gICAgICAgIGlmKGlzU2FmYXJpKXtcblxuICAgICAgICAgICAgdG9nZ2xlID0gdHJ1ZTtcbiAgICAgICAgICAgICBfKCdzdmctcGFnZScpLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIlxuICAgICAgICAgICAgc3ZnQ2lyY2xlLmNsYXNzTGlzdC5hZGQoJ2NpcmNsZS1hbmltYXRlJylcblxuICAgICAgICAgICAgc3ZnQ2lyY2xlLm9uYW5pbWF0aW9uZW5kID0gZnVuY3Rpb24oKXtcbiAgICAgIFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2cuJytidG5PcGVuKycgLml0ZW1zJykuY2xhc3NMaXN0LmFkZCgnaXRlbXMtYWN0aXZlJylcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGJ0bk9wZW4pWzFdLnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2hvd0NhbnZhcycpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9DbG9zZXMgdGhlIHBhZ2UgYW5pbWF0ZWQgZG93blxuICAgICAgICAgICAgc3ZnQ2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHRvZ2dsZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvL0F1dG9tYXRpY2FsbHkgc3RvcHMgY2FudmFzIFxuICAgICAgICAgICAgICAgIFN0cmV0Y2gucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgc2xvdE1hY2hpbmUucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgU3RhcnJ5TmlnaHQucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgVGVjaG5vbG9naWVzLnByb3RvdHlwZS50b2dnbGUgPSBmYWxzZVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL0NhbnZhcyAvIEl0ZW1zIGZhZGVzIG91dFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYnRuT3BlbilbMV0ucGFyZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Q2FudmFzJylcbiAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9KVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRvZ2dsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24odGltZXN0YW1wKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID0gNjAwO1xuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZUNpcmNsZSh0aW1lc3RhbXAsIGJ0bk9wZW4pXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuXG4gICAgICAgICAgICBzdmdDbG9zZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgICAgICAgICAgICAgIGNsb3NlQnV0dG9uU2hvdygwKVxuICAgICAgICAgICAgICAgIFN0cmV0Y2gucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgc2xvdE1hY2hpbmUucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgU3RhcnJ5TmlnaHQucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgVGVjaG5vbG9naWVzLnByb3RvdHlwZS50b2dnbGUgPSBmYWxzZVxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYnRuT3BlbilbMV0ucGFyZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Q2FudmFzJylcblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgaXNGaXJlZm94ID8gXygnc3ZnLWNpcmNsZScpLnNldEF0dHJpYnV0ZSgncicsIDApIDogXygnc3ZnLWNpcmNsZScpLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgwKSdcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9DdXJyZW50IFNWRyBlbGVtZW50IGhpZGVzXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYnRuT3BlbilbMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdnLicrYnRuT3BlbisnIC5pdGVtcycpLmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3dDYW52YXMnKVxuICAgICAgICAgICAgICAgICAgICAvLyBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGJ0bk9wZW4pWzFdLnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnc2hvd0NhbnZhcycpXG4gICAgICAgICAgICAgICAgfSwxMTAwKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICB2YXIgcG9wVXBDYXJkcyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGxldCBvcGVuX21vZGFscyA9IHRoaXMub3Blbk1vZGFsc1xuXG4gICAgICAgIGxldCBwb3BVcGNhcmRzID0gXygnY2FyZC1wb3B1cHMnKVxuICAgICAgICBmb3IobGV0IGNhcmRzIG9mIHBvcFVwY2FyZHMpe1xuICAgICAgICAgICAgY2FyZHMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICByZW1vdmVHb29leShlKVxuICAgICAgICAgICAgICAgIG9wZW5fbW9kYWxzKHRoaXMuYXR0cmlidXRlc1szXS52YWx1ZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9LmJpbmQodGhpcylcbiAgICBpZih3VyA8IDc2OCkgcG9wVXBDYXJkcygpXG4gICAgXG4gICAgXygnY2lyY2xlLXRodW1ibmFpbHMnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuICAgICAgICBpZih3VyA8IDc2OCl7XG4gICAgICAgICAgICBob3Zlcm1hcFsxXShlKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHJlbW92ZUdvb2V5KGUpXG4gICAgICAgICAgICB0aGlzLm9wZW5Nb2RhbHMoZSlcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgIFxuICAgIH0uYmluZCh0aGlzKSk7XG59O1xuLy9BZGQgdG8gd2luZG93IG9iamVjdCB0byBiZSB1c2VkIGZvciBodG1sIHBhZ2Ugb25lbmQgZnVuY3Rpb25cbndpbmRvdy5zdmdQYWdlID0gbmV3IFN2Z1BhZ2UoKTtcblxuZnVuY3Rpb24gZ2V0UG9zKGVsZSl7XG4gICAgICAgIFxuICAgIHZhciBlbGVtUmVjdCA9IGVsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgbWFpblN2ZyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3N2Zy1wYWdlJylbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGVsZW1MZWZ0ID0gKG1haW5Tdmcud2lkdGggLSAoIHBhcnNlSW50KGVsZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgKSB8fCBlbGVtUmVjdC53aWR0aCkgKSAvIDJcblxuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBlbGVtUmVjdC53aWR0aCxcbiAgICAgICAgbWFpblN2ZzogbWFpblN2ZyxcbiAgICAgICAgbGVmdDogZWxlbVJlY3QubGVmdCxcbiAgICAgICAgdG9wOiBlbGVtUmVjdC50b3AsXG4gICAgICAgIGhlaWdodDogZWxlbVJlY3QuaGVpZ2h0LFxuICAgICAgICAvL1BsYWNlcyBpbWFnZSdzIHByb3BlcnR5IGxlZnQgdG8gdGhlIGNlbnRlciBvZiBpdCdzIGNvbnRhaW5lciAoY2VudGVyIG9mIHBhZ2UpXG4gICAgICAgIGNlbnRlcmVkTGVmdDogZWxlbUxlZnRcbiAgICB9XG59O1xuZnVuY3Rpb24gYWRqdXN0QnV0dG9uKCl7XG4gICAgXygnbGluZScpWzBdLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMzUnKVxuICAgIF8oJ2xpbmUnKVswXS5zZXRBdHRyaWJ1dGUoJ3gnLCAnMTAuNScpXG4gICAgXygnbGluZScpWzBdLnNldEF0dHJpYnV0ZSgneScsICcyNScpXG4gICAgXygnbGluZScpWzFdLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMzUnKVxuICAgIF8oJ2xpbmUnKVsxXS5zZXRBdHRyaWJ1dGUoJ3gnLCAnMTAuNScpXG4gICAgXygnbGluZScpWzFdLnNldEF0dHJpYnV0ZSgneScsICcyNScpXG4gICAgXygneC1jaXJjbGUnKS5zZXRBdHRyaWJ1dGUoJ3InLCAnMjInKVxufVxuXG4vL0RpZmZlcmVudCBzY3JlZW4gc2l6aW5nICwgZWxlbWVudHMgYWRqdXN0IHRvIGl0XG5mdW5jdGlvbiBhZGp1c3RFbGVtZW50cygpe1xuICAgIHZhciBwYXRoRDc2OCA9IFwiTTU2NS4xLDB2OTAwSDBjMCwwLDAtNzUuMywwLTE5Mi40YzAtMjExLjcsMC0zMDMuNywwLTUzMy4xQzAsNTAuNSwwLDAsMCwwSDU2NS4xelwiO1xuICAgIHZhciBwYXRoRDQwMCA9IFwiTTM5MCw4MDBIMGMwLDAsMC04Ny4zLDAtMTYxLjNTMCw4NCwwLDQ3LjNTMCwwLDAsMGgzOTBWODAwelwiO1xuICAgIHZhciBzbWFsbFNwbGluZXMgPSBcIi40MiAwIDEgMTsuNDIgMCAxIDE7LjQyIDAgMSAxOy40MiAwIDEgMTtcIlxuICAgIHZhciBzbWFsbEtleVRpbWVzID0gXCIwOyAwLjIwOyAwLjQ1OyAxXCJcbiAgICB2YXIgc3ZnID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc3ZnLXBhZ2UnKVswXVxuICAgIFxuICAgIC8vU2V0cyBzaXppbmcgZm9yIG9wZW5pbmcgY2xvc2luZyBzdmctcGFnZSB3YXZlXG4gICAgaWYod0ggPCA4NDAgJiYgd1cpe1xuICAgICAgICB2YXIgc3ZnV2lkdGggPSB3VyA8IDUwMCA/IHdXIC0gMjAgOiB3VyAtIDUwO1xuICAgICAgICB2YXIgc3ZnSGVpZ2h0ID0gd0ggPCA2ODAgPyB3SCAtIDE1IDogd0ggLSA1MDtcbiAgICB9ZWxzZXtcbiAgICAgICAgdmFyIHN2Z1dpZHRoID0gd1cgPCA1MDAgPyB3VyAtIDIwIDogd1cgLSA1MDtcbiAgICAgICAgdmFyIHN2Z0hlaWdodCA9IDg0MFxuICAgIH1cblxuICAgIGlmKHdXIDw9IDYxNSl7XG4gICAgICAgIGFkanVzdEJ1dHRvbigpXG4gICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGF0aCcpLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGhENzY4KVxuICAgICAgICBfKCdwYXRoJykuc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCBhbmltYXRlNzY4KVxuICAgICAgICBfKCdwYXRoJykuc2V0QXR0cmlidXRlKCdrZXlUaW1lcycsIHNtYWxsS2V5VGltZXMpXG4gICAgICAgIF8oJ3BhdGgnKS5zZXRBdHRyaWJ1dGUoJ2tleVNwbGluZXMnLCBzbWFsbFNwbGluZXMpXG4gICAgfVxuXG4gICAgaWYod1cgPD0gNDAwKXtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3BhdGgnKS5zZXRBdHRyaWJ1dGUoJ2QnLCBwYXRoRDQwMClcbiAgICAgICAgXygncGF0aCcpLnNldEF0dHJpYnV0ZSgndmFsdWVzJywgYW5pbWF0ZTQwMClcbiAgICB9XG5cbiAgICBpZih3VyA+PSA5NzAgJiYgd0gpe1xuXG4gICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgc3ZnSGVpZ2h0KVxuICAgICAgICAgICAgXG4gICAgfWVsc2Uge1xuICAgICAgICBpZih3SCA+IDg0MCl7XG4gICAgICAgICAgICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBcIjAgMCBcIisgXCIgXCIrc3ZnV2lkdGggKyBcIiBcIiArIHN2Z0hlaWdodCk7IFxuICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHN2Z1dpZHRoKVxuICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBzdmdIZWlnaHQpXG5cbiAgICAgICAgfVxuICAgICAgICBpZih3SCA8IDg0MCl7IFxuICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgXCIwIDAgXCIrIFwiIFwiK3N2Z1dpZHRoICsgXCIgXCIgKyBzdmdIZWlnaHQpOyBcbiAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBzdmdXaWR0aClcbiAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgc3ZnSGVpZ2h0KVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYod1cgJiYgd0gpe1xuICAgICAgIFxuICAgICAgICAvL0FkZCB0byBlbGVtZW50IHdoZW4gbW9yZSBjYW52YXNlcyBhcmUgYWRkZWQgdG8gSFRNTFxuICAgICAgICB2YXIgZWxlbWVudEcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdnLnBob3RvLCBnLmRldmVsb3BlciwgZy5kZXNpZ24sIGcuYW5pbWF0aW9ucywgZy50ZWNobm9sb2dpZXMnKVxuXG4gICAgICAgIGVsZW1lbnRHLmZvckVhY2goZnVuY3Rpb24oZWwsIGkpe1xuICAgICAgICAgICAgdmFyIGdyb3VwTmFtZSA9IGVsLmNsYXNzTGlzdFswXTtcbiAgICAgIFxuICAgICAgICAgICAgaWYoZ3JvdXBOYW1lID09PSAncGhvdG8nKXtcbiBcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzLWFyZWEnKS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgxNTcsIDApJyk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWwuY2hpbGRyZW4sZnVuY3Rpb24oZWxlbSwgaSl7XG4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vQ2FtZXJhIFNWR1xuICAgICAgICAgICAgICAgICAgICBpZihpID09PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0hlaWdodCA9IG5ld1NpemUoJ3dpZHRoJywgNzAwLCBlbGVtKS5oZWlnaHRcbiAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCA3MDApXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgbmV3SGVpZ2h0KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gZ2V0UG9zKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0QXR0cmlidXRlWSA9IHBvcy5tYWluU3ZnLmhlaWdodCAtIG5ld0hlaWdodCAtIDVcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd4JywgcG9zLmNlbnRlcmVkTGVmdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd5Jywgc2V0QXR0cmlidXRlWSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYod1cgPD0gNTAwIHx8IHdIIDw9IDgwMCl7XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9Gb3JlaWduT2JqZWN0IGhvbGRzIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICBpZihpID09PSAyKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYod1cgPCA5NzApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXNBcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcy1hcmVhJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IGdldFBvcyggY2FudmFzQXJlYSApXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih3SCA8IDY0MCAmJiB3VyA8IDgwMCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCAyNDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmlyZWZveFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNGaXJlZm94ID8gZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCBzdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSAtIHBvcy5oZWlnaHQgLSAxNikgOiAoc3ZnLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSAvIDIpIC0gMzk3LjYgLyAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgneScsIHN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIC0gMzk3LjYgLSAxNilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW0uc2V0QXR0cmlidXRlKCd5JywgMjUwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMzYwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAzNjApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzRmlyZWZveCA/IGVsZW0uc2V0QXR0cmlidXRlKCd4JywgcG9zLmxlZnQgLTYpIDogZWxlbS5zZXRBdHRyaWJ1dGUoJ3gnLCAoc3ZnLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSAvIDIpIC0gMzk3LjYgLyAyICsgMjAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW0uc2V0QXR0cmlidXRlKCd5Jywgc3ZnLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgLSBwb3MuaGVpZ2h0IC0gMTYpXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvc0hlaWdodCA9IGdldFBvcyggZWxlbSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gcGFyc2VJbnQoIGVsZW0uZ2V0QXR0cmlidXRlKCd3aWR0aCcpIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbUxlZnQgPSAocG9zSGVpZ2h0Lm1haW5Tdmcud2lkdGggLSB3aWR0aCkgLSAxNTtcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgneScsIDYwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd4JywgZWxlbUxlZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdXIDw9IDUwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0aGlzUG9zID0gZ2V0UG9zKCBlbGVtIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgneCcsIHRoaXNQb3MuY2VudGVyZWRMZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdIIDwgNjIwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCAyMDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL0l0ZW1zXG4gICAgICAgICAgICAgICAgICAgIGlmKGkgPT09IDEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IGdldFBvcyggZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcy1hcmVhJykgKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jaGlsZE5vZGVzWzFdLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMjM1KSAgXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKCd4JywgMjApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih3VyA8IDk3MCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jaGlsZE5vZGVzWzFdLnNldEF0dHJpYnV0ZSgneScsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKCd5JywgMTAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYod2luZG93LmlubmVyV2lkdGggPD0gNTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jaGlsZE5vZGVzWzFdLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAzMzUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jaGlsZE5vZGVzWzFdLnNldEF0dHJpYnV0ZSgneCcsIDEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGlzUG9zID0gZ2V0UG9zKCBlbGVtLmNoaWxkTm9kZXNbMV0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZihncm91cE5hbWUgPT09ICdkZXZlbG9wZXInKXtcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsLmNoaWxkcmVuLCBmdW5jdGlvbihlbGVtLCBpKXtcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9mb3JlaWduT2JqZWN0IGhvbGRzIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICBpZihpID09PSAxKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdXIDwgOTcwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnd2lkdGgnLDQwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDM3NSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gZ2V0UG9zKGVsLmNoaWxkcmVuWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCAyMDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih3aW5kb3cuaW5uZXJXaWR0aCA8PSA4NTApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdIIDwgNjkwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCAyNSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd4JywgNSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd4JywgNTApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd5JywgNzUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYod2luZG93LmlubmVyV2lkdGggPCA1MDUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdIIDwgNjkwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCA1MCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd4JywgMCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywzNjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAzNzUpO1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGlzUG9zID0gZ2V0UG9zKGVsZW0uY2hpbGROb2Rlc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgneScsIDUwIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgneCcsIDUgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2l0ZW1zXG4gICAgICAgICAgICAgICAgICAgIGlmKGkgPT09IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYod2luZG93LmlubmVyV2lkdGggPCA1MDUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoJ3gnLCAxMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKCd5JywgNDI0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMzcwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdXID4gNTA1ICYmIHdXIDwgODUwICl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYod0ggPCA2OTApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKCd5JywgNDI1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKCd3aWR0aCcsIDM3MClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNlIGVsZW0uY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoJ3knLCA0NjApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGdyb3VwTmFtZSA9PT0gJ2Rlc2lnbicpe1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IGVsLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdXG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhc0FyZWEgPSBlbC5jaGlsZHJlblsxXVxuICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHdIICYmIHdXID4gOTcwKXtcblxuICAgICAgICAgICAgICAgICAgICBpZiggY2FudmFzQXJlYSApe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYod1cgPiAxMjAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNBcmVhLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCA1ODApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDU4MClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc0FyZWEuc2V0QXR0cmlidXRlKCd5JywgODApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoIGl0ZW1zICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5zZXRBdHRyaWJ1dGUoJ3knLCAyMDApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKCB3VyA+IDc1MCAmJiB3VyA8IDk3MCl7XG4gICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKCBjYW52YXNBcmVhICl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0ZvciBTYWZhcmkgb3ZlcmZsb3cgbm90IHdvcmtpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHdXIDwgODEwID8gY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ3gnLCAyMTApIDogY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ3gnLCAyNTUpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNBcmVhLnNldEF0dHJpYnV0ZSgneScsIDE2MClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdIIDwgNzAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9Gb3IgU2FmYXJpIG92ZXJmbG93IG5vdCB3b3JraW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDQ1MClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiggaXRlbXMgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgneScsIDApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgneScsIDApXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgneCcsIDEwKVxuICAgICAgICAgICAgICAgICAgICB3SCA8IDcwMCA/IGl0ZW1zLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMjUwKSAgOiAgaXRlbXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAyNjApXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAzNDApXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGl0ZW1zLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JylcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ3knLCBoZWlnaHQpXG5cbiAgICAgICAgICAgICAgICAgICAgd1cgPCA2MDAgPyBjYW52YXNBcmVhLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCA0MDApIDogY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgNTAwKVxuICAgICAgICAgICAgICAgICAgICB3VyA8IDYwMCA/IGNhbnZhc0FyZWEuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCA0MDApIDogY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDUwMClcblxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzUG9zID0gZ2V0UG9zKGNhbnZhc0FyZWEpXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0FyZWEuc2V0QXR0cmlidXRlKCd4JywgY2FudmFzUG9zLmNlbnRlcmVkTGVmdClcbiAgICAgICAgICAgICAgICAgICAgLy9Gb3Igc2FmYXJpLCBzbyBwaG90byBkb2Vzbid0IHNob3cgdGhlIG92ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0FyZWEuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSAtIGl0ZW1zLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpXG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGdyb3VwTmFtZSA9PT0gJ2FuaW1hdGlvbnMnKXtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBlbC5jaGlsZHJlblswXS5jaGlsZHJlblswXVxuICAgICAgICAgICAgICAgIHZhciBjYW52YXNBcmVhID0gZWwuY2hpbGRyZW5bMV1cbiAgICAgICAgICAgICAgICB2YXIgc3ZnUGFnZUhlaWdodCA9IHN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpXG5cbiAgICAgICAgICAgICAgICBpZih3SCAmJiB3VyA+IDk3MCl7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0FyZWEuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzdmdQYWdlSGVpZ2h0KVxuICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZih3VyA8IDc2OCl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBib3R0b20gPSAoIHN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIC0gMzEwICkgLyAyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgneCcsIDE1KVxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5zZXRBdHRyaWJ1dGUoJ3knLCBib3R0b20pXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMzIwKVxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMzcwKVxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNBcmVhLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc3ZnUGFnZUhlaWdodClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihncm91cE5hbWUgPT09ICd0ZWNobm9sb2dpZXMnKXtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBlbC5jaGlsZHJlblswXS5jaGlsZHJlblswXVxuICAgICAgICAgICAgICAgIHZhciBjYW52YXNBcmVhID0gZWwuY2hpbGRyZW5bMV1cblxuICAgICAgICAgICAgICAgIGlmKHdXIDwgNjUwICYmIHdIIDwgNjU1KXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbSA9ICggc3ZnLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgLSAzNzAgKSAvIDJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMuc2V0QXR0cmlidXRlKCd5JywgYm90dG9tKVxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5zZXRBdHRyaWJ1dGUoJ3gnLCA1KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9ICBcbn07XG5cblxuXG5cblxuXG5pZih3VyA8IDk3MCB8fCB3SCA8IDgwMCl7XG4gICAgYWRqdXN0RWxlbWVudHMoKTtcbn1lbHNlIHtcbiAgICAvL0FkZHMgbWFyZ2luIGJldHdlZW4gZnVsbCBoZWlnaHQgdGhyZXNoaG9sZCBmb3Igc3ZnLXBhZ2VcbiAgICBpZih3SCA8IDg0MCl7XG4gICAgICAgXygnc3ZnLXBhZ2UnKS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHdIIC0gNDApIFxuICAgIH1cbiAgICBpZih3VyA8IDEwMDApe1xuICAgICAgICBfKCdzdmctcGFnZScpLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB3VyAtIDQwKSBcbiAgICB9XG4gICB2YXIgZGVzaWduQ2FudmFzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmRlc2lnbiAuaXRlbS1jYW52YXMnKVxuICAgZGVzaWduQ2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCA1ODApXG4gICBkZXNpZ25DYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCA1ODApXG59XG5cbi8vTW92ZXMgY2xvc2UgYnV0dG9uIHRvIHJpZ2h0IG9mIHN2Zy1wYWdlXG5mdW5jdGlvbiBwbGFjZUNsb3NlQnV0dG9uKCl7XG4gICAgXG4gICAgdmFyIGJ0blBvcyA9IGdldFBvcyggXygnY2xvc2UtYnRuJykgKVxuICAgIF8oJ2Nsb3NlLWJ0bicpLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKCcrIChidG5Qb3MubWFpblN2Zy53aWR0aCAtIDU2ICkrJ3B4KSdcbn1cbnBsYWNlQ2xvc2VCdXR0b24oKTtcblxuXG5cbmZ1bmN0aW9uIGhvdmVyTWFwKCl7XG4gICAgdmFyIGJ0bldyYXAgPSBfKCdidXR0b24td3JhcCcpXG4gICAgdmFyIGRpc3Q7XG4gICAgdmFyIGxhc3REaXN0O1xuICAgIHZhciBjdXJyZW50UGF0aDsgLy9QYXRoIHRvIGJlIHJlbW92ZWQgd2hlbiBtb3VzZW91dFxuICBcbiAgICB2YXIgbW91c2VPdXQgPSBmdW5jdGlvbihkaXN0KXtcbiAgICAgICAgLy8gZGlzdCBmcm9tIG9wZW5pbmcgcG9wdXBzIHRvIHJlbW92ZSBwb2ludGVyXG4gICAgICAgIHZhciBwb2ludGVyRGlzdCA9IHR5cGVvZiBkaXN0ID09PSAnbnVtYmVyJyA/IGRpc3QgOiBsYXN0RGlzdFxuICBcbiAgICAgICAgXygnb3ZhbC1wb2ludGVyJykuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgtODBweCwgMHB4ICknXG4gICAgICAgIFxuICAgICAgICBpZihpc0ZpcmVmb3gpe1xuICAgICAgICAgIFxuICAgICAgICAgICAgXygnc2hvdy1pY29uJykuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgtMjRweCwnICsgcG9pbnRlckRpc3QgKyAncHggKScgXG4gICAgICAgICBcbiAgICAgICAgfWVsc2UgaWYoaXNTYWZhcmkpe1xuXG4gICAgICAgICAgICAgXygnc2hvdy1pY29uJykuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgtMjRweCwnICsgcG9pbnRlckRpc3QgKyAncHggKSdcblxuICAgICAgICB9ZWxzZXtcblxuICAgICAgICAgICAgIF8oJ3Nob3ctaWNvbicpLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTIycHgsJyArIHBvaW50ZXJEaXN0ICsgJ3B4ICknXG5cbiAgICAgICAgfSAgXG4gICAgfTtcblxuICAgIGlmKHdXID4gNzY4KSBidG5XcmFwLm9ubW91c2VvdmVyID0gaGFuZGxlcjtcbiAgICAgICAgXG4gICAgZnVuY3Rpb24gaGFuZGxlcihlKXtcbiAgICAgICAgZGlzdCA9IGdldERpc3RhbmNlKGUudGFyZ2V0LmNsYXNzTmFtZSwgZS50YXJnZXQuaWQpIFxuXG4gICAgICAgIGZ1bmN0aW9uIGdldERpc3RhbmNlKGVsLGlkKSB7XG4gICAgICAgICAgICB2YXIgdG90YWxEaXN0ID0gZnVuY3Rpb24obil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG4gKiAzN1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5vZGVsaXN0ID0gXyhlbClcbiAgICAgICAgICAgIHZhciBlbEFycmF5ID0gW10uc2xpY2UuY2FsbChub2RlbGlzdClcbiAgICAgICAgIFxuICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgZWxBcnJheS5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgaWYoZWxBcnJheVtpXS5pZCA9PSBpZCkgcmV0dXJuIHRvdGFsRGlzdChpKTtcbiAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgXG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UGF0aEVsZW1lbnQoZWwsIG1hcF9wYXRocyl7XG4gICAgICAgICAgICB2YXIgbmV3UGF0aEFycmF5ID0gW11cbiAgICAgICAgICAgIHZhciBwYXRoQXJyYXkgPSBbXS5zbGljZS5jYWxsKCBtYXBfcGF0aHMgKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL1B1dHMgZWxlbWVudHMgaW4gY29ycmVjdCBvcmRlclxuICAgICAgICAgICAgZm9yKHZhciBpID0gcGF0aEFycmF5Lmxlbmd0aCAtMTsgaSA+PSAwOyBpLS0pe1xuICAgICAgICAgICAgICAgIG5ld1BhdGhBcnJheS5wdXNoKHBhdGhBcnJheVtpXSlcbiAgICAgICAgICAgIH1cbiBcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbClcbiAgICAgICAgICAgIHZhciB0YXJnZXRBcnJheSA9IFtdLnNsaWNlLmNhbGwoIF8odGFyZ2V0LmNsYXNzTmFtZSkgKSAgXG5cbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0YXJnZXRBcnJheS5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICBpZih0YXJnZXRBcnJheVtpXSA9PT0gdGFyZ2V0KSByZXR1cm4gbmV3UGF0aEFycmF5W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBhbmltYXRlR29vZXkgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYoICFfKCdzaG93LWljb24nKS5jbGFzc0xpc3QuY29udGFpbnMoJ2ljb24tdHJhbnNpdGlvbicpICl7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gdHJhbnNmb3JtcyBvbmx5IHVwIGFuZCBkb3duIGJlZm9yZSBvdXQuXG4gICAgICAgICAgICAgICAgXygnc2hvdy1pY29uJykuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgtMjJweCwnICsgZGlzdCArICdweCApJ1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIF8oJ3Nob3ctaWNvbicpLmNsYXNzTGlzdC5hZGQoJ2ljb24tdHJhbnNpdGlvbicpXG4gICAgICAgICAgICAgICAgICAgIF8oJ3Nob3ctaWNvbicpLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTE1cHgsJyArIGRpc3QgKyAncHggKSdcbiAgICAgICAgICAgICAgICAgICAgXygnb3ZhbC1wb2ludGVyJykuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwcHgsIDBweCApJ1xuICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9LDEwMClcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIF8oJ3Nob3ctaWNvbicpLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTE1cHgsJyArIGRpc3QgKyAncHggKSdcbiAgICAgICAgICAgICAgICBfKCdvdmFsLXBvaW50ZXInKS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDBweCwgMHB4ICknXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYW5pbWF0ZVBhdGhMaW5lcyA9IGZ1bmN0aW9uKHBhdGgsIG1hcF9wYXRocyl7XG4gICAgICAgICAgICB2YXIgY2xhc3NJZCA9IHBhdGguaWQucmVwbGFjZSgvLXNtJC9pZywgXCJcIik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwX3BhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgIC8vUmVtb3ZlcyBhbGwgY2xhc3NlcyBiZWZvcmUgdGFyZ2V0IGVsZW1lbnQgY2xhc3MgZ2V0cyBhZGRlZFxuICAgICAgICAgICAgICAgIGlmKG1hcF9wYXRoc1tpXS5jbGFzc0xpc3QubGVuZ3RoID09PSAyKXtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gbWFwX3BhdGhzW2ldLmNsYXNzTGlzdFsxXVxuICAgICAgICAgICAgICAgICAgICBtYXBfcGF0aHNbaV0uY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aC5jbGFzc0xpc3QuYWRkKGNsYXNzSWQpXG4gICAgICAgICAgICByZXR1cm4gY2xhc3NJZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW1vdmVDYXJkc0NsYXNzID0gZnVuY3Rpb24odGFyZ2V0KXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgY2FyZCA9IF8oJ2NhcmQtaWNvbicpXG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gY2FyZC5sZW5ndGhcblxuICAgICAgICAgICAgd2hpbGUobGVuZ3RoLS0pe1xuICAgICAgICAgICAgICAgIGxldCBzdHlsZVRyYW5zZm9ybSA9ICtjYXJkW2xlbmd0aF0uc3R5bGUudHJhbnNmb3JtLnJlcGxhY2UoLyhbXi1cXGRdKS9pZywgJycpXG4gICAgICAgICAgICAgICAgaWYoc3R5bGVUcmFuc2Zvcm0gIT09IDApIGNhcmRbbGVuZ3RoXS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWSgwcHgpJ1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFuaW1hdGVDYXJkc1VwID0gZnVuY3Rpb24ocGF0aCl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IGNhcmQgPSBfKCdjYXJkLWljb24nKVxuICAgICAgICAgICAgbGV0IHJlZ0V4ID0gLy0uKyQvaWdcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSBwYXRoLmlkLnJlcGxhY2UocmVnRXgsICcnKVxuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IGNhcmQubGVuZ3RoXG5cbiAgICAgICAgICAgIC8vSWYgdGFyZ2V0IGFsc28gaGFzIDIgY2xhc3NMaXN0LCByZW1vdmUgdGhhdCBjbGFzcyBhbmQgYWRkIHAwb3B1cGNhcmRcbiAgICAgICAgICAgIHdoaWxlKGxlbmd0aC0tKXtcbiAgICAgICAgICAgICAgICBsZXQgY2FyZFBhcmVudCA9IGNhcmRbbGVuZ3RoXS5wYXJlbnROb2RlXG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlVHJhbnNmb3JtID0gK2NhcmRbbGVuZ3RoXS5zdHlsZS50cmFuc2Zvcm0ucmVwbGFjZSgvKFteLVxcZF0pL2lnLCAnJylcblxuICAgICAgICAgICAgICAgIGlmKHRhcmdldCA9PT0gY2FyZFBhcmVudC5pZC5yZXBsYWNlKHJlZ0V4LCAnJykgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhcmRbbGVuZ3RoXS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWSgtMTQwcHgpJ1xuICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXJkW2xlbmd0aF0uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVkoLTE0MHB4KSdcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZihzdHlsZVRyYW5zZm9ybSAhPT0gMCl7XG4gICAgICAgICAgICAgICAgICAgIGNhcmRbbGVuZ3RoXS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWSgwcHgpJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIEFuaW1hdGVDaXJjbGVzKHBhdGgsIG1hcF9wYXRocyl7XG4gICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBjaXJjbGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI3B1bHNlLWNpcmNsZXMgY2lyY2xlJylcbiAgICAgICAgICAgIHZhciBwYXRocyA9IFtdXG4gICAgICAgICAgICAvL1JlbW92ZXMgYWxsIGNsYXNzZXMgYmVmb3JlIHRhcmdldCBlbGVtZW50cyBjbGFzc2VzIGdldHMgYWRkZWRcbiAgICAgICAgICAgIGZvcihsZXQgY2lyIG9mIGNpcmNsZXMpe1xuICAgICAgICAgICAgICAgIGlmKGNpci5jbGFzc0xpc3QubGVuZ3RoID4gMSl7XG4gICAgICAgICAgICAgICAgICAgIGNpci5jbGFzc0xpc3QucmVtb3ZlKGNpci5jbGFzc0xpc3RbMV0pXG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vU3RvcHMgYmVmb3JlIGVycm9yIHdoZW4gbm90IHBhc3NpbmcgYXJndW1lbnRzIGZyb20gY2xpY2sgaGFuZGxlclxuICAgICAgICAgICAgaWYoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICAgICAgLy9QYWlycyBjaXJjbGVzIGFuZCByZXR1cm5zIHRoZSBwYWlycyBzbyBjbGFzc2VzIGNhbiBiZSBhZGRlZFxuICAgICAgICAgICAgdmFyIHBhaXJDaXJjbGVzID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB2YXIgY2lyID0gW11cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNpcmNsZXMubGVuZ3RoOyBqKz0yKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjaXIucHVzaCggW2NpcmNsZXNbal0sIGNpcmNsZXNbaisxXV0gKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2lyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBfcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBwYXRocy51bnNoaWZ0KCBtYXBfcGF0aHNbaV0uaWQpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHBhdGhzLmluZGV4T2YocGF0aC5pZClcbiAgICAgICAgICAgIHZhciBjaXJQYWlycyA9IHBhaXJDaXJjbGVzKClbaW5kZXhdXG5cbiAgICAgICAgICAgIGNpclBhaXJzWzBdLmNsYXNzTGlzdC5hZGQoJ21pZGRsZS1wdWxzZScpXG4gICAgICAgICAgICBjaXJQYWlyc1sxXS5jbGFzc0xpc3QuYWRkKCdyaW5nLXB1bHNlJykgXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIHJlbW92ZUNpcmNsZXMgPSBmdW5jdGlvbihzdHJpbmcpe1xuICAgICAgICAgICAgdmFyIGFjdGl2ZUNpcmNsZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubWlkZGxlLXB1bHNlLCAucmluZy1wdWxzZScpXG5cbiAgICAgICAgICAgIGZvcihsZXQgY2lyIG9mIGFjdGl2ZUNpcmNsZXMpe1xuICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNpci5hZGRFdmVudExpc3RlbmVyKCdhbmltYXRpb25lbmQnLCAoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBlLnRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKGUudGFyZ2V0LmNsYXNzTGlzdFsxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiByZW1vdmVBbGwoc3RyaW5nKXtcbiAgICAgICAgICAgIHJlbW92ZUNpcmNsZXMoc3RyaW5nKVxuICAgICAgICAgICAgbW91c2VPdXQoZGlzdClcbiAgICAgICAgICAgIHJlbW92ZUNhcmRzQ2xhc3MoKVxuICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgIC8vUGF0aCB0byBiZSByZW1vdmVkIHdoZW4gbW91c2VvdXRcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjdXJyZW50UGF0aCkuY2xhc3NMaXN0LnJlbW92ZShjdXJyZW50UGF0aClcbiAgICAgICAgICAgIH1jYXRjaChlcnIpe1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlTWFwKGUpe1xuICAgICAgICAgICBsZXQgdGFyZ2V0ID0gZS50YXJnZXQuY2xhc3NMaXN0LnZhbHVlXG4gICAgIFxuICAgICAgICAgICAvL0lmIGNsaWNrIGNvbWVzIGZyb20gb3BlbmluZyBzdmcgbW9kYWxzXG4gICAgICAgICAgICBpZih0YXJnZXQgPT09ICdjYXJkLWNvbG9yLXN0MzknIHx8IHdXID4gNzY4ICYmIGUudHlwZSA9PT0gJ2NsaWNrJyl7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gIHJlbW92ZUFsbChwYXRoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtb3VzZSBvdmVyXG4gICAgICAgICAgICBpZihlLnRhcmdldC5pZCl7XG4gICAgICAgICAgICAgICAgLy9TdGFydCB0aGUgcGF0aCBhbmltYXRlZCBsaW5lc1xuICAgICAgICAgICAgICAgIHZhciBtYXBfcGF0aHMgPSB3VyA+IDc2OCA/IF8oJ21hcC1wYXRocycpIDogXygnbWFwLXBhdGhzLXNtJylcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IGdldFBhdGhFbGVtZW50KGUudGFyZ2V0LmlkLCBtYXBfcGF0aHMpXG5cbiAgICAgICAgICAgICAgICAvL1VzZWQgdG8gdXBkYXRlIHRyYW5zbGF0ZSBmb3IgYnV0dG9uIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgbGFzdERpc3QgPSBkaXN0XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBhbmltYXRlR29vZXkoKVxuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXRoID0gYW5pbWF0ZVBhdGhMaW5lcyhwYXRoLCBtYXBfcGF0aHMpXG4gICAgICAgICAgICAgICAgQW5pbWF0ZUNpcmNsZXMocGF0aCwgbWFwX3BhdGhzKVxuICAgICAgICAgICAgICAgIGFuaW1hdGVDYXJkc1VwKHBhdGgpXG4gICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL09ubHkgcnVucyBhZnRlciBtb3VzZW92ZXIgZWxlbWVudHMgcnVuIGZpcnN0LCB0aGVuIGluaXRpYXRlZC4gXG4gICAgICAgICAgICAgICAgXygnaW50ZXJhY3RpdmUtY29udGFpbmVyJykub25tb3VzZW92ZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKGUudGFyZ2V0LmNsYXNzTmFtZSAhPT0gJ29wZW4tY2FudmFzLXBhZ2UnICYmIHdXID4gNzY4KXtcbiBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUFsbCgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgICBpZiAoZS50eXBlID09ICdtb3VzZW92ZXInICYmIHdXID4gNzY4KSB7XG4gICAgICAgICAgICBoYW5kbGVNYXAoZSlcbiAgICAgICAgfWVsc2UgaWYoZS50eXBlID09PSAnY2xpY2snKXtcbiAgICBcbiAgICAgICAgICAgIGhhbmRsZU1hcChlKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZGlzdF1cbiAgICB9XG4gICAgcmV0dXJuIFttb3VzZU91dCwgaGFuZGxlcl0gLy8gVG8gYmUgYWJsZSB0byB1c2UgbW91c2VPdXQgZnVuY3Rpb24gYW5kIGhhbmRsZXIgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGRpc3QgdG8gdXNlIGZvciBtb3VzZU91dCBGdW5jXG59O1xuXG52YXIgdG9nZ2xlU3RhcnMgPSB7XG4gICAgdG9nZ2xlOiBmYWxzZVxufVxuXG52YXIgcm9ib3RTZWN0aW9uID0gZnVuY3Rpb24oZSl7XG5cbiAgICBjb25zdCBzdGFycyA9IFtdXG4gICAgdmFyIGFuaW1hdGVTdGFycyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBcbiAgICAgICAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFyLWNhbnZhcycpO1xuICAgICAgICBsZXQgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIGxldCB3aWR0aCA9IGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICBsZXQgaGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcblxuICAgICAgICBsZXQgcmFuZG9tV2lkdGggPSAoKSA9PiB7XG4gICAgICAgICAgICAvL21heCBhbmQgbWluXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqICh3aWR0aC8yIC0gd2lkdGgvOSkgKyB3aWR0aC85XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgTmlnaHRTdGFycyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCByYW5kb21TdGFydCA9IHJhbmRvbVdpZHRoKClcblxuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbiA9IDIwMDAgLy91c2VkIHRvIGRlbGF5IHN0YXJzXG4gICAgICAgICAgICB0aGlzLnJhZGl1cyA9IDEzICsgTWF0aC5yYW5kb20oKSAqIDUgLy9zaXplIG9mIHN0YXJzXG5cbiAgICAgICAgICAgIHRoaXMuaSA9IDAgLy94IGFuZCB5IHNwZWVkXG4gICAgICAgICAgICB0aGlzLmsgPSAwIC8vb3BhY2l0eSBzcGVlZFxuXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0ge1xuICAgICAgICAgICAgICAgIHk6IE1hdGgucmFuZG9tKCkgKiBoZWlnaHRcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5GbGlja2VyID0gKGluY3JlbnRtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChNYXRoLmNvcyhpbmNyZW50bWVudCAtIE1hdGguUEkvMTgwKSAqIC4yICkgXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMucmFkU2l6ZSA9IChpbmNyZW50bWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoTWF0aC5zaW4oaW5jcmVudG1lbnQgLSBNYXRoLlBJLzE4MCkgKiA3KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnggPSAoaW5jcmVudG1lbnQsIHN0YXJTaXplKSA9PiB7XG4gICAgICAgICAgICAgICAgLy9mdWxsIHNjcmVlbiBhbmltYXRlIGNoYW5nZSB0aGlzLnJhbmRvbVdpZHRoIGJhY2sgdG8gd2lkdGggLyAyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGguY29zKGluY3JlbnRtZW50IC0gTWF0aC5QSS8xODApICogKHJhbmRvbVN0YXJ0ICsgc3RhclNpemUgKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnkgPSAoaW5jcmVudG1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zaW4oLWluY3JlbnRtZW50IC0gTWF0aC5QSS8xODApICogMTYwXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZHJhdyA9IChjdHgpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgcyA9IHRoaXM7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbGV0IG9wYWNTcGVlZCA9IHMuayArPSAuM1xuICAgICAgICAgICAgICAgIGxldCBzcGVlZCA9IHMuaSArPSBzLnJhbmRvbVNwZWVkXG5cbiAgICAgICAgICAgICAgICBsZXQgcmFkU2l6ZSA9IHMucmFkU2l6ZShzcGVlZClcbiAgICAgICAgICAgICAgICBsZXQgZmxpY2tlciA9IHMuRmxpY2tlcihvcGFjU3BlZWQpXG5cbiAgICAgICAgICAgICAgICBsZXQgeSA9IHMueShzcGVlZClcbiAgICAgICAgICAgICAgICBsZXQgeCA9IHMueChzcGVlZCwgcy5yYWRpdXMpXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgvMiwgcy5zdGFydC55KVxuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4ICx5ICwuNCwgeCAseSAsMTQpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAnTGlnaHRTa3lCbHVlJyk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKC45LCAnRG9kZ2VyQmx1ZScpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnUm95YWxCbHVlJyk7XG5cbiAgICAgICAgICAgICAgICBjdHguYmVnaW5QYXRoKClcbiAgICAgICAgICAgICAgICBjdHguYXJjKHgsICB5LCAocy5yYWRpdXMgLSByYWRTaXplKSAtIGZsaWNrZXIsIDAsIE1hdGguUEkqMilcbiAgICAgICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnRcbiAgICAgICAgICAgICAgICBjdHguZmlsbCgpXG4gICAgICAgIFxuICAgICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLXdpZHRoLzIsIC0gcy5zdGFydC55KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlU3RhcnMoc3RhckNvdW50LHVwZGF0ZSl7XG4gICAgICAgICAgICBsZXQgZGVsYXkgPSAwXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhckNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWxheSArPSBNYXRoLnJhbmRvbSgpICogd2lkdGhcblxuICAgICAgICAgICAgICAgIGxldCBuaWdodFN0YXJzID0gbmV3IE5pZ2h0U3RhcnMoKVxuICAgICAgICAgICAgICAgIG5pZ2h0U3RhcnMucmFuZG9tU3BlZWQgPSAuMDAxICsgTWF0aC5yYW5kb20oKSAqIC4wMDZcbiAgICAgICAgICAgICAgICBuaWdodFN0YXJzLnN0YXJ0VGltZSA9IERhdGUubm93KClcbiAgICAgICAgICAgICAgICBuaWdodFN0YXJzLmR1cmF0aW9uICs9IGRlbGF5ICAgLy9zZXRzIGEgcmFuZG9tIGRlbGF5IGZvciBzdGFycyB0byBzdGFydFxuICAgICAgICAgICAgICAgIHN0YXJzLnB1c2gobmlnaHRTdGFycylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZSgpe1xuICAgICAgICAgICAgLy9TdG9wcGluZyBzdGFyc1xuICAgICAgICAgICAgaWYodG9nZ2xlU3RhcnMudG9nZ2xlKXtcbiAgICAgICAgICAgICAgICBzdGFycy5sZW5ndGggPSAwXG4gICAgICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGN0eC5jbGVhclJlY3QoMCwgMCwgd2luZG93LmlubmVyV2lkdGgsIHdpbmRvdy5pbm5lckhlaWdodCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCBhbGwgPSBzdGFycy5sZW5ndGhcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBsZXQgcGVyY2VudCA9IE1hdGgubWluKCAoIERhdGUubm93KCkgLSBzdGFyc1tpXS5zdGFydFRpbWUgKSAvIHN0YXJzW2ldLmR1cmF0aW9uLCAxICkgIC8vRGVsYXkgdG8gc3RhcnQgc3RhcnNcbiAgICAgICAgICAgICAgICBsZXQgcGVyY2VudCA9IE1hdGgubWluKCAoIERhdGUubm93KCkgLSBzdGFyc1tpXS5zdGFydFRpbWUgKSwgMSApICAvLyBObyBkZWxheVxuXG4gICAgICAgICAgICAgICAgaWYocGVyY2VudCA9PT0gMSl7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJzW2ldLmRyYXcoY3R4KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh1cGRhdGUpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3JlYXRlU3RhcnMsXG4gICAgICAgICAgICB1cGRhdGVcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG5cbiAgICB2YXIgdXBkYXRlVGV4dCA9IChmdW5jdGlvbigpe1xuIFxuICAgICAgICB2YXIgdG9nZ2xlID0gdHJ1ZVxuICAgICAgICB2YXIgdGV4dEZpZWxkID0gXygndGV4dC1maWVsZCcpXG5cbiAgICAgICAgZnVuY3Rpb24gY2hhbmdlVG9nZ2xlKGJvb2xlYW4pe1xuICAgICAgICAgICAgdG9nZ2xlID0gYm9vbGVhblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2dnbGVGYWxzZTogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICBjaGFuZ2VUb2dnbGUoZmFsc2UpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXBkYXRlSW1nVGV4dDogZnVuY3Rpb24oaW1nKXtcblxuICAgICAgICAgICAgICAgIGNoYW5nZVRvZ2dsZSh0cnVlKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBpbWdUZXh0ID0gaW1nLmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKVxuICAgICAgICAgICAgICAgIHZhciB0ZXh0TGVuZ3RoID0gaW1nVGV4dC5sZW5ndGhcblxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCB0ZXh0TGVuZ3RoOyBpKyspe1xuXG4gICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbihpKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKCF0b2dnbGUpIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dEZpZWxkLnRleHRDb250ZW50ICs9IGltZ1RleHRbaV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9LDEwMCAqIGkpXG4gICAgICAgICAgICAgICAgICAgIH0pKGkpOyAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICBcblxuICAgIGZ1bmN0aW9uIGVsZWN0cmljQm94KCl7XG4gICAgICAgIHZhciByYW5kb21DaXIgPSBbMCwxLDIsMyw0LDVdXG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0UmFuZG9tKG51bSl7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTWF0aC5mbG9vcihudW0pKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBmaW5kTnVtKGl0ZW0pe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgbmV3TnVtID0gcmFuZG9tQ2lyLnNwbGljZShpdGVtLDEpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIF8oJ3JvYm90LXN0MzQnKVtuZXdOdW1dLmNsYXNzTGlzdC5hZGQoJ2JsaW5rJylcbiAgICAgICAgICAgIGlmKHJhbmRvbUNpci5sZW5ndGgpe1xuICAgICAgICAgICAgICAgcmVsYXkocmFuZG9tQ2lyKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlbGF5KGVsKXtcbiAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBnZXRSYW5kb20oZWwubGVuZ3RoLTEpXG4gICAgICAgICAgICAgICAgZmluZE51bShpdGVtKVxuICAgICAgICAgICAgfSw4MClcbiAgICAgICAgfVxuICAgICAgICByZWxheShyYW5kb21DaXIpXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNoZWNrRm9yQ2xhc3Nlcygpe1xuICAgICAgICB2YXIgY2lyY2xlcyA9IF8oJ3JvYm90LXN0MzQnKS5sZW5ndGhcbiAgICAgICBcbiAgICAgICAgLy8gQWRkIGJsaW5raW5nIGxpZ2h0IGNsYXNzZXNcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaXJjbGVzOyBpKyspIHtcbiAgICAgICAgICAgIGlmKCBfKCdyb2JvdC1zdDM0JylbaV0uY2xhc3NMaXN0LmNvbnRhaW5zKCdibGluaycpICl7XG5cbiAgICAgICAgICAgICAgICBfKCdyb2JvdC1zdDM0JylbaV0uY2xhc3NMaXN0LnJlbW92ZSgnYmxpbmsnKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsZWN0cmljQm94KClcbiAgICB9O1xuXG4gICAgLy8gQWRkIGVsZWN0cmljaXR5IGZvciByb2JvdCBib3ggc3RvbWFjaFxuICAgIGZ1bmN0aW9uIGFkZEVsZWN0cmljaXR5KCl7XG4gICAgICAgIHZhciBwYXRoTGVuZ3RoID0gXygnZWxlY3RyaWMtcGF0aCcpLmxlbmd0aFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgXygnZWxlY3RyaWMtcGF0aCcpW2ldLnN0eWxlLnN0cm9rZURhc2hhcnJheSA9IDIwXG4gICAgICAgICAgICBfKCdlbGVjdHJpYy1wYXRoJylbaV0uc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IDI4MFxuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydCA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gZHJhdyh0aW1lc3RhbXApe1xuICAgICAgICAgICAgaWYoIXN0YXJ0KSBzdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICAgICAgdmFyIHJ1bnRpbWUgPSB0aW1lc3RhbXAgLSBzdGFydFxuICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gTWF0aC5taW4ocnVudGltZSAvIDEyMDAsIDEpXG4gICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIF8oJ2VsZWN0cmljLXBhdGgnKVtpXS5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gMjgwICsgKDI4MCAqIHByb2dyZXNzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihwcm9ncmVzcyA8IDEpe1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3KVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgXygnZWxlY3RyaWMtcGF0aCcpW2ldLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3KVxuICAgIH07XG4gICAgXG5cbiAgICAvKiogT3V0dGVyIGZ1bmN0aW9uIHNjb3BlIHZhcmlhYmxlcyAqKi9cbiAgICB2YXIgZGVzaWduSW1hZ2VzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZGVzaWduSW1hZ2VzJyk7XG4gICAgdmFyIGltZ19jb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdpbWFnZS1jb250YWluZXInKVswXTtcblxuICAgIHZhciBhbmltYXRlU2xpZGVyID0ge1xuICAgICAgICB0YXJnZXQ6IG51bGwsXG4gICAgICAgIHBhcnRpYWxEaXN0OiAwLFxuICAgICAgICBqOiAwLFxuICAgICAgICBkaXN0OiAwLFxuICAgICAgICBzdGFydDogMCxcbiAgICAgICAgaW1hZ2VzOiBbXSxcbiAgICAgICAgaW1nU3RhcnQ6IDAsXG4gICAgICAgIG5ld1N0YXJ0OiBmdW5jdGlvbihudW0pe1xuXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoIHRoaXMuaW1hZ2VzW251bV0uc3R5bGUudHJhbnNmb3JtLnJlcGxhY2UoL14oW1xcd10qKVxcKHwocHguKikkL2lnLCAnJykgKVxuXG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRhaW5lcldpZHRoOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KCBpbWdfY29udGFpbmVyLnN0eWxlLndpZHRoLnJlcGxhY2UoL3B4L2lnLCAnJykgKVxuICAgICAgICB9LFxuICAgICAgICBjbG9uZUltYWdlOiBmdW5jdGlvbihpbWcpe1xuICAgICAgICAgICAgY29uc3QgY2xvbmVkSW1nID0gaW1nLmNsb25lTm9kZSh0cnVlKVxuICAgICAgICAgICAgY2xvbmVkSW1nLmNsYXNzTmFtZSA9ICcnXG4gICAgICAgICAgICBjbG9uZWRJbWcucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpXG4gICAgICAgICAgICBpbWdJbmxhcmdlLmNoZWNrRm9yRHVwbGljYXRlcygnZGVzaWduVmlzaWJsZScpXG4gICAgICAgICAgICBpbWdJbmxhcmdlLm1vdmVFbGVtZW50KGNsb25lZEltZywgJ2Rlc2lnblZpc2libGUnKVxuICAgICAgICB9LFxuICAgICAgICBkcmF3OiBmdW5jdGlvbih0aW1lc3RhbXApe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZighdGhpcy5zdGFydCkgdGhpcy5zdGFydCA9IHRpbWVzdGFtcFxuXG4gICAgICAgICAgICB2YXIgcnVudGltZSA9IHRpbWVzdGFtcCAtIHRoaXMuc3RhcnRcbiAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IE1hdGgubWluKHJ1bnRpbWUgLyA2MDAsIDEpXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VzWzBdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJysgKHRoaXMuaW1nU3RhcnQgLSAodGhpcy5kaXN0KnByb2dyZXNzKSApKydweCwgLTUwJSknXG4gICAgICAgICAgIFxuICAgICAgICAgICAgaWYocHJvZ3Jlc3MgPT09IDEpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vU2Vjb25kIHBob3RvIGZvbGxvd2luZyB0aGUgZmlyc3QgdG8gYmUgYW5pbWF0ZWQgYXV0b21hdGljYWxseVxuICAgICAgICAgICAgICAgIGlmKHRoaXMuaiA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja3MgaWYgbGVmdCBvciByaWdodCBidXR0b24gY2xpY2sgd2l0aCBhIG5lZ2F0aXZlIGxlZnQgb3IgcG9zaXRpdmUgcmlnaHQgYW5kIHVwZGF0ZXMgaW1nU3RhcnRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWdTdGFydCA9IHRoaXMuZGlzdCA8IDAgPyAtdGhpcy5jb250YWluZXJXaWR0aCgpIDogdGhpcy5jb250YWluZXJXaWR0aCgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdCA9IHRoaXMuZGlzdCA8IDAgPyAtdGhpcy5jb250YWluZXJXaWR0aCgpIDogdGhpcy5jb250YWluZXJXaWR0aCgpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQgPSAwXG4gICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gdGhpcy5pbWFnZXMuc2hpZnQoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmltYWdlcy5wdXNoKGl0ZW0pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaiA9IDBcbiAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vVXNlciBkb3VibGUgY2xpY2tzIHNhbWUgYnV0dG9uIHdoZW4gMm5kIGltYWdlIGlzbid0IGZpbmlzaGVkIGl0IGRyYXdzIGFnYWluXG4gICAgICAgICAgICAgICAgICAgIGlmKHRoaXMuaW1nU3RhcnQgIT09IHRoaXMuZGlzdCApe1xuICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3KClcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vU3RvcHMgdHlwZWQgdGV4dCBmcm9tIHJ1bm5pbmcgb25seSB3aGVuIHBob3RvIHN0b3BzIGludG8gcGxhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIF8oJ3RleHQtZmllbGQnKS50ZXh0Q29udGVudCA9ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUZXh0LnVwZGF0ZUltZ1RleHQodGhpcy5pbWFnZXNbMF0pIC8vU3RhcnRzIHRoZSB0eXBlZCB0ZXh0IGZ1bmN0aW9uXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggXygnYnV0dG9uLWlubGFyZ2UnKS5zdHlsZS5vcGFjaXR5ICE9PSAnMScgKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfKCdidXR0b24taW5sYXJnZScpLnN0eWxlLm9wYWNpdHkgPSAxXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvbmVJbWFnZSh0aGlzLmltYWdlc1swXSkgXG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmorK1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlU2xpZGVyLmRyYXcuYmluZCh0aGlzKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFuaW1hdGVEYXRhOiBmdW5jdGlvbihlKXsgICBcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnRhcmdldC5pbm5lclRleHRcbiAgICAgICAgICAgIHZhciBuZXdTdGFydCA9IHRoaXMubmV3U3RhcnQoMClcbiAgICAgICAgICAgIHRoaXMucGFydGlhbERpc3QgPSBuZXdTdGFydFxuXG4gICAgICAgICAgICAvL0lmIHVzZXIgY2xpY2tzIGJlZm9yZSBpbWFnZSBkb25lIGFuaW1hdGluZywgdXBkYXRlcyBjdXJyZW50IGxvY2F0aW9uIGFuZCBzdGFydHMgYWdhaW5cbiAgICAgICAgICAgIGlmKG5ld1N0YXJ0ICE9PSAwICYmICFpc05hTihuZXdTdGFydCkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHRhcmdldCA9PT0gJzwnKXtcbiAgICAgICAgICAgICAgICAgICAgLy9JZiB1c2VyIGRvdWJsZSBjbGlja3Mgc2FtZSBidXR0b24gcmlnaHQgYXdheVxuICAgICAgICAgICAgICAgICAgICBpZihuZXdTdGFydCA8IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWdTdGFydCA9IG5ld1N0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3QgPSB0aGlzLmNvbnRhaW5lcldpZHRoKCkgKyBuZXdTdGFydFxuICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaiA9IDAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdCA9IG5ld1N0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltZ1N0YXJ0ID0gbmV3U3RhcnRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZih0YXJnZXQgPT09ICc+Jyl7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZihuZXdTdGFydCA8IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5qID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWdTdGFydCA9IG5ld1N0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3QgPSBuZXdTdGFydFxuICAgICAgICAgICAgICAgICAgICAvL0lmIHVzZXIgZG91YmxlIGNsaWNrcyBzYW1lIGJ1dHRvbiByaWdodCBhd2F5XG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbWdTdGFydCA9IG5ld1N0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3QgPSAtdGhpcy5jb250YWluZXJXaWR0aCgpICsgbmV3U3RhcnRcbiAgICAgICAgICAgICAgICAgICAgfSAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0gMFxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydCA9IDBcblxuICAgICAgICAgICAgICAgIGlmKHRhcmdldCA9PT0gJzwnKXtcbiAgICAgICAgICAgICAgICAgICAgLy9maXJzdCBjbGljayBzdGFydHMgaW1hZ2Ugb3V0c2lkZSB0aGUgaGVhZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmogPj0gMSA/IHRoaXMuaW1nU3RhcnQgPSAwIDogdGhpcy5pbWdTdGFydCA9IHRoaXMuY29udGFpbmVyV2lkdGgoKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3QgPSB0aGlzLmNvbnRhaW5lcldpZHRoKClcbiAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vZmlyc3QgY2xpY2sgc3RhcnRzIGltYWdlIG91dHNpZGUgdGhlIGhlYWRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5qID49IDEgPyB0aGlzLmltZ1N0YXJ0ID0gMCA6IHRoaXMuaW1nU3RhcnQgPSAtdGhpcy5jb250YWluZXJXaWR0aCgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdCA9IC10aGlzLmNvbnRhaW5lcldpZHRoKClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRyYXcoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBsb2FkIGltYWdlcyBpbnRvIGFycmF5IHRvIGJlIHVzZWQgZm9yIHNsaWRlclxuICAgICAgICBsb2FkSW1hZ2VzOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXNpZ25JbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IGRlc2lnbkltYWdlc1tpXTtcbiAgICAgICAgICAgICAgICB0aGlzLmltYWdlcy5wdXNoKGVsZW1lbnQpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgLy8gS2VlcHMgZnJvbSByZXNpemUgZXZlbnQgbG9hZGluZyBjbGljayBoYW5kbGVyXG4gICAgaWYoZS50eXBlICE9PSAncmVzaXplJyAmJiBlLnR5cGUgIT09ICdzY3JvbGwnKXtcbiAgICAgICAgXG4gICAgICAgIF8oJ2J0bkNvbnRhaW5lcicpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgICAgICAgICBhbmltYXRlU2xpZGVyLnRhcmdldCA9IGUudGFyZ2V0XG4gICAgICAgICAgICBhbmltYXRlU2xpZGVyLmFuaW1hdGVEYXRhKGUpXG5cbiAgICAgICAgICAgIGNoZWNrRm9yQ2xhc3NlcygpXG4gICAgICAgICAgICBhZGRFbGVjdHJpY2l0eSgpXG4gICAgICAgICAgICB1cGRhdGVUZXh0LnRvZ2dsZUZhbHNlKClcbiAgICAgICAgICAgIF8oJ3RleHQtZmllbGQnKS50ZXh0Q29udGVudCA9ICcnXG4gICAgICAgICAgICBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBbYW5pbWF0ZVNsaWRlciwgYW5pbWF0ZVN0YXJzXSAvLyBUbyBiZSB1c2VkIGluIHRoZSB3aW5kb3cub25sb2FkIHNlY3Rpb25cbn07XG5cblxuZnVuY3Rpb24gRGVzaWduU2xpZGVyKCkge1xuICAgIHZhciBpbWdfY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnaW1hZ2UtY29udGFpbmVyJylbMF1cbiAgICB2YXIgaW1nX2NvbnRhaW5lcl9yZWN0ID0gaW1nX2NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIHRoaXMuZWxsaXBzZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NsaXAtZWxsaXBzZScpWzBdXG4gICAgdGhpcy5yZWMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzY3JlZW4tcGF0aCcpWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgdGhpcy5zZWN0aW9uQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc2VjdGlvbi10aHJlZS1yb2JvdCcpWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICB2YXIgYWN0dWFsVG9wID0gdGhpcy5yZWMudG9wIC0gdGhpcy5zZWN0aW9uQ29udGFpbmVyLnRvcCAvL3doZW4gcGFnZSBub3QgZnVsbHkgc2Nyb2xsZWQgaW50byB2aWV3IGl0J3MgdGhlIGFjdHVhbCB0b3BcbiAgIFxuICAgIHRoaXMuc2V0RWxsaXBzZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLmVsbGlwc2Uuc2V0QXR0cmlidXRlKCdyeCcsIHRoaXMucmVjLndpZHRoLzIpXG4gICAgICAgIHRoaXMuZWxsaXBzZS5zZXRBdHRyaWJ1dGUoJ3J5JywgdGhpcy5yZWMuaGVpZ2h0LzIpXG4gICAgICAgIHRoaXMuZWxsaXBzZS5zZXRBdHRyaWJ1dGUoJ2N4JywgdGhpcy5yZWMubGVmdCArIHRoaXMucmVjLndpZHRoLzIgLSA1KVxuICAgICAgICB0aGlzLmVsbGlwc2Uuc2V0QXR0cmlidXRlKCdjeScsIGFjdHVhbFRvcCArIHRoaXMucmVjLmhlaWdodC8yIClcbiAgICB9XG4gICAgdGhpcy5zZXRJbWdDb250YWluZXIgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgY29udGFpbmVyX1dpZHRoID0gdGhpcy5yZWMud2lkdGggLyA5ICsgdGhpcy5yZWMud2lkdGhcbiAgICAgICAgdmFyIGltZ19jb250YWluZXJZID0gYWN0dWFsVG9wIC0gKGltZ19jb250YWluZXJfcmVjdC5oZWlnaHQgLSB0aGlzLnJlYy5oZWlnaHQpIC8gMlxuICAgICAgICBpbWdfY29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoLTUwJSwnICsgaW1nX2NvbnRhaW5lclkgKyAncHgpJyAgLy8tNDglIHRvIG1ha2UgdXAgZm9yIDUzJSByb2JvdC1zdmcgb2Zmc2V0XG4gICAgICAgIGltZ19jb250YWluZXIuc3R5bGUud2lkdGggPSBjb250YWluZXJfV2lkdGggKyAncHgnXG4gICAgfVxuICAgIHRoaXMuc2V0QnV0dG9uTG9jYXRpb24gPSBmdW5jdGlvbigpe1xuXG4gICAgICAgIHZhciBhZGRlZFdpZHRoID0gd2luZG93LmlubmVyV2lkdGggPCA3NjggPyA3MCA6IDIwMCAgLy9EaXN0YW5jZSBiaWdnZXIgdGhhbiByb2JvdCBoZWFkXG5cbiAgICAgICAgdmFyIHggPSAgKCB3aW5kb3cuaW5uZXJXaWR0aCAtICh0aGlzLnJlYy53aWR0aCArIGFkZGVkV2lkdGgpICkgLyAyXG4gICAgICAgIHZhciB5ID0gd2luZG93LmlubmVyV2lkdGggPiA3NjggPyBhY3R1YWxUb3AgKyAoIHRoaXMucmVjLmhlaWdodCAvIDIgKSAtIDI1IDogdGhpcy5yZWMuYm90dG9tIC0gdGhpcy5zZWN0aW9uQ29udGFpbmVyLnRvcCAvLyAtIDI1IGZvciB0aGUgYnRuQ29udGFpbmVyIGhlaWdodCAvIDJcblxuICAgICAgICBfKCdidG5Db250YWluZXInKS5zdHlsZS53aWR0aCA9IHRoaXMucmVjLndpZHRoICsgYWRkZWRXaWR0aCArJ3B4J1xuICAgICAgICBfKCdidG5Db250YWluZXInKS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcrIHggKyAncHgsJyArIHkgKyAncHgpJ1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKXtcblxuICAgICAgICByZXR1cm4gW3RoaXMuc2V0RWxsaXBzZUF0dHJpYnV0ZXMoKSx0aGlzLnNldEltZ0NvbnRhaW5lcigpLHRoaXMuc2V0QnV0dG9uTG9jYXRpb24oKV1cblxuICAgIH0uYmluZCh0aGlzKVxufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJyxmdW5jdGlvbihlKXtcblxuICAgIHZhciB1cGRhdGVSb2JvdCA9IHJvYm90U2VjdGlvbihlKVxuXG4gICAgdmFyIGRlc2lnblNsaWRlciA9IG5ldyBEZXNpZ25TbGlkZXIoKVxuICAgIGRlc2lnblNsaWRlcigpICAvL3VwZGF0ZXMgY2FudmFzIHNpemVcbiAgICB1cGRhdGVSb2JvdFsxXSgpICAvL3VwZGF0ZXMgYnV0dG9uLCBpbWFnZSBsb2NhdGlvbiAsIGF0dHJpYnV0ZXMgb2Ygcm9ib3Rcbn0pO1xuXG4vLyAqKioqIEFTU0VNQkxZIExJTkUgU0VDVElPTiAqKioqXG5cbmNsYXNzIEFzc2VtYmx5TGluZSB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5tYWluU1ZHID0gXygnYXNzZW1ibHktbGluZS1zdmcnKVxuICAgICAgICB0aGlzLnNsaWRlcnMgPSBfKCdyb2xsZXJfdW5pdCcpXG4gICAgICAgIHRoaXMuY29kZUNvbnRhaW5lcnMgPSBfKCdjb2RlLWNvbnRhaW5lcicpXG4gICAgfVxuICAgIFxuICAgIGdldFJlY3QoZWwpe1xuICAgICAgICBsZXQgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICAgIGxldCBiQm94ID0gZWwuZ2V0QkJveCgpXG4gICAgICAgIHJldHVybiB7cmVjdCwgYkJveH1cbiAgICB9XG4gICAgXG4gICAgZ2V0RWxlbVZhbHVlKHBvcykge1xuICAgICAgICBjb25zdCBbc2l6ZV0gPSAvWzEtOV0uKi8uZXhlYyggdGhpcy5tYWluU1ZHLmdldEF0dHJpYnV0ZSgndmlld0JveCcpIClcbiAgICAgICAgY29uc3QgcmVnRXggPSAvXihcXGR7NH0pXFxzKFxcZHszfSkkL2lnO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXVxuICAgICAgICB2YWx1ZXMubGVuZ3RoID0gMCAgXG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLnNsaWRlcnMubGVuZ3RoO1xuICAgICAgICBjb25zdCByb2xsZXJVbml0ID0gdGhpcy5zbGlkZXJzXG4gICAgICAgIGNvbnN0IGNvZGVFbGVtZW50cyA9IHRoaXMuY29kZUNvbnRhaW5lcnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgcm9sbGVyRWxlbSA9IHJvbGxlclVuaXRbaV1cbiAgICAgICAgICAgIGNvbnN0IGNvZGVFbGVtID0gY29kZUVsZW1lbnRzW2ldXG4gICAgICAgIFxuICAgICAgICAgICAgc3dpdGNoIChwb3MpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjb250YWluZXInOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xpZGVyc0NvbnRhaW5lclxuICAgICAgICAgICAgICAgIGNhc2UgJ3ZpZXdCb3hXaWR0aCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXplLnJlcGxhY2UocmVnRXgsICckMScpXG4gICAgICAgICAgICAgICAgY2FzZSAndmlld0JveEhlaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaXplLnJlcGxhY2UocmVnRXgsICckMicpXG4gICAgICAgICAgICAgICAgY2FzZSAnZWwnOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaChyb2xsZXJFbGVtKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyZWN0WCc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCB0aGlzLmdldFJlY3QoIHJvbGxlckVsZW0gKS5yZWN0LnggKSAvLyBub3QgaW4gdXNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvZGVCb3gueCc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCB0aGlzLmdldFJlY3QoIGNvZGVFbGVtICkucmVjdC54ICkgXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvZGViQm94LngnOiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCggdGhpcy5nZXRSZWN0KCBjb2RlRWxlbSApLmJCb3gueCApIFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdiQm94WCc6ICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCB0aGlzLmdldFJlY3QoIHJvbGxlckVsZW0gKS5iQm94LnggKS8vIG5vdCBpbiB1c2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAneSc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCB0aGlzLmdldFJlY3QoIHJvbGxlckVsZW0gKS5iQm94LnkgKSAgIFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd3aWR0aCc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCB0aGlzLmdldFJlY3QoIHJvbGxlckVsZW0gKS5iQm94LndpZHRoICkgICBcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaGVpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goIHRoaXMuZ2V0UmVjdCggcm9sbGVyRWxlbSApLmJCb3guaGVpZ2h0IClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7IFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICB9XG59O1xuXG5jbGFzcyBSb2xsZXJVbml0IGV4dGVuZHMgQXNzZW1ibHlMaW5lIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcigpXG4gICAgICAgIHRoaXMuZ2V0UmVjdCA9IHRoaXMuZ2V0UmVjdFxuICAgICAgICB0aGlzLmRyYXcgPSB0aGlzLmRyYXcuYmluZCh0aGlzKVxuICAgICAgICB0aGlzLmJlZ2luUG9zID0gW11cbiAgICAgICAgdGhpcy5kaXN0ID0gW11cbiAgICAgICAgdGhpcy5sZXNzVGhhbiA9ICcnXG4gICAgICAgIHRoaXMuc3RhcnQgPSAwXG4gICAgICAgIHRoaXMudGltZSA9IDEwMDBcbiAgICAgICAgdGhpcy5jdXJyZW50ID0ge31cbiAgICAgICAgdGhpcy5jbGljayA9IDBcbiAgICAgICAgdGhpcy5iZWx0Q2xpY2sgPSAwXG4gICAgICAgIHRoaXMuZm9yZWluT2JqcyA9IF8oJ2Fzc2VtYmx5LWltZy1mb3JlaWduT2JqJylcbiAgICAgICAgdGhpcy5mb3JlaW5Hcm91cCA9IF8oJ2Fzc2VtYmx5LWltZy13cmFwJylcbiAgICAgICAgdGhpcy5iZWx0cyA9IF8oJ2JlbHQnKVxuICAgIH1cblxuICAgIHN0YXJ0UG9zKGVsZW0pe1xuICAgICAgICBsZXQgYXJyID0gW11cbiAgICAgICAgbGV0IGVsID0gZWxlbVxuICAgICAgICBjb25zdCBsZW5ndGggPSBlbC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICggZWxbaV0uaGFzQXR0cmlidXRlKCdzdHlsZScpICl7XG4gICAgICAgICAgICAgICAgYXJyLnB1c2goIHBhcnNlSW50ICggZWxbaV0uc3R5bGUudHJhbnNmb3JtLnJlcGxhY2UoL14oW1xcd10qKVxcKChbPy1cXGRdLiopcHhcXCkvaWcsIFwiJDJcIikgKSApXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBhcnIucHVzaCgwKSBcbiAgICAgICAgICAgIH0gIFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJcbiAgICB9XG5cbiAgICBtaW4oIHN0YXJ0LGFjdHVhbCA9IFtdKXtcbiAgICAgICAgbGV0IHJlY3QgPSBNYXRoLm1pbiguLi5zdGFydClcbiAgICAgICAgbGV0IGRpc3QgPSBNYXRoLm1pbiguLi5hY3R1YWwpXG4gICAgICAgIGxldCBpbmRleCA9IHN0YXJ0LmluZGV4T2YocmVjdClcbiAgICAgICAgcmV0dXJuIHtpbmRleCxkaXN0fSAgICAgICAgIFxuICAgIH1cbiAgICBtYXgoIHN0YXJ0LGFjdHVhbCApe1xuICAgICAgICBsZXQgcmVjdCA9IE1hdGgubWF4KC4uLnN0YXJ0KVxuICAgICAgICBsZXQgZGlzdCA9IE1hdGgubWF4KC4uLmFjdHVhbClcbiAgICAgICAgbGV0IGluZGV4ID0gc3RhcnQuaW5kZXhPZihyZWN0KVxuICAgICAgICByZXR1cm4ge2luZGV4LGRpc3R9XG4gICAgfVxuXG4gICAgZ2V0RGlzdGFuY2UoKXtcbiAgICAgICAgbGV0IHdpZHRoID0gdGhpcy5nZXRFbGVtVmFsdWUoJ3dpZHRoJylbMF1cbiAgICAgICAgbGV0IGFyciA9IFtdXG4gICAgICAgIGxldCBzdGFydGluZ1BvaW50ID0gdGhpcy5nZXRFbGVtVmFsdWUoJ2NvZGVCb3gueCcpXG4gICAgICAgIGxldCBhY3R1YWxEaXN0ID0gdGhpcy5nZXRFbGVtVmFsdWUoJ2NvZGViQm94LngnKVxuICAgIFxuICAgICAgICBjb25zdCBtYXhFbGVtZW50ID0gdGhpcy5tYXgoc3RhcnRpbmdQb2ludCxhY3R1YWxEaXN0KVxuICAgICAgICBjb25zdCBtaW5FbGVtZW50ID0gdGhpcy5taW4oc3RhcnRpbmdQb2ludCxhY3R1YWxEaXN0KVxuXG4gICAgICAgIGNvbnN0IG1vdmVFbmQgPSAoaykgPT4ge1xuICAgICAgICAgICAgbGV0IGRpc3QgPSB0aGlzLmxlZnQgPyA0MzEgOiAtNDMxICAvLyBtb3ZlQmVnaW5uaW5nIGRpc3QgKiAyICAgIFxuICAgICAgICAgICAgYXJyLnB1c2goe2Rpc3Q6IGRpc3QsIGluZGV4OiBrLCB9KVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbW92ZUJlZ2lubmluZyA9IChrKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGlzdCA9IHRoaXMubGVmdCA/IChtaW5FbGVtZW50LmRpc3QgKyB3aWR0aCkgOiAtKG1pbkVsZW1lbnQuZGlzdCArIHdpZHRoKSBcbiAgICAgICAgICAgIGxldCByaWdodFBhZ2VTdGFydCA9IHRoaXMubGVmdCA/IGFjdHVhbERpc3QucmV2ZXJzZSgpW2tdICsgd2lkdGggOiAtYWN0dWFsRGlzdFtrXSAtIHdpZHRoXG4gICAgICAgIFxuICAgICAgICAgICAgdGhpcy5sZXNzVGhhbiA9IGsgIC8vVXBkYXRlcyB0aGUgc21hbGxlc3QgZGlzdGFuY2VcbiAgICAgICAgICAgIGFyci5wdXNoKHtkaXN0OiBkaXN0KjIsaW5kZXg6IGssIHJpZ2h0UGFnZVN0YXJ0OiByaWdodFBhZ2VTdGFydCwgcGFnZVJpZ2h0OiB0cnVlfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihsZXQgayA9IDA7IGsgPCAzOyBrKysgKXtcbiAgICBcbiAgICAgICAgICAgIGlmICggbWluRWxlbWVudC5pbmRleCA9PT0gayApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0ID8gbW92ZUVuZChrKSA6IG1vdmVCZWdpbm5pbmcoaykgICAgICAgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9ZWxzZSBpZiggbWF4RWxlbWVudC5pbmRleCA9PT0gayApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJpZ2h0ID8gbW92ZUJlZ2lubmluZyhrKSA6ICBtb3ZlRW5kKGspXG5cbiAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IHRoaXMubGVmdCA/IDQzMSA6IC00MzEgIC8vIG1vdmVCZWdpbm5pbmcgZGlzdCAqIDJcbiAgICAgICAgICAgICAgICBhcnIucHVzaCh7ZGlzdDogZGlzdCwgaW5kZXg6IGt9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFyci5zb3J0ID0gKGEsYikgPT4gYS5wbGFjZSAtIGIucGxhY2VcbiAgICAgICAgcmV0dXJuIGFyclxuICAgIH1cblxuICAgIC8vIEFkZCBhbmQgcmVtb3ZlIGZvcmVpZ25PYmplY3RzIGludG8gc2xpZGVyXG4gICAgZm9yZWluT2JqQXJyKCl7XG4gICAgICAgIC8vIGxldCBsZW5ndGggPSAgdGhpcy5mb3JlaW5PYmpzLmxlbmd0aFxuICAgICAgICBsZXQgbGVuZ3RoID0gIHRoaXMuZm9yZWluR3JvdXAubGVuZ3RoXG4gICAgICAgIGxldCBhcnIgPSBuZXcgQXJyYXkobGVuZ3RoKVxuXG4gICAgICAgIC8vIFB1dHMgaW1hZ2UgZm9yZWlnbm9iamVjdHMgaW50byBhcnJheVxuICAgICAgICB3aGlsZShsZW5ndGgpIHtcbiAgICAgICAgICAgIGxlbmd0aC0tO1xuICAgICAgICAgICAgYXJyW2xlbmd0aF0gPSB0aGlzLmZvcmVpbkdyb3VwW2xlbmd0aF07XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RhcnRpbmdQb2ludCA9IHRoaXMuZ2V0RWxlbVZhbHVlKCdjb2RlQm94LngnKVxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLm1pbihzdGFydGluZ1BvaW50KS5pbmRleFxuICAgICAgICBcbiAgICAgICAgbGV0IGFkZCA9IGFyci5zcGxpY2UoMywxKVxuICAgICAgICBsZXQgcmVtb3ZlZCA9IGFyci5zcGxpY2UoaW5kZXgsMSlcblxuICAgICAgICBsZXQgcmVtb3ZlZENoaWxkID0gcmVtb3ZlZFswXS5jaGlsZE5vZGVzWzFdXG4gICAgICAgIGxldCBhZGRDaGlsZCA9IGFkZFswXS5jaGlsZE5vZGVzWzFdXG4gICAgICAgIGFyci5zcGxpY2UoaW5kZXgsMCxhZGRbMF0pXG4gICAgICAgIGFyci5wdXNoKHJlbW92ZWRbMF0pXG5cbiAgICAgICAgLy9BZGQgYW5kIHJlbW92ZSBqdXN0IHRyYW5zZm9ybXMgZmlyc3RcbiAgICAgICAgbGV0IHN0eWxlVHJhbnNmb3JtID0gIHJlbW92ZWRbMF0uYXR0cmlidXRlc1sxXVxuICAgICAgICByZW1vdmVkWzBdLnJlbW92ZUF0dHJpYnV0ZSggc3R5bGVUcmFuc2Zvcm0ubmFtZSkgXG4gICAgICAgIGFkZFswXS5zZXRBdHRyaWJ1dGUoc3R5bGVUcmFuc2Zvcm0ubmFtZSwgc3R5bGVUcmFuc2Zvcm0udmFsdWUpICAgICBcblxuICAgICAgICAvL1N0cmlwcyBhdHRyaWJ1dGVzIG9mIHJlbW92ZWQgYW5kIGFkZCBzYW1lIGF0dHJpYnV0ZXMgdG8gYWRkZWQgZm9yZWlnbm9iamVjdFxuICAgICAgICB3aGlsZSggcmVtb3ZlZENoaWxkLmF0dHJpYnV0ZXMubGVuZ3RoID4gMSl7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgYXR0ck5hbWUgPSAgcmVtb3ZlZENoaWxkLmF0dHJpYnV0ZXNbMV0ubmFtZSBcbiAgICAgICAgICAgIGxldCBhdHRyVmFsdWUgPSAgcmVtb3ZlZENoaWxkLmF0dHJpYnV0ZXNbMV0udmFsdWUgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGFkZENoaWxkLnNldEF0dHJpYnV0ZShhdHRyTmFtZSwgYXR0clZhbHVlKVxuICAgICAgICAgICAgcmVtb3ZlZENoaWxkLnJlbW92ZUF0dHJpYnV0ZSggcmVtb3ZlZENoaWxkLmF0dHJpYnV0ZXNbMV0ubmFtZSlcbiAgICAgICAgfSBcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZm9yZWluR3JvdXAgPSBhcnJcbiAgICB9XG4gICAgXG4gICAgLy8gUmFuIG9uY2Ugd2hlbiBwYWdlIHJlbG9hZHNcbiAgICBwb3NpdGlvbkZvcmllZ25PYmplY3QoX3RoaXMpe1xuICAgICAgICBsZXQgc2xpZGVycyA9IHRoaXMuY29kZUNvbnRhaW5lcnNcbiAgICAgICAgbGV0IGZvcmVpZ25PYmplY3RzID0gdGhpcy5mb3JlaW5PYmpzXG4gICAgICAgIGxldCBsZW5ndGggPSBzbGlkZXJzLmxlbmd0aFxuICAgIFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCBzbGlkZXJfeCA9IHRoaXMuZ2V0UmVjdCh0aGlzLmNvZGVDb250YWluZXJzW2ldKS5iQm94LnhcbiAgICAgICAgICAgIGxldCBzbGlkZXJfeSA9IHRoaXMuZ2V0UmVjdCh0aGlzLmNvZGVDb250YWluZXJzW2ldKS5iQm94LnlcbiAgICAgICAgICAgIGxldCBzbGlkZXJfd2lkdGggPSB0aGlzLmdldFJlY3QodGhpcy5jb2RlQ29udGFpbmVyc1tpXSkuYkJveC53aWR0aFxuICAgICAgICAgICAgbGV0IHNsaWRlcl9oZWlnaHQgPSB0aGlzLmdldFJlY3QodGhpcy5jb2RlQ29udGFpbmVyc1tpXSkuYkJveC5oZWlnaHRcbiAgICBcbiAgICAgICAgICAgIGZvcmVpZ25PYmplY3RzW2ldLnNldEF0dHJpYnV0ZSgneCcsIHNsaWRlcl94KVxuICAgICAgICAgICAgZm9yZWlnbk9iamVjdHNbaV0uc2V0QXR0cmlidXRlKCd5Jywgc2xpZGVyX3kpXG4gICAgICAgICAgICBmb3JlaWduT2JqZWN0c1tpXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgc2xpZGVyX3dpZHRoKVxuICAgICAgICAgICAgZm9yZWlnbk9iamVjdHNbaV0uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzbGlkZXJfaGVpZ2h0KVxuICAgICAgICB9XG4gICAgICAgIC8vSW5wdXRzIGltYWdlIGludG8gY29udGFpbmVyXG4gICAgICAgIF90aGlzLnRhcmdldEVsZW0oKVxuICAgIH1cbiAgICBcbiAgICBcbiAgICBtb3JlVGhhbkhhbGYoIGRpc3QsIHBvc2l0aXZlQ3VycmVudCwgc3RhcnREaXN0ICl7XG4gICAgICAgIHJldHVybiBkaXN0IC0gKHN0YXJ0RGlzdCAtIHBvc2l0aXZlQ3VycmVudClcbiAgICB9XG4gICAgXG4gICAgbGVzc1RoYW5IYWxmKGN1cnJlbnQsIGRpc3QsIHN0YXJ0RGlzdCl7XG4gICAgICAgIGxldCBkID0gZGlzdC5kaXN0IDwgMCA/IGRpc3QuZGlzdCAqIC0xIDogZGlzdC5kaXN0XG5cbiAgICAgICAgaWYoc3RhcnREaXN0ID09PSAwICl7XG4gICAgICAgICAgICBpZihkaXN0LnJpZ2h0UGFnZVN0YXJ0KXtcbiAgICAgICAgICAgICAgICBsZXQgZGlmZiA9IGN1cnJlbnQgLSBzdGFydERpc3QgXG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsRGlmZiA9IGQgLSAgKGN1cnJlbnQgLSBzdGFydERpc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgKyB0b3RhbERpZmZcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkIC0gY3VycmVudFxuICAgICAgICAgICAgXG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgIGlmKGRpc3QucmlnaHRQYWdlU3RhcnQpe1xuICAgICAgICAgICAgICAgIGxldCBkaWZmID0gY3VycmVudCAtIHN0YXJ0RGlzdCBcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxEaWZmID0gZCAtICBNYXRoLmFicyhjdXJyZW50IC0gc3RhcnREaXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiBkaWZmICsgdG90YWxEaWZmXG4gICAgICAgICAgICB9ICBcbiAgICAgICAgICAgIGxldCBkaWZmID0gZCAtIE1hdGguYWJzKGN1cnJlbnQgLSBzdGFydERpc3QpXG4gICAgICAgICAgICByZXR1cm4gZGlmZlxuICAgICAgICB9XG4gICAgfVxuICAgIG9wcGlzaXRlRGlyKGN1cnJlbnQsIHN0YXJ0RGlzdCl7XG4gICAgICAgIGlmKHN0YXJ0RGlzdCA9PT0gMCl7XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudFxuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICBpZihjdXJyZW50ID4gc3RhcnREaXN0KXsgLy8gbW9yZSB0aGFuIGhhbGZcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudCAtIHN0YXJ0RGlzdFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0RGlzdCAtIGN1cnJlbnQgICAvL2xlc3MgdGhhbiBoYWxmICAgIFxuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVJpZ2h0UGFnZVN0YXJ0KGQscmlnaHRQYWdlU3RhcnQsIHBvc0N1cnJlbnQsIHN0YXJ0RGlzdCl7XG4gICAgXG4gICAgICAgIGlmKHN0YXJ0RGlzdCA8IDApe1xuICAgICAgICAgICAgLy9tb3JlIHRoYW4gaGFsZlxuICAgICAgICAgICAgaWYoZCA+IHBvc0N1cnJlbnQpeyAgXG4gICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gcG9zQ3VycmVudFxuICAgICAgICAgICAgICAgIHJldHVybiB7ZGlzdGFuY2UsIHBhZ2VSaWdodDogZmFsc2V9IFxuICAgICAgICAgICAgLy9sZXNzIHRoYW4gaGFsZlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGRpZmZlcmVuY2UgPSAoMTE0MS4yIC0gcG9zQ3VycmVudCkgXG4gICAgICAgICAgICBsZXQgdG90YWxEaWYgPSBkIC0gKDExNDEuMiAtIHBvc0N1cnJlbnQpXG4gICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSBkaWZmZXJlbmNlICsgdG90YWxEaWZcbiAgICAgICAgICAgIHJldHVybiB7ZGlzdGFuY2UsIHBhZ2VSaWdodDogdHJ1ZX1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vbGVzcyB0aGFuIGhhbGYgb25seSBlbGVtZW50IHdpdGggYSByaWdodFBhZ2VTdGFydCBvZiAxMTQxLjJcbiAgICAgICAgICAgIGlmKHJpZ2h0UGFnZVN0YXJ0ID4gMTE2MCl7IC8vMTE2MFxuICAgICAgICAgICAgICAgIGxldCBkaWZmZXJlbmNlID0gZCAvIDIgLSBwb3NDdXJyZW50XG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsRGlmID0gZCAtICBkaWZmZXJlbmNlXG4gICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gdG90YWxEaWYgKyBkaWZmZXJlbmNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtkaXN0YW5jZSwgcGFnZVJpZ2h0OiB0cnVlfVxuICAgICAgICAgICAgLy9tb3JlIHRoYW4gaGFsZlxuICAgICAgICAgICAgfWVsc2UgaWYocG9zQ3VycmVudCA8IHN0YXJ0RGlzdCApeyBcbiAgICAgICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSBzdGFydERpc3QgLSBwb3NDdXJyZW50IFxuICAgICAgICAgICAgICAgIHJldHVybiB7ZGlzdGFuY2UsIHBhZ2VSaWdodDogZmFsc2UgfVxuICAgICAgICAgICAgLy9sZXNzIHRoYW4gaGFsZiBcbiAgICAgICAgICAgIH1lbHNleyAgXG4gICAgICAgICAgICAgICAgbGV0IGRpZmYgPSBwb3NDdXJyZW50IC0gc3RhcnREaXN0IFxuICAgICAgICAgICAgICAgIGxldCB0b3RhbERpZmYgPSBkIC0gIChwb3NDdXJyZW50IC0gc3RhcnREaXN0KVxuICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IGRpZmYgKyB0b3RhbERpZmZcbiAgICAgICAgICAgICAgICByZXR1cm4ge2Rpc3RhbmNlLCBwYWdlUmlnaHQ6IHRydWV9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gKiogUklHSFQgQlVUVE9OIElTIE5FR0FUSVZFIERJU1QsIExFRlQgQlVUVE9OIElTIFBPU0lUSVZFIERJU1QqKlxuICAgIGhhbmRsZURvdWJsZUNsaWNrKGN1cnJlbnQsIGRpc3QsIGJlZ2luUG9zKXtcbiAgICAgICAgLy9VcGRhdGVzIGhvdyBtYW55IHRpbWVzIGJhY2sgYW5kIGZvcnRoIGJlZm9yZSBhbmltYXRpb24gZmluaXNoZXNcbiAgICAgICAgdGhpcy5jbGljayArK1xuXG4gICAgICAgIGxldCBjdXJyZW50RGlyZWN0aW9uID0gTWF0aC5zaWduKCB0aGlzLmN1cnJlbnREaXN0WzFdLmRpc3QgKVxuICAgICAgICBsZXQgZGlzdERpcmVjdGlvbiA9IE1hdGguc2lnbiggZGlzdFsxXS5kaXN0IClcbiAgICAgICAgXG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCAzOyBpKyspe1xuXG4gICAgICAgICAgICAvL01pZGRsZSBkaXN0IG5vdCBlcXVhbCBib3RoIG5lZ2F0aXZlIG9yIHBvc2l0aXZlcyB0aGVuIHVzZSBjdXJyZW50IGRpc3RcbiAgICAgICAgICAgIGxldCBkaXN0X2kgPSBjdXJyZW50RGlyZWN0aW9uICE9PSBkaXN0RGlyZWN0aW9uID8gdGhpcy5jdXJyZW50RGlzdFtpXSA6IGRpc3RbaV1cbiAgICAgICAgICAgIGxldCBkID0gZGlzdF9pLmRpc3QgPCAwID8gZGlzdF9pLmRpc3QgKiAtMSA6IGRpc3RfaS5kaXN0ICAvL2NoYW5nZWQgdGhpc1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL1N0YXJ0cyBvZmYgd2l0aCBwb3NpdGl2ZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIGxldCByaWdodFBhZ2VTdGFydCA9IGRpc3RfaS5yaWdodFBhZ2VTdGFydCA8IDAgPyBkaXN0X2kucmlnaHRQYWdlU3RhcnQgKiAtMSA6IGRpc3RfaS5yaWdodFBhZ2VTdGFydFxuICAgICAgICAgICAgbGV0IHN0YXJ0RGlzdCA9IGJlZ2luUG9zW2ldIDwgMCA/IGJlZ2luUG9zW2ldICogLTEgOiBiZWdpblBvc1tpXVxuICAgICAgICAgICAgbGV0IHBvc0N1cnJlbnQgPSBjdXJyZW50W2ldIDwgMCA/IGN1cnJlbnRbaV0gKiAtMSA6IGN1cnJlbnRbaV1cblxuICAgICAgICAgICAgLy8gV2hlbiBjbGlja2VkIG9wcG9zaXRlIGRpcmVjdGlvblxuICAgICAgICAgICAgaWYoIGN1cnJlbnREaXJlY3Rpb24gIT09IGRpc3REaXJlY3Rpb24pe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoIHJpZ2h0UGFnZVN0YXJ0ICl7XG4gICAgICAgICAgICAgICAgICAgIGxldCByaWdodFN0YXJ0ID0gdGhpcy5yaWdodCA/IC1yaWdodFBhZ2VTdGFydCA6IHJpZ2h0UGFnZVN0YXJ0XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyID0gdGhpcy5oYW5kbGVSaWdodFBhZ2VTdGFydChkLHJpZ2h0UGFnZVN0YXJ0LCBwb3NDdXJyZW50LCBzdGFydERpc3QsIHRoaXMuY3VycmVudERpc3RbaV0uaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJEaXN0ID0gdGhpcy5yaWdodCA/IC1jdXIuZGlzdGFuY2UgOiBjdXIuZGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgbGV0IHBhZ2VSaWdodCA9IGN1ci5wYWdlUmlnaHRcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3QucHVzaCh7ZGlzdDogY3VyRGlzdCwgaW5kZXg6IGRpc3RfaS5pbmRleCwgcmlnaHRQYWdlU3RhcnQ6IHJpZ2h0U3RhcnQsIHBhZ2VSaWdodDogcGFnZVJpZ2h0fSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpblBvcy5wdXNoKGN1cnJlbnRbaV0pXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IHRoaXMub3BwaXNpdGVEaXIoIHBvc0N1cnJlbnQsIHN0YXJ0RGlzdClcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3QgPSB0aGlzLnJpZ2h0ICYmIGRpc3RhbmNlID4gMCA/IC1kaXN0YW5jZSA6IGRpc3RhbmNlXG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0LnB1c2goe2Rpc3Q6IGRpc3QsIGluZGV4OiBkaXN0X2kuaW5kZXgsIHJpZ2h0UGFnZVN0YXJ0OiBkaXN0X2kucmlnaHRQYWdlU3RhcnQsIHBhZ2VSaWdodDogZmFsc2V9KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luUG9zLnB1c2goY3VycmVudFtpXSlcbiAgICAgICAgICAgICAgICB9ICAgICAgXG4gICAgICAgICAgICAvL0NsaWNrZWQgc2FtZSBkaXJlY3Rpb25cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIC8vQWZ0ZXIgZWxlbWVudCBzdGFydHMgZnJvbSBoaWRkZW4gcGFydCBvZiBwYWdlXG4gICAgICAgICAgICAgICAgaWYoKCB0aGlzLnJpZ2h0ICYmIHJpZ2h0UGFnZVN0YXJ0ICYmIGN1cnJlbnRbaV0gPCAwKSB8fCB0aGlzLmxlZnQgJiYgY3VycmVudFtpXSA+IDAgJiYgcmlnaHRQYWdlU3RhcnQgICl7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlc3NUaGFuID0gZGlzdF9pLmluZGV4IC8vaGF2ZSB0byB1cGRhdGUgcmlnaHRQYWdlU3RhcnQgYWdhaW4gZHVlIHRvIHJ1bm5pbmcgdGhpcy5nZXREaXN0YW5jZSgpIHR3aWNlXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IGQgLyAyIC0gKCByaWdodFBhZ2VTdGFydCAtIHBvc0N1cnJlbnQgKSAgXG4gICAgICAgICAgICAgICAgICAgIGxldCBQb3NPck5lZ0Rpc3RhbmNlID0gdGhpcy5yaWdodCAmJiBkaXN0YW5jZSA+IDAgPyBkaXN0YW5jZSAqIC0xOiBkaXN0YW5jZVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdC5wdXNoKHtkaXN0OiBQb3NPck5lZ0Rpc3RhbmNlLCBpbmRleDogZGlzdF9pLmluZGV4LCByaWdodFBhZ2VTdGFydDogZGlzdF9pLnJpZ2h0UGFnZVN0YXJ0LCBwYWdlUmlnaHQ6IGZhbHNlfSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5iZWdpblBvcy5wdXNoKGN1cnJlbnRbaV0pXG4gICAgICAgICAgICAgICAgfWVsc2V7ICBcbiAgICAgICAgICAgICAgICAgICAgbGV0IGxlc3NUaGFuaGFsZiA9IHN0YXJ0RGlzdCA8IHBvc0N1cnJlbnQgfHwgKHN0YXJ0RGlzdCAmJiBwb3NDdXJyZW50IDwgZCkgPyB0cnVlIDogZmFsc2UgIFxuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSBsZXNzVGhhbmhhbGYgPyB0aGlzLmxlc3NUaGFuSGFsZiggcG9zQ3VycmVudCwgZGlzdF9pLCBzdGFydERpc3QpIDogdGhpcy5tb3JlVGhhbkhhbGYoIGQsIHBvc0N1cnJlbnQsIHN0YXJ0RGlzdCApICAgIFxuICAgICAgICAgICAgICAgICAgICBsZXQgUG9zT3JOZWdEaXN0YW5jZSA9IHRoaXMucmlnaHQgPyAtZGlzdGFuY2UgOiBkaXN0YW5jZVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdC5wdXNoKHtkaXN0OiBQb3NPck5lZ0Rpc3RhbmNlLCBpbmRleDogZGlzdF9pLmluZGV4LCByaWdodFBhZ2VTdGFydDogZGlzdF9pLnJpZ2h0UGFnZVN0YXJ0LCBwYWdlUmlnaHQ6IHRydWV9KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luUG9zLnB1c2goY3VycmVudFtpXSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy9SZW1vdmVzIHByaW9yIHZhbHVlcyBpbiBhcnJheXNcbiAgICAgICAgdGhpcy5kaXN0LnNwbGljZSgwLDMpLCB0aGlzLmJlZ2luUG9zLnNwbGljZSgwLDMpXG4gICAgfVxuICAgIC8vVXBkYXRlcyBzbGlkZXJzIHBvc2l0aW9uc1xuICAgIHVwZGF0ZVBvcygpe1xuICAgICAgICAvLyBIYW5kbGVzIGJhY2sgYW5kIGZvcnRoIGNsaWNraW5nXG4gICAgICAgIGlmKHRoaXMuc3RhcnQpe1xuICAgICAgICAgICAgdGhpcy5zdGFydCA9IDBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RGlzdCA9IHRoaXMuZ2V0RGlzdGFuY2UoKVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QmVnaW5Qb3MgPSB0aGlzLnN0YXJ0UG9zKHRoaXMuc2xpZGVycylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZURvdWJsZUNsaWNrKHRoaXMuY3VycmVudCwgdGhpcy5kaXN0LCB0aGlzLmJlZ2luUG9zKVxuICAgICAgICAgICAgXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdGhpcy51cGRhdGVCZWx0UG9zKClcbiAgICAgICAgICAgIHRoaXMuYmVnaW5Qb3MubGVuZ3RoID0gMFxuICAgICAgICAgICAgdGhpcy5kaXN0Lmxlbmd0aCA9IDBcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSB0aGlzLmdldERpc3RhbmNlKClcbiAgICAgICAgICAgIGNvbnN0IGJlZ2luUG9zID0gdGhpcy5zdGFydFBvcyh0aGlzLnNsaWRlcnMpXG4gICAgICAgICAgICAvLyAzIGlzIGxlbmd0aCBvZiBzbGlkZXIgZWxlbWVudHNcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuYmVnaW5Qb3MucHVzaChiZWdpblBvc1tpXSlcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3QucHVzaChkaXN0W2ldKVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmRyYXcpXG4gICAgICAgIH1cbiAgICB9XG4gICAgYW5pbWF0ZUJlbHRzKHRvcEdlYXJzLCBib3R0b21HZWFycyl7XG4gICAgICAgIF8oJ3RlZXRoLXdyYXBwZXItdG9wJykuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgkeyB0b3BHZWFycyB9cHgpYFxuICAgICAgICBfKCd0ZWV0aC13cmFwcGVyLWJvdHRvbScpLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHsgYm90dG9tR2VhcnMgfXB4KWBcbiAgICB9XG5cbiAgICBhbmltYXRlKHNsaWRlcnMsIGltZ0dyb3VwLCB2YWx1ZSl7XG4gICAgICAgIHNsaWRlcnMuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgkeyB2YWx1ZSB9cHgpYFxuICAgICAgICBpbWdHcm91cC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7IHZhbHVlIH1weClgXG4gICAgfVxuXG4gICAgZHJhdyh0aW1lc3RhbXApe1xuICAgICAgICBjb25zdCB0aW1lID0gdGhpcy50aW1lXG4gICAgICAgIGlmKCF0aGlzLnN0YXJ0KSB0aGlzLnN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgIHRoaXMucnVudGltZSA9IHRpbWVzdGFtcCAtIHRoaXMuc3RhcnQ7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4odGhpcy5ydW50aW1lIC8gdGltZSwgMSlcblxuICAgICAgICBsZXQgaiA9IHRoaXMubGVzc1RoYW5cbiAgICBcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgICAgXG4gICAgICAgICAgICBsZXQgbnVtID0gaSAhPT0gaiA/IGkgOiBqXG4gICAgICAgICAgICBsZXQgc2xpZGVycyA9IHRoaXMuc2xpZGVyc1tudW1dXG4gICAgXG4gICAgICAgICAgICBsZXQgaW1nR3JvdXAgPSB0aGlzLmZvcmVpbkdyb3VwW251bV1cbiAgICBcbiAgICAgICAgICAgIGxldCBiZWdpblBvcyA9IHRoaXMuYmVnaW5Qb3NbbnVtXVxuICAgICAgICAgICAgbGV0IGRpc3QgPSB0aGlzLmRpc3RbbnVtXS5kaXN0XG4gICAgICAgICAgICBsZXQgcmlnaHRTdGFydCA9IHRoaXMuZGlzdFtudW1dLnJpZ2h0UGFnZVN0YXJ0XG4gICAgICAgICAgICBsZXQgcGFnZVJpZ2h0ID0gdGhpcy5kaXN0W251bV0ucGFnZVJpZ2h0ICAgXG4gICAgICAgICAgICAvL1JpZ2h0IG9yIExlZnQgc2lkZSBlbGVtZW50IGFuaW1hdGUgdG8gb3RoZXIgc2lkZSBvZiBzY3JlZW5cbiAgICAgICAgICAgIGlmKG51bSA9PT0gaiAmJiBwYWdlUmlnaHQpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHByb2dyZXNzIDw9IC41KXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gYmVnaW5Qb3MgLSAoZGlzdCAqIHByb2dyZXNzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRbbnVtXSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZShzbGlkZXJzLCBpbWdHcm91cCwgdmFsdWUpXG4gICAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSByaWdodFN0YXJ0IC0gKCBkaXN0ICogKHByb2dyZXNzIC0gLjUpKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRbbnVtXSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZShzbGlkZXJzLCBpbWdHcm91cCwgdmFsdWUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBiZWdpblBvcyAtIChkaXN0ICogcHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50W251bV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0ZShzbGlkZXJzLCBpbWdHcm91cCwgdmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQmVsdHMgQW5pbWF0aW9uXG4gICAgICAgIGxldCB0b3BHZWFycyA9IHRoaXMuYmVsdFBvcy5zdGFydFBvc1swXSArICh0aGlzLmJlbHRQb3MuZGlzdCAqIHByb2dyZXNzKSBcbiAgICAgICAgbGV0IGJvdHRvbUdlYXJzID0gdGhpcy5iZWx0UG9zLnN0YXJ0UG9zWzFdIC0gKHRoaXMuYmVsdFBvcy5kaXN0ICogcHJvZ3Jlc3MpXG4gICAgICAgIHRoaXMuYW5pbWF0ZUJlbHRzKHRvcEdlYXJzLCBib3R0b21HZWFycylcbiAgICAgICAgaWYocHJvZ3Jlc3MgPCAxKXtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmRyYXcpXG4gICAgICAgIH0gZWxzZXtcbiAgICAgICAgICAgIHRoaXMuZm9yZWluT2JqQXJyKClcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSAwXG4gICAgICAgICAgICB0aGlzLmJlbHRDbGljayArK1xuICAgICAgICAgICAgdGhpcy5jbGljayA9IDBcbiAgICAgICAgICAgIGltZ0lubGFyZ2UudGFyZ2V0RWxlbSgpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfSBcbiAgICB9XG4gICAgLy9TdGFycyBnZWFycyBpbmxpbmUgbGVmdCBvciByaWdodCBkZXBlbmRpbmcgb24gbGVmdCBvciByaWdodCBjbGlja1xuICAgIGJlbHREaXJlY3Rpb25zKCl7XG4gICAgICAgIGxldCBiZWx0V2lkdGggPSBfKCdib3R0b20tbWFpbicpLmdldEJCb3goKS53aWR0aFxuXG4gICAgICAgIGlmKHRoaXMucmlnaHQpe1xuICAgICAgICAgICAgXygnYm90dG9tLXRlZXRoJykuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSggJHtiZWx0V2lkdGh9cHggKWBcbiAgICAgICAgICAgIF8oJ3RvcC10ZWV0aCcpLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoICR7LWJlbHRXaWR0aH1weCApYFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIF8oJ2JvdHRvbS10ZWV0aCcpLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoICR7LWJlbHRXaWR0aH1weCApYFxuICAgICAgICAgICAgXygndG9wLXRlZXRoJykuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSggJHtiZWx0V2lkdGh9cHggKWBcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVCZWx0UG9zKCl7XG4gICAgICAgIGxldCBiZWx0cyA9IHRoaXMuc3RhcnRQb3ModGhpcy5iZWx0cylcbiAgICAgICAgbGV0IHN0YXJ0UG9zLCBkaXN0OyBcblxuICAgICAgICAgICAgLy8gU3RhcnRzIGdlYXJzIG9uIG9uZSBzaWRlIG9mIHRoZSBwYWdlIG9yIHRoZSBvdGhlciBcbiAgICAgICAgaWYoIHRoaXMuYmVsdENsaWNrID09PSAwIHx8IHRoaXMuYmVsdENsaWNrICYmIGJlbHRzWzBdID09PSAwICkgdGhpcy5iZWx0RGlyZWN0aW9ucygpXG5cbiAgICAgICAgaWYodGhpcy5yaWdodCl7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGJlbHRzXG4gICAgICAgICAgICBkaXN0ID0gXygndG9wLXRlZXRoJykuZ2V0QkJveCgpLndpZHRoIC8gM1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMubGVmdCl7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGJlbHRzXG4gICAgICAgICAgICBkaXN0ID0gLSggXygndG9wLXRlZXRoJykuZ2V0QkJveCgpLndpZHRoIC8gMyApXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vS2VlcHMgR2VhcnMgYWx3YXlzIGxvb2tpbmcgbGlrZSB0aGVpciBuZXZlciBlbmRpbmdcbiAgICAgICAgaWYoIHRoaXMuYmVsdENsaWNrID09PSAzKXtcbiAgICAgICAgICAgIHRoaXMuYmVsdENsaWNrID0gMFxuICAgICAgICAgICAgdGhpcy5hbmltYXRlQmVsdHMoMCwgMClcbiAgICAgICAgICAgIHRoaXMuYmVsdERpcmVjdGlvbnMoKVxuICAgICAgICAgICAgc3RhcnRQb3MgPSBbMCwwXVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYmVsdFBvcyA9IHtkaXN0LCBzdGFydFBvc31cbiAgICB9IFxufVxuXG5jbGFzcyBJbkxhcmdlSW1nIGV4dGVuZHMgUm9sbGVyVW5pdCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgc3VwZXIoKVxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9ICBfKCdpbWctaW5sYXJnZS1jb250YWluZXInKVxuICAgICAgICB0aGlzLmFuaW1hdGVDbGlwUGF0aCA9IHRoaXMuYW5pbWF0ZUNsaXBQYXRoLmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5pbWcgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuaW5sYXJnZS1pbWctd3JhcCBpbWcnKVxuICAgICAgICB0aGlzLmltZ1dyYXAgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdpbmxhcmdlLWltZy13cmFwJylbMF1cbiAgICAgICAgdGhpcy5tb3VzZU1vdmUgPSB0aGlzLm1vdXNlTW92ZS5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIgPSB0aGlzLnJlbW92ZUxpc3RlbmVyLmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5tb3VzZVkgPSAwXG4gICAgICAgIHRoaXMuaW1hZ2VDbG9zZSA9IHRoaXMuaW1hZ2VDbG9zZS5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMudGFyZ2V0RWxlbSA9IHRoaXMudGFyZ2V0RWxlbVxuICAgICAgICB0aGlzLmNoZWNrRm9yRHVwbGljYXRlcyA9IHRoaXMuY2hlY2tGb3JEdXBsaWNhdGVzXG4gICAgICAgIHRoaXMubW92ZUVsZW1lbnQgPSB0aGlzLm1vdmVFbGVtZW50XG4gICAgICAgIHRoaXMuWSA9IDBcbiAgICB9XG4gICAgXG4gICAgYWRkQ2xpY2tMaXN0ZW5lcigpe1xuICAgICAgICBjb25zb2xlLmxvZygnbGlzdGVuZXIgYWRkZWQnKVxuICAgICAgICBfKCdpbWctaW5sYXJnZS1jb250YWluZXInKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaW1hZ2VDbG9zZSk7IFxuICAgIH1cbiAgICByZW1vdmVDbGlja0xpc3RlbmVyKCl7XG4gICAgICAgIGNvbnNvbGUubG9nKCdyZW1vdmVkIGNsaWNrIGxpc3RlbmVyJylcbiAgICAgICAgXygnaW1nLWlubGFyZ2UtY29udGFpbmVyJykucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmltYWdlQ2xvc2UpOyBcbiAgICB9XG4gICAgY2hlY2tGb3JEdXBsaWNhdGVzKGNsc3NOYW1lKXtcbiAgICAgICAgY29uc3QgaW1ncyA9IHRoaXMuaW1nV3JhcC5jaGlsZHJlblxuICAgICAgICBsZXQgbGVuZ3RoID0gaW1ncy5sZW5ndGhcbiAgICAgICAgd2hpbGUobGVuZ3RoLS0pe1xuICAgICAgICAgICAgaWYgKCBpbWdzW2xlbmd0aF0uY2xhc3NOYW1lID09PSBjbHNzTmFtZSApe1xuICAgICAgICAgICAgICAgIHRoaXMuaW1nID0gaW1nc1tsZW5ndGhdO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlSW1nKClcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy9SZWN1cnNpb25cbiAgICB0YXJnZXRFbGVtKGVsZW1YKXtcbiAgICAgICAgXG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmZvcmVpbk9ianMubGVuZ3RoXG4gICAgICAgIGxldCBhcnIgPSBbXVxuICAgICAgICBsZXQgZ3JvdXBBcnIgPSBbXVxuICAgICAgIFxuICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0gKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gMXN0IHB1c2hlcyBvbmx5IGVsZW1lbnRzIHdpdGggc3R5bGUgYXR0cmlidHVlcyBvZiB4XG4gICAgICAgICAgICBpZighZWxlbVggJiYgdGhpcy5mb3JlaW5PYmpzW2ldLmhhc0F0dHJpYnV0ZSgneCcpICl7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYXJyLnB1c2goIHRoaXMuZm9yZWluT2Jqc1tpXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS54IClcbiAgICAgICAgICAgICAgICBncm91cEFyci5wdXNoKHRoaXMuZm9yZWluT2Jqc1tpXS5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2NhbGluZyBpbWFnZSBvbmx5XG4gICAgICAgICAgICBpZiAoIHRoaXMuZm9yZWluT2Jqc1tpXS5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnggPT09IGVsZW1YICYmIHRoaXMudG9nZ2xlTW92ZUVsZW1lbnQpe1xuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAgPSB0aGlzLmZvcmVpbk9ianNbaV0ucGFyZW50Tm9kZVxuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCB0aGlzLmZvcmVpbk9ianNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkueCA9PT0gZWxlbVggKXtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrRm9yRHVwbGljYXRlcygnd2ViVmlzaWJsZScpXG4gICAgICAgICAgICAgICAgbGV0IGltZ05vZGUgPSB0aGlzLmZvcmVpbk9ianNbaV0uY2hpbGROb2Rlc1sxXTtcbiAgICAgICAgICAgICAgICBsZXQgY2xvbmVkSW1nID0gaW1nTm9kZS5jbG9uZU5vZGUodHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tb3ZlRWxlbWVudCggY2xvbmVkSW1nLCAnd2ViVmlzaWJsZScgKSAgXG4gICAgICAgICAgICB9IFxuICAgICAgICB9XG4gICAgICAgIC8vIE1pZGRsZSBlbGVtZW50IHdoaWNoIGlzIHRoZSBtZWRpYW4gb2YgdGhlIHRocmVlIGVsZW1lbnRzXG4gICAgICAgIGxldCBzb3J0ZWQgPSBhcnIuc29ydCggKGEsYikgPT4gYSAtIGIgKVsxXVxuICAgICAgICB0aGlzLnRhcmdldEVsZW0oc29ydGVkKVxuICAgIH1cbiAgICBpbnNlcnRUZXh0KGltZyl7XG4gICAgICAgIGxldCBpbWdDb250ZW50ID0gXygnaW1nLWNvbnRlbnQnKVxuICAgICAgICBsZXQgdXJsID0gaW1nLmF0dHJpYnV0ZXNbMl0udmFsdWVcbiAgICAgICAgbGV0IHRleHQgPSBpbWcuYXR0cmlidXRlc1sxXS50ZXh0Q29udGVudFxuICAgICAgICBpbWdDb250ZW50LnRleHRDb250ZW50ID0gdGV4dFxuICAgICAgICBpbWdDb250ZW50LmlubmVySFRNTCArPSAnPGJyPicrJzxhIGhyZWY9XCInICsgdXJsICsgJ1wiPiAnICsgdXJsICsgJyA8L2E+JysnPC9icj4nXG4gICAgfVxuICAgIG1vdmVFbGVtZW50KGVsLCBjbHMpe1xuICAgICAgICB0aGlzLmltZyA9IGVsIC8vdXBkYXRlcyBpbWFnZSB0byBiZSB1c2VkIGVsc2V3aGVyZSBcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHMpXG4gICAgICAgIGxldCBpbWdfY29udGVudCA9IF8oJ2ltZy1jb250ZW50JylcbiAgICAgICAgbGV0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChlbClcbiAgICAgICAgdGhpcy5pbWdXcmFwLmluc2VydEJlZm9yZShmcmFnbWVudCwgaW1nX2NvbnRlbnQpO1xuICAgICAgICB0aGlzLmltZ1dyYXAuY2xhc3NMaXN0LmFkZCgnc2hvdy1pbWcnKVxuICAgICAgICB0aGlzLmltZ1dyYXAuY2xhc3NMaXN0LnJlbW92ZSgnaGlkZS1pbWcnKVxuICAgIH1cblxuICAgIHJlbW92ZUltZyhlKXtcbiAgIFxuICAgICAgICAvL09ubHkgcmFuIHRvIGV4aXQgb3V0IG9mIGltYWdlIGZyb20gY2xpY2sgaGFuZGxlclxuICAgICAgICBpZihlKXtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAwXG4gICAgICAgICAgICB0aGlzLmltZ1dyYXAuY2xhc3NMaXN0LnJlcGxhY2UoJ3Nob3ctaW1nJywgJ2hpZGUtaW1nJylcbiAgICAgICAgICAgIHNldFRpbWVvdXQoICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmltZ1dyYXAuY2xhc3NMaXN0LnJlcGxhY2UoJ2hpZGUtaW1nJywgJ3Nob3ctaW1nJylcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJylcbiAgICAgICAgICAgICAgICB0aGlzLmltZy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnXG4gICAgICAgICAgICB9LDExMDApXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBfKCdpbWctY29udGVudCcpLnRleHRDb250ZW50ID0gJydcbiAgICAgICAgICAgIHRoaXMuaW1nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5pbWcpXG4gICAgIFxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZXMgaW1hZ2VzIFxuICAgIGltYWdlQ2xvc2UoZSl7XG4gICAgICAgY29uc29sZS5sb2coIGUudGFyZ2V0LnRhZ05hbWUpXG4gICAgICAgIFxuICAgICAgICBpZihlLnRhcmdldC50YWdOYW1lICE9PSAnSU1HJyl7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNsaWNrTGlzdGVuZXIoKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmVJbWcoZSlcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEaXNwbGF5cyBpbWFnZVxuICAgIHNob3dJbWFnZShjbHNzTmFtZSl7XG4gICAgICAgIHRoaXMuaW1nID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbHNzTmFtZSlbMF1cbiAgICAgICAgdGhpcy5pbnNlcnRUZXh0KHRoaXMuaW1nKVxuICAgICAgICB0aGlzLmltZy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgICAgICB0aGlzLmFkZENsaWNrTGlzdGVuZXIoKVxuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPSAxXG4gICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAqKiAgUkVNT1ZFIEFOSU1BVEVDTElQUEFUSCBJRiBJIERPTidUIFJFQUxMTFkgSEFWRSBUTyBVU0UgSVQgRk9SIEZJUkVGT1ggKipcbiAgICAvL0ZpcmVmb3ggb25seVxuICAgIGFuaW1hdGVDbGlwUGF0aCh0aW1lc3RhbXApe1xuICAgICAgICBpZighdGhpcy5zdGFydCkgdGhpcy5zdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICB0aGlzLnJ1bnRpbWUgPSB0aW1lc3RhbXAgLSB0aGlzLnN0YXJ0O1xuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWluKHRoaXMucnVudGltZSAvIDEwMDAsIDEpXG4gICAgICAgIHRoaXMuaW1nV3JhcC5zdHlsZS5jbGlwUGF0aCA9IGBjaXJjbGUoJHt0aGlzLmNsaXBTdGFydCArICh0aGlzLmNsaXBWYWx1ZSAqIHByb2dyZXNzKX0lKWBcbiAgICBcbiAgICAgICAgaWYocHJvZ3Jlc3MgPCAxKXtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGVDbGlwUGF0aClcbiAgICAgICAgfWVsc2Uge1xuXG4gICAgICAgICAgICBpZih0aGlzLmNvbnRhaW5lci5zdHlsZS5vcGFjaXR5ID09IDApe1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmVzIGZsZXggYW5kIG9wYWNpdHksIHNldHMgYmFjayB0byBkaXNwbGF5IG5vbmVcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJylcbiAgICAgICAgICAgICAgICAvLyB0aGlzLmltZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuaW1nKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGFydCA9IDBcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUcmFuc2Zvcm0oKXtcbiAgICAgICAgbGV0IHJlZ0V4ID0gL15zY2FsZS9nO1xuICAgICAgICBsZXQgdHJhbnNmb3JtID0gdGhpcy5ncm91cC5zdHlsZS50cmFuc2Zvcm0ucmVwbGFjZSgvXihcXHcqXFwoLT9cXGQqLlxcdypcXCkpKC4qKS9pZywgXCIkMVwiKVxuICAgICAgICBsZXQgY2hlY2tGb3JTY2FsZSA9IHRyYW5zZm9ybS5tYXRjaChyZWdFeClcbiAgICAgICAgLy9TbyB0d28gc2NhbGUgdmFsdWVzIGRvbid0IGdldCBhZGRlZCB0byBlbGVtZW50IHdoZW4gdHJhbnNsYXRlIGRvZXNuJ3QgZXhpc3RcbiAgICAgICAgaWYoY2hlY2tGb3JTY2FsZSl7XG4gICAgICAgICAgICByZXR1cm4gJydcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2NhbGVQaG90byhkaXN0LCBzY2FsZSwgdHJhbnNsYXRlKXtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NsaWRlcl8xXycpLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVZKCR7ZGlzdH1weClgXG4gICAgICAgIHRoaXMuZ3JvdXAuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNsYXRlICsgYHNjYWxlKCAkezEgKyBzY2FsZX0gKWBcbiAgICB9XG4gICAgXG4gICAgbW91c2VNb3ZlKGUpe1xuICAgICAgICAvLyBtdWx0aXB5IGJ5IDEuNSBiZWNhdXNlIG9mIHRoZSBsYWcsIHNvIEkgc3BlZWQgaXQgdXAganVzdCBhIGJpdFxuICAgICAgICBsZXQgZGlzdCA9IGUuY2xpZW50WSAtIHRoaXMubW91c2VZXG4gICAgICAgIGxldCB2YWx1ZSA9ICAgZGlzdCAvIHRoaXMuWVxuICAgICAgICBsZXQgc2NhbGUgPSBNYXRoLm1pbiggdmFsdWUgPCAwID8gLXZhbHVlIDogLXZhbHVlLCAxKVxuICAgICAgICBsZXQgdHJhbnNsYXRlID0gdGhpcy5nZXRUcmFuc2Zvcm0oKSBcbiAgICAgICAgbGV0IHRyYW5zbGF0ZVZhbHVlID0gKyggdHJhbnNsYXRlLnJlcGxhY2UoL1teLVxcZC5dL2lnLCBcIlwiKSApXG4gIFxuICAgICAgICAvL0NoZWNrcyBpZiBlbGVtZW50IGlzIGVpdGhlciAtNDMxIG9yIDQzMSBzbyB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gb3JpZ2luIGNhbiBiZSBhZGRlZFxuICAgICAgICBpZih0cmFuc2xhdGVWYWx1ZSA+IDIpe1xuICAgICAgICAgICAgdGhpcy5ncm91cC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAxNjUgKyBcInB4IFwiICsgNDUwICsgXCJweFwiXG4gICAgICAgIH1lbHNlIGlmKHRyYW5zbGF0ZVZhbHVlIDwgLTEpe1xuICAgICAgICAgICAgdGhpcy5ncm91cC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAxMDM0ICsgXCJweCBcIiArIDQ1OCArIFwicHhcIlxuICAgICAgICB9XG4gICAgICAgIC8vc2NhbGUgaXMgMSB3aGVuIGNsaWNrZWQgc29tZXdoZXJlIGVsc2VcbiAgICAgICAgaWYoIHNjYWxlIDwgMSAmJiBkaXN0IDw9IDYgKSB0aGlzLnNjYWxlUGhvdG8oZGlzdCwgc2NhbGUsIHRyYW5zbGF0ZSlcbiAgICB9XG5cbiAgICBtb3VzZURvd24oZSl7XG4gICAgICAgIFxuICAgICAgICBfKCdzbGlkZS1ncm91cCcpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLnJlbW92ZUxpc3RlbmVyLCB0cnVlKVxuXG4gICAgICAgIHRoaXMudG9nZ2xlTW92ZUVsZW1lbnQgPSB0cnVlXG4gICAgICAgIHRoaXMudGFyZ2V0RWxlbSgpXG4gICAgICAgIGxldCB2ZXJQaWVjZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2ZXJ0X3BpZWNlJylcbiAgICAgICAgbGV0IHZlcnRZID0gdmVyUGllY2UuZ2V0QkJveCgpLnlcbiAgICAgICAgbGV0IGhhbmRsZVkgPSBfKCdpbWctc2NhbGUnKS5nZXRCQm94KCkueSAgICBcblxuICAgICAgICAvL0dldHMgZGlzdGFuY2Ugc2xpZGVyIG5lZWRzIHRvIGdvICBcbiAgICAgICAgdGhpcy5ZID0gaGFuZGxlWSAtIHZlcnRZXG4gICAgICAgIFxuICAgICAgICAvL1N0YXJ0IHBvc2l0aW9uIGZvciBkaXN0YW5jZVxuICAgICAgICBpZighdGhpcy5tb3VzZVkpIHRoaXMubW91c2VZID0gZS5jbGllbnRZXG4gICAgICAgIF8oJ3NsaWRlLWdyb3VwJykuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZU1vdmUsIHRydWUpXG4gICAgICAgXG4gICAgfVxuXG4gICAgcmVtb3ZlTGlzdGVuZXIoZSl7XG4gICAgICAgIF8oJ3NsaWRlLWdyb3VwJykucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5tb3VzZU1vdmUsIHRydWUpXG4gICAgICAgIFxuICAgICAgICBsZXQgdHJhbnNsYXRlID0gdGhpcy5nZXRUcmFuc2Zvcm0oKVxuICAgICAgICB0aGlzLnNjYWxlUGhvdG8oMCwwLHRyYW5zbGF0ZSlcbiAgICAgICAgXG4gICAgICAgIF8oJ3NsaWRlLWdyb3VwJykucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMucmVtb3ZlTGlzdGVuZXIsIHRydWUpXG4gICAgICAgIF8oJ2ltZy1zY2FsZScpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2VEb3duLCB0cnVlKTtcblxuICAgICAgICAvL1VwZGF0ZXMgcG9zaXRpb24gd2hlbiBtb3VzZVVwXG4gICAgICAgIHRoaXMubW91c2VZID0gMFxuICAgICAgICB0aGlzLnRvZ2dsZU1vdmVFbGVtZW50ID0gZmFsc2VcbiAgICB9XG59XG5cbmxldCByb2xsZXJVbml0ID0gbmV3IFJvbGxlclVuaXQoKTtcbmxldCBpbWdJbmxhcmdlID0gbmV3IEluTGFyZ2VJbWcoKTtcbnJvbGxlclVuaXQucG9zaXRpb25Gb3JpZWduT2JqZWN0KGltZ0lubGFyZ2UpO1xuXG5fKCdpbWctc2NhbGUnKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCAoZSkgPT4ge1xuICAgIGltZ0lubGFyZ2UubW91c2VEb3duKGUpXG59LCB0cnVlKTtcblxuXygnYnV0dG9ucycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxmdW5jdGlvbihlKXtcbiAgICBcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQucGFyZW50RWxlbWVudC5jbGFzc0xpc3RbMF1cblxuICAgIGlmKHRhcmdldCA9PT0gJ2ltZy1sZWZ0JyB8fCB0YXJnZXQgPT09ICdpbWctcmlnaHQnKXtcbiAgICAgICAgaWYocm9sbGVyVW5pdC5jbGljayA9PT0gMSkgcmV0dXJuICBcbiAgICAgICAgXG4gICAgICAgIHJvbGxlclVuaXQubGVmdCA9IHRhcmdldCA9PT0gJ2ltZy1sZWZ0JyA/IHRydWUgOiBmYWxzZVxuICAgICAgICByb2xsZXJVbml0LnJpZ2h0ID0gdGFyZ2V0ID09PSAnaW1nLXJpZ2h0JyA/IHRydWUgOiBmYWxzZVxuICAgICAgICByb2xsZXJVbml0LnVwZGF0ZVBvcygpXG5cbiAgICB9ZWxzZSBpZih0YXJnZXQgPT09ICdpbWctaW5sYXJnZScpe1xuICAgICAgICBpbWdJbmxhcmdlLnNob3dJbWFnZSgnd2ViVmlzaWJsZScpXG4gICAgfVxufSk7XG5cbl8oJ2J1dHRvbi1pbmxhcmdlJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgIGltZ0lubGFyZ2Uuc2hvd0ltYWdlKCdkZXNpZ25WaXNpYmxlJylcbn0pXG5cbi8vICoqKiogR1JBUEggU0VDVElPTiAqKioqXG5cbmNvbnN0IHJhbmRvbSA9IChtaW4sIG1heCkgPT4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xuXG5jb25zdCB0b2dnbGVSb2JvdCA9IHtcbiAgICB0b2dnbGU6IGZhbHNlLFxuICAgIGZsaWdodDogZmFsc2UsIC8vVG9nZ2xlcyB3aGVuIHNjcm9sbGVkIG91dCBvZiBzY3JlZW4gdmlld1xuICAgIGRpcmVjdGlvbjogJ3VwJ1xufVxuXG5mdW5jdGlvbiBzdGFydFJvYm90RmxpZ2h0KCl7IFxuICAgIC8vICoqKiBCdXJuZXJzICoqKlxuXG4gICAgY29uc3QgZmxhbWVzID0gXygncm9ib3QtZmxhbWUnKVxuICAgIGNvbnN0IGxlbmd0aCA9IGZsYW1lcy5sZW5ndGhcblxuICAgIGNvbnN0IGZyb20gPSB7eDogMSwgeTogMX1cbiAgICBjb25zdCB0byA9IHt9XG4gICAgY29uc3QgZGlzdGFuY2UgPSB7fTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgICBjb25zdCBuZXh0ID0gdGltZXN0YW1wID0+IHtcbiAgICAgICAgLy9zdGFydHMgYWxsIG92ZXIgZnJvbSBnZXRzIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBsYXN0IHNpemVcbiAgICAgICAgT2JqZWN0LmFzc2lnbihmcm9tLCB0byk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBheGlzID0ga2V5c1tpXVxuICAgICAgICAgICAgdG9bYXhpc10gPSByYW5kb20oLjgsIDEpO1xuICAgICAgICAgICAgZGlzdGFuY2VbYXhpc10gPSBmcm9tW2F4aXNdIC0gdG9bYXhpc107XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lLnN0YXJ0ID0gdGltZXN0YW1wO1xuICAgIH07XG5cbiAgICBjb25zdCB0aW1lID0ge1xuICAgICAgICB0b3RhbDogNDBcbiAgICB9O1xuXG4gICAgY29uc3QgZHJhd0J1cm5lcnMgPSB0aW1lc3RhbXAgPT4ge1xuICAgICAgICBpZiAodG9nZ2xlUm9ib3QuZmxpZ2h0KSByZXR1cm5cbiAgICAgICAgaWYgKHRpbWUucnVudGltZSA+IHRpbWUudG90YWwgfHwgIXRvLngpIG5leHQodGltZXN0YW1wKTtcblxuICAgICAgICB0aW1lLnJ1bnRpbWUgPSB0aW1lc3RhbXAgLSB0aW1lLnN0YXJ0O1xuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IHRpbWUucnVudGltZSAvIHRpbWUudG90YWw7XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IGtleXMubWFwKGF4aXMgPT4gZnJvbVtheGlzXSAtIHByb2dyZXNzICogZGlzdGFuY2VbYXhpc10pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZmxhbWUgPSBmbGFtZXNbaV1cbiAgICAgICAgICAgIGZsYW1lLnN0eWxlLnRyYW5zZm9ybSA9IGBzY2FsZSgke3h9LCAke3l9KWA7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXdCdXJuZXJzKTtcbiAgICB9O1xuXG5cbiAgICAvLyoqKiBEcmF3cyBTdGFycyAqKipcbiAgICBsZXQgZ3JhcGhzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZ3JhcGgtc3QyMCcpXG4gICAgY29uc3QgcmVjQ2xpcCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3JlYy1jbGlwJylbMF1cbiAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBjb25zdCByb2JvdFJlY3QgPSBfKCdmbG9hdGluZ19yb2JvdCcpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgZ3JhcGggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ3JhcGgtc3ZnJylcbiAgICBjb25zdCBbc2l6ZV0gPSAvWzEtOV0uKi8uZXhlYyggZ3JhcGguZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykgKVxuICAgIFxuICAgIGNvbnN0IHJlZ0V4ID0gLyhbMS05Ll0qKVxccyhbMS05Ll0uKikvaWc7XG4gICAgY29uc3QgZ3JhcGhXaWR0aCA9IHNpemUucmVwbGFjZShyZWdFeCwgJyQxJylcbiAgICBjb25zdCBncmFwaEhlaWdodCA9IHNpemUucmVwbGFjZShyZWdFeCwgJyQyJylcbiAgICBcbiAgICBjb25zdCByb2JvdEhlaWdodCA9IHJvYm90UmVjdC5oZWlnaHQ7XG4gICAgY29uc3Qgcm9ib3RXaWR0aCA9IHJvYm90UmVjdC53aWR0aDtcbiAgICBjb25zdCBzdGFydFkgPSBncmFwaEhlaWdodCAtIHJvYm90SGVpZ2h0XG4gICAgY29uc3Qgc3RhcnRYID0gcm9ib3RSZWN0LnggLSAod2luZG93LmlubmVyV2lkdGggLSBncmFwaFdpZHRoKSAvIDJcblxuICAgIC8vc3RhcnRzIHN0YXJzIHJhbmRvbWx5XG4gICAgY29uc3QgcmFuZG9tSW50ZXJ2YWwgPSBmdW5jdGlvbihjYWxsYmFjayxkYXRhLG1pbiwgbWF4KXtcblxuICAgICAgICBjb25zdCB0aW1lID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgdG90YWw6IHJhbmRvbShtaW4sIG1heClcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZHJhdyA9ICh0aW1lc3RhbXApID0+e1xuICAgICAgICAgICAgaWYodG9nZ2xlUm9ib3QuZmxpZ2h0KSByZXR1cm5cbiAgICAgICAgICAgIGlmICh0aW1lLnRvdGFsIDw9IHRpbWVzdGFtcCAtIHRpbWUuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aW1lLnN0YXJ0ID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIHRpbWUudG90YWwgPSByYW5kb20obWluLCBtYXgpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhdyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXcpO1xuICAgIH07XG5cbiAgICBjb25zdCBjcmVhdGVTdGFyID0gKGN4LCBjeSwgcmFkaXVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImNpcmNsZVwiKTtcbiAgICAgICAgc3Rhci5zZXRBdHRyaWJ1dGUoXCJyXCIsIHJhZGl1cyk7XG4gICAgICAgIHN0YXIuc2V0QXR0cmlidXRlKFwiY3lcIiwgY3kpO1xuICAgICAgICBzdGFyLnNldEF0dHJpYnV0ZShcImN4XCIsIGN4KTtcbiAgICAgICAgc3Rhci5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwid2hpdGVcIik7XG4gICAgICAgIHN0YXIuc2V0QXR0cmlidXRlKFwiZmlsbC1vcGFjaXR5XCIsIDApO1xuICAgICAgICByZXR1cm4gc3RhcjtcbiAgICB9O1xuXG4gICAgY29uc3QgRmFsbGluZ1N0YXJzID0gZnVuY3Rpb24oZGF0YSl7XG5cbiAgICAgICAgbGV0IGF0dHIgPSBuZXcgZGF0YSh0b2dnbGVSb2JvdC5kaXJlY3Rpb24pXG5cbiAgICAgICAgY29uc3QgcmFkaXVzID0gYXR0ci5yYWRpdXNcbiAgICAgICAgY29uc3QgY3ggPSBhdHRyLmN4XG4gICAgICAgIGNvbnN0IGN5ID0gYXR0ci5jeVxuICAgICAgICBjb25zdCBkaXN0ID0gYXR0ci5kaXN0XG4gICAgICAgIGNvbnN0IHN0YXIgPSBjcmVhdGVTdGFyKGN4LCBjeSwgcmFkaXVzKVxuICAgICAgIFxuICAgICAgICBjb25zdCB0aW1lID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgdG90YWw6IHJhbmRvbSgxOTAwLCAyMDAwKVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZHJhdyA9ICh0aW1lc3RhbXApID0+IHtcbiAgICAgICAgICBpZih0b2dnbGVSb2JvdC50b2dnbGUgfHwgdG9nZ2xlUm9ib3QuZmxpZ2h0KXtcbiAgICAgICAgICAgICAgICBncmFwaC5yZW1vdmVDaGlsZChzdGFyKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB0aW1lLmVsYXBzZWQgPSB0aW1lc3RhbXAgLSB0aW1lLnN0YXJ0XG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWluKHRpbWUuZWxhcHNlZCAvIHRpbWUudG90YWwsIDEpXG4gICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBvcGFjaXR5ID0gcHJvZ3Jlc3MgKiAyXG5cbiAgICAgICAgICAgIHN0YXIuc2V0QXR0cmlidXRlKFwiY3lcIiwgY3kgKyBwcm9ncmVzcyAqIGRpc3QpXG4gICAgICAgICAgICBzdGFyLnNldEF0dHJpYnV0ZShcImZpbGwtb3BhY2l0eVwiLCBwcm9ncmVzcyA8IC41ID8gb3BhY2l0eSA6IDIgLSBvcGFjaXR5KVxuICAgICAgICAgICAgdGltZS5lbGFwc2VkIDwgdGltZS50b3RhbCA/IHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3KTogZ3JhcGgucmVtb3ZlQ2hpbGQoc3RhcilcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhdylcblxuICAgICAgICAvL0luc2VydHMgbmV3IHN0YXIgYmFzZWQgb24gcmFuZG9tSW50ZXJ2YWwgcnVuaW5nIHRocm91Z2hTdGFycygpXG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHN0YXIpXG4gICAgICAgIGdyYXBoLmluc2VydEJlZm9yZShmcmFnbWVudCwgZ3JhcGguZmlyc3RDaGlsZClcblxuICAgIH07XG5cbiAgICB2YXIgZmx5SW50b1BsYWNlID0ge1xuICAgICAgICBiZWdpblk6IGdyYXBoSGVpZ2h0IC0gcm9ib3RIZWlnaHQgLyAxMixcbiAgICAgICAgaGlkZGVuWDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGxldCBkaWZmZXJlbmNlID0gZ3JhcGhXaWR0aCAgLSAgd1dcbiAgICAgICAgICAgIGlmKCF3VyA8IGdyYXBoV2lkdGgpe1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvYm90UmVjdC53aWR0aCArIHJvYm90UmVjdC54ICsgZGlmZmVyZW5jZSBcbiAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoaWRlUm9ib3Q6IGZ1bmN0aW9uKHNpemUpe1xuICAgICAgICAgICAgaWYoIHNpemUgPT09IDEuMyl7XG4gICAgICAgICAgICAgICAgbGV0IGJlZ2luWCA9IHRoaXMuaGlkZGVuWCgpO1xuICAgICAgICAgICAgICAgIF8oJ2Zsb2F0aW5nX3JvYm90Jykuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgkezB9cHgsIC0ke3RoaXMuYmVnaW5ZfXB4KWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlU3RhcnM6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBsZXQgYXR0cmlidXRlcyA9IGZ1bmN0aW9uKGRpcmVjdGlvbil7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihkaXJlY3Rpb24gPT09ICdkb3duJyl7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlUm9ib3QudG9nZ2xlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYWRpdXMgPSByYW5kb20oLjUsIDIuNylcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN4ID0gcmFuZG9tKHN0YXJ0WCAtIDEwMCwgc3RhcnRYICsgcm9ib3RXaWR0aCArIDEwMClcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN5ID0gcmFuZG9tKHN0YXJ0WSAtIDEyMCAsc3RhcnRZIC0gMTc1IClcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3QgPSAxMDAgKyByb2JvdEhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByYWRpdXMsIGN4LCBjeSwgZGlzdCB9IFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZihkaXJlY3Rpb24gPT09ICd1cCcpe1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFkaXVzID0gcmFuZG9tKDEuNSwgMy43KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN4ID0gcmFuZG9tKDAgLSAyNSwgZ3JhcGhXaWR0aCArIDI1KVxuICAgICAgICAgICAgICAgICAgICBsZXQgY3kgPSByYW5kb20oZ3JhcGhIZWlnaHQgIC0gODAsIGdyYXBoSGVpZ2h0ICsgNTAgIClcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3QgPSAtZ3JhcGhIZWlnaHQ7IFxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJhZGl1cywgY3gsIGN5LCBkaXN0IH0gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9FdmVyeSA4MG1zIHRocm91Z2ggMTgwbXMgb2YgdGltZS50b3RhbCBpdCB3aWxsIGRyYXcgYSBzdGFyXG4gICAgICAgICAgICAvLyoqKiogU1RBUlRTIFNUQVJTIE1PVklORyAqKioqKlxuICAgICAgICAgICAgcmFuZG9tSW50ZXJ2YWwoRmFsbGluZ1N0YXJzLCBhdHRyaWJ1dGVzLDgwLCAxODApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBncmFwaERhdGEgPSB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICB0b3RhbDogMjAwMCxcbiAgICB9XG4gICAgY29uc3Qgc3VidHJhY3RSYXkgPSAoKSA9PiB7XG4gICAgICAgIF8oJ2xlZnQtdGV4dC1wYW5lbCcpLnJlbW92ZUF0dHJpYnV0ZSgnY2xpcC1wYXRoJylcbiAgICAgICAgXygncmVjLWNsaXAnKS5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZSg0ODVweCwgNTIwcHgpXCJcbiAgICB9XG4gICAgY29uc3QgZ2V0U3Ryb2tlTGVuZ3RoID0gKCkgPT4ge1xuICAgICAgICBsZXQgaSA9IGdyYXBocy5sZW5ndGhcbiAgICAgICAgbGV0IHZhbHVlID0gbmV3IEFycmF5KGkpXG4gICAgICAgIGZ1bmN0aW9uIGdldExlbmd0aCgpe1xuICAgICAgICAgICAgd2hpbGUoaS0tKXtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IGdyYXBoc1tpXS5nZXRUb3RhbExlbmd0aCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJ1blZhbHVlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGdldExlbmd0aCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0cm9rZUxlbmd0aCA9IGdldFN0cm9rZUxlbmd0aCgpO1xuICAgIHN0cm9rZUxlbmd0aC5ydW5WYWx1ZSgpO1xuICAgIFxuICAgIGNvbnN0IGRyYXdQZXJjZW50U3Ryb2tlID0gKHByb2dyZXNzKSA9PiB7XG4gICAgICAgIGxldCBzdHJva2UgPSBzdHJva2VMZW5ndGguZ2V0VmFsdWUoKVxuICAgICAgICBsZXQgaSA9IGdyYXBocy5sZW5ndGhcbiAgICAgICAgd2hpbGUoaS0tKXtcbiAgICAgICAgICAgIGdyYXBoc1tpXS5zdHlsZS5zdHJva2UgPSAndXJsKCNkZXNpZ24tZ3JhZGllbnQpJ1xuICBcbiAgICAgICAgICAgIGdyYXBoc1swXS5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gc3Ryb2tlWzBdICsgKHN0cm9rZVswXSAqIHByb2dyZXNzKVxuICAgICAgICAgICAgZ3JhcGhzWzFdLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSBzdHJva2VbMV0gLSAoc3Ryb2tlWzFdICogcHJvZ3Jlc3MpXG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYW5pbWF0ZUdyYXBoID0gKHRpbWVzdGFtcCkgPT4ge1xuICAgICAgICBpZighZ3JhcGhEYXRhLnN0YXJ0KSBncmFwaERhdGEuc3RhcnQgPSB0aW1lc3RhbXBcbiAgICAgICAgbGV0IHJ1bnRpbWUgPSB0aW1lc3RhbXAgLSBncmFwaERhdGEuc3RhcnRcbiAgICAgICAgbGV0IHByb2dyZXNzID0gTWF0aC5taW4ocnVudGltZSAvIGdyYXBoRGF0YS50b3RhbCwgMSlcblxuICAgICAgICBfKCdncmFwaC1wZXJjZW50YWdlLXRvcCcpLnRleHRDb250ZW50ID0gTWF0aC5yb3VuZCggMCArIDkwICogcHJvZ3Jlc3MpICsgJyAlJ1xuICAgICAgICBfKCdncmFwaC1wZXJjZW50YWdlLWJvdHRvbScpLnRleHRDb250ZW50ID0gTWF0aC5yb3VuZCggMCArIDcwICogcHJvZ3Jlc3MpICsgJyAlJ1xuICAgICAgICBfKCdncmFwaC1yZWN0Jykuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgKDQxMiAqIHByb2dyZXNzKSArICdweCknIFxuICAgICAgICBkcmF3UGVyY2VudFN0cm9rZShwcm9ncmVzcylcbiAgICAgICAgXG4gICAgICAgIGlmKHByb2dyZXNzIDwgMSkgXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZUdyYXBoKVxuICAgICAgICBlbHNlIFxuICAgICAgICAgICAgcmV0dXJuIHN1YnRyYWN0UmF5KClcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydEFuaW1hdGVHcmFwaCA9ICgpID0+e1xuICAgICAgICBpZiggXygncmVjLWNsaXAnKS5zdHlsZS50cmFuc2Zvcm0gKSByZXR1cm5cblxuICAgICAgICByZWNDbGlwLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMHB4LCAwcHgpJ1xuICAgICAgICBfKCdncmFwaC1jbGlwcGluZycpLmNsYXNzTGlzdC5hZGQoJ3Nob3ctZ3JhcGhzJylcblxuICAgICAgICAvL0FuaW1hdGUgZ3JhcGhzIGFmdGVyIHJlY0NsaXAgdHJhbnNmb3JtIGlzIGRvbmVcbiAgICAgICAgc2V0VGltZW91dCggKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGVHcmFwaClcbiAgICAgICAgfSwgMjUwMClcbiAgICAgICBcbiAgICB9XG5cbiAgICBjb25zdCBiZWdpbiA9IHtcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIHRvdGFsOiA0MDAwXG4gICAgfVxuXG4gICAgY29uc3QgZmx5SW4gPSAodGltZXN0YW1wKSA9PntcbiAgICAgICAgaWYoIWJlZ2luLnN0YXJ0KSBiZWdpbi5zdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICBiZWdpbi5ydW50aW1lID0gdGltZXN0YW1wIC0gYmVnaW4uc3RhcnRcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1pbihiZWdpbi5ydW50aW1lIC8gYmVnaW4udG90YWwsIDEpXG4gICAgICAgIGNvbnN0IGN1cnZlID0gNjI0LjkgLyAyXG4gICAgICAgIGNvbnN0IGVhc2UgPSBlYXNlT3V0KHByb2dyZXNzKVxuICAgICAgICBjb25zdCBpbmNyZW1lbnQgPSBjdXJ2ZSAqIHByb2dyZXNzIC8gNTBcbiAgICBcbiAgICAgICAgY29uc3QgeSA9IC1mbHlJbnRvUGxhY2UuYmVnaW5ZICsgZmx5SW50b1BsYWNlLmJlZ2luWSAqIHByb2dyZXNzXG4gICAgICAgIGNvbnN0IHggPSAtTWF0aC5jb3MoIGluY3JlbWVudCArIE1hdGguUEkvMTgwKSAqIGN1cnZlICsgY3VydmUgXG4gICAgICAgIC8vICFiZWdpbi50b2dnbGVcbiAgICAgICAgIF8oJ2Zsb2F0aW5nX3JvYm90Jykuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgkey14fXB4LCAke3l9cHgpYFxuICAgICAgICAvLyA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzZWN0aW9uLWZpdmUtd2ViIC5jb250YWluZXItbGcnKS5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHsxLjMgLSAuMyAqIGVhc2V9KWBcblxuICAgICAgICBpZihwcm9ncmVzcyA9PT0gMSl7XG4gICAgICAgICAgICAvLyB0b2dnbGVSb2JvdC50b2dnbGUgPSB0cnVlO1xuICAgICAgICAgICAgdG9nZ2xlUm9ib3QuZGlyZWN0aW9uID0gJ2Rvd24nXG4gICAgICAgIFxuICAgICAgICAgICAgLy9SZXNpemVzIHRoZSB3aG9sZSBjb250YWluZXIgc28gcm9ib3QgZml0cyBpbnRvIHNjcmVlblxuICAgICAgICAgICAgaWYoIHdXID4gMTA1MCApe1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoc3RhcnRBbmltYXRlR3JhcGgsIDYwMClcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2VjdGlvbi1maXZlLXdlYiAuY29udGFpbmVyLWxnJykuY2xhc3NMaXN0LmFkZCgnc2NhbGUtY29udGFpbmVyJylcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHN0YXJ0QW5pbWF0ZUdyYXBoKClcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZmx5SW4pXG4gICAgfVxuICAgIHJldHVybiB7Zmx5SW4sIGZseUludG9QbGFjZSwgZHJhd0J1cm5lcnN9XG59XG5cbmxldCBuYXZUb2dnbGUgPSB7XG4gICAgdG9nZ2xlOiB0cnVlXG59XG5cbmNsYXNzIE5hdmlnYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMubmF2SXRlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubmF2LWxpc3QgYnV0dG9uJylcbiAgICAgICAgdGhpcy5zY3JvbGxUbyA9IHRoaXMuc2Nyb2xsVG8uYmluZCh0aGlzKVxuICAgICAgICB0aGlzLmFuaW1hdGVTY3JvbGwgPSB0aGlzLmFuaW1hdGVTY3JvbGwuYmluZCh0aGlzKVxuICAgICAgICB0aGlzLnN0YXJ0ID0gMFxuICAgIH1cbiAgICBnZXREaXN0YW5jZShlbCl7XG4gICAgIFxuICAgICAgICBsZXQgdG9wID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgICAgIGxldCBoZWlnaHQgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICAgICAgbGV0IGJvdHRvbSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbVxuICAgICAgICByZXR1cm4ge3RvcCwgaGVpZ2h0LCBib3R0b219XG4gICAgfVxuICAgIGdldFNjcm9sbHRvRWxlbWVudCh0YXJnZXQsIHJlZ0V4KXtcbiAgICAgICAgbGV0IHNlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2VjdGlvbicpXG4gICAgICAgIGxldCBsZW5ndGggPSBzZWN0aW9uLmxlbmd0aFxuICAgICAgICB3aGlsZShsZW5ndGgtLSl7XG4gICAgICAgICAgICBpZiAoIHRhcmdldCA9PT0gc2VjdGlvbltsZW5ndGhdLmlkLnJlcGxhY2UocmVnRXgsIFwiJDFcIikgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHNlY3Rpb25bbGVuZ3RoXSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGxlbmd0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBvdXRFeHBvKG4pe1xuICAgICAgICByZXR1cm4gMSA9PSBuID8gbiA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBuKTtcbiAgICB9O1xuXG4gICAgYW5pbWF0ZVNjcm9sbCh0aW1lc3RhbXApe1xuICAgICAgICBpZighdGhpcy5zdGFydCkgdGhpcy5zdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICBsZXQgcnVudGltZSA9ICB0aW1lc3RhbXAgLSB0aGlzLnN0YXJ0XG4gICAgICAgIGxldCBwcm9ncmVzcyA9IHRoaXMub3V0RXhwbyggTWF0aC5taW4oIHJ1bnRpbWUgLyAxMjAwLCAxICkgKVxuICAgICAgICBsZXQgeSA9IHRoaXMuc3RhcnRQb3MgKyAodGhpcy5lbERpc3QgKiBwcm9ncmVzcylcbiAgICAgICBcbiAgICAgICAgd2luZG93LnNjcm9sbCgwLCB5KVxuICAgICAgICBpZihwcm9ncmVzcyA8IDEpe1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZVNjcm9sbClcbiAgICAgICAgfWVsc2UgcmV0dXJuIG5hdlRvZ2dsZS50b2dnbGUgPSB0cnVlICBcbiAgICB9XG5cbiAgICB0b2dnbGVPcGVuQnRuKCl7XG4gICAgICAgIGxldCBpID0gdGhpcy5uYXZJdGVtcy5sZW5ndGhcbiAgICAgICAgd2hpbGUoaS0tKXtcbiAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRoaXMubmF2SXRlbXNbaV0uc3R5bGUudHJhbnNmb3JtKXtcbiAgICAgICAgICAgICAgIHRoaXMubmF2SXRlbXNbaV0ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgc2Nyb2xsVG8oZSl7XG4gICAgICAgIHRoaXMudG9nZ2xlT3BlbkJ0bigpXG4gICAgICAgIGlmKGUudGFyZ2V0LmNsYXNzTmFtZSA9PT0gJ2NvbnRhY3QtbW9kYWwnKSByZXR1cm5cbiAgICAgICAgY29uc3QgcmVnRXggPSAvKFxcdytcXC1cXHcrKVxcLVxcdysvaWdcbiAgICAgICAgY29uc3Qgc2VjdGlvbklkID0gZS50YXJnZXQuY2xhc3NOYW1lLnJlcGxhY2UocmVnRXgsXCIkMVwiKVxuICAgICAgICBsZXQgc2Nyb2xsVG9FbGVtID0gdGhpcy5nZXRTY3JvbGx0b0VsZW1lbnQoc2VjdGlvbklkLHJlZ0V4KS5lbFxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmdldFNjcm9sbHRvRWxlbWVudChzZWN0aW9uSWQscmVnRXgpLmluZGV4XG4gICAgICAgIGxldCBlbERpc3QgPSB0aGlzLmdldERpc3RhbmNlKHNjcm9sbFRvRWxlbSwgaW5kZXgpLnRvcFxuICAgICAgICB0aGlzLmVsRGlzdCA9IGVsRGlzdFxuICAgICAgICB0aGlzLnN0YXJ0UG9zID0gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgICAgIHRoaXMuc3RhcnQgPSAwXG4gICAgICAgIFxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlU2Nyb2xsKVxuICAgIH1cbiAgICBzY3JvbGxUbzc2OChlKXtcbiAgICAgICAgbGV0IHRhcmdldEJ0biA9IGUudGFyZ2V0LnBhcmVudE5vZGUucGFyZW50Tm9kZVxuICAgICAgICBcbiAgICAgICAgaWYodGFyZ2V0QnRuLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKSl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2dnbGVPcGVuQnRuKClcbiAgICAgICAgfSBcbiAgICAgICAgdGhpcy50b2dnbGVPcGVuQnRuKClcbiAgICAgICAgdGFyZ2V0QnRuLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnYXV0bydcbiAgICAgICAgdGFyZ2V0QnRuLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGVYKCR7LTEzMn1weClgXG4gICAgfVxuXG4gICAgY29udHJvbGxlcigpe1xuICAgICAgICBfKCduYXYtbGlzdCcpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGUudGFyZ2V0KVxuICAgICAgICAgICAgbmF2VG9nZ2xlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICBpZiggZS50YXJnZXQubm9kZU5hbWUgPT09IFwiQlVUVE9OXCIpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUbyhlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSBAIHNjcmVlbiBzaXplIDc2OCBhbmQgc21hbGxlclxuICAgICAgICAgICAgaWYoZS50YXJnZXQucGFyZW50Tm9kZS5jbGFzc0xpc3RbMV0gPT09ICduYXYtaWNvbicpe1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG83NjgoZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuY29uc3QgbmF2aWdhdGlvbiA9IG5ldyBOYXZpZ2F0aW9uKClcbm5hdmlnYXRpb24uY29udHJvbGxlcigpXG5cbmNvbnN0IHRvZ2dsZUFuaW1hdGUgPSB7XG4gICAgc3RhcnM6IHRydWUsXG4gICAgZmxpZ2h0U3RhcnM6IHRydWUsXG4gICAgY2lyY3VpdDogdHJ1ZVxufVxuXG5jb25zdCByb2JvdCA9IG5ldyByb2JvdFNlY3Rpb24oJ2V2ZW50Jyk7XG5jb25zdCByb2JvdEZsaWdodCA9IHN0YXJ0Um9ib3RGbGlnaHQoKTtcblxuXG5jb25zdCB0cmlnZ2VyU3RhcnMgPSAoZSkgPT4ge1xuICAgIHZhciB1cGRhdGUgPSByb2JvdFsxXShlKS51cGRhdGVcbiAgICB2YXIgc3Rhcl9jb3VudCA9IHdXID4gNTQwID8gMjUgOiAxNVxuICAgIHZhciBtYWtlU3RhcnMgPSByb2JvdFsxXSgpXG4gICAgbWFrZVN0YXJzLmNyZWF0ZVN0YXJzKHN0YXJfY291bnQsIHVwZGF0ZSlcbn1cblxuY2xhc3MgU2Nyb2xsQW5pbWF0ZSBleHRlbmRzIE5hdmlnYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5zZWN0aW9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJyNzZWN0aW9uLW9uZS1kaWdpdGFsLCAjc2VjdGlvbi10d28tcG9wdXBzLCAuc2VjdGlvbi10aHJlZS1yb2JvdCwgI3NlY3Rpb24tZml2ZS13ZWIgICcpXG4gICAgfVxuICAgIGNoZWNrRWxlbVRvcChlKXtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHRoaXMuc2VjdGlvbnMubGVuZ3RoXG4gICAgICAgXG4gICAgICAgIHdoaWxlKGxlbmd0aC0tKXtcbiAgICAgICAgICAgIGxldCBkaXN0ID0gdGhpcy5nZXREaXN0YW5jZSh0aGlzLnNlY3Rpb25zW2xlbmd0aF0pXG4gICAgICAgICAgICBsZXQgZWxtVG9wID0gZGlzdC50b3BcbiAgICAgICAgICAgIGxldCBlbG1IZWlnaHQgPSBkaXN0LmhlaWdodFxuICAgICAgICAgICAgbGV0IGVsbUJvdHRvbSA9IGRpc3QuYm90dG9tXG5cbiAgICAgICAgICAgIC8vRGlnaXRhbCBIYW5kXG4gICAgICAgICAgICBpZihsZW5ndGggPT09IDApe1xuXG4gICAgICAgICAgICAgICAgaWYoZWxtQm90dG9tIDwgMzAwKXtcbiAgICAgICAgICAgICAgICAgICAgaWYod1cgPCA3NjgpIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdkaWdpdGFsX3NoYWtlJykuc3R5bGUud2lsbENoYW5nZSA9IFwiYXV0b1wiXG4gICAgICAgICAgICAgICAgICAgIGRpZ2l0YWwucmVtb3ZlRGlnaXRhbEFuaW1hdGlvbigpXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZUFuaW1hdGUuY2lyY3VpdCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9NYXBcbiAgICAgICAgICAgIGlmKGxlbmd0aCA9PT0gMSl7XG4gICAgICAgICAgICAgICBjb25zdCBwb2ludGVyTG9jYXRpb24gPSBfKCdvdmFsLXBvaW50ZXInKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS54XG5cbiAgICAgICAgICAgICAgIC8vU3RvcHMgc2Nyb2xsIGZyb20gcnVubmluZyBob3Zlcm1hcCBmdW5jdGlvbiBvdmVyIGFuZCBvdmVyXG4gICAgICAgICAgICAgICBpZihwb2ludGVyTG9jYXRpb24gPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG92ZXJtYXAgPSBob3Zlck1hcCgpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBob3Zlcm1hcFsxXShlKVswXTsgLy8gUG9zaXRpb24gZGlzdGFuY2Ugb2Ygc2hvdy1pY29uIGdvb2V5XG4gICAgICAgICAgICAgICAgICAgIGhvdmVybWFwWzBdKCBkaXN0LCB0cnVlICkgIC8vIGhhbmRsZXIoZSkgZnVuY3Rpb24gcmVtb3ZlIGdvb2V5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUm9ib3QgRGVzaWduIHN0YXJzIGVsZW1lbnRcbiAgICAgICAgICAgIGlmKGxlbmd0aCA9PT0gMikge1xuICBcbiAgICAgICAgICAgICAgICAvL1BhZ2UgaW4gdmlldyBzdGFydCBhbmltYXRlIHN0YXJzXG4gICAgICAgICAgICAgICAgaWYoZWxtVG9wIDw9IGVsbUhlaWdodCAmJiBlbG1Cb3R0b20gPj0gZWxtSGVpZ2h0ICYmIHRvZ2dsZUFuaW1hdGUuc3RhcnMpe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQW5pbWF0ZS5zdGFycyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZVN0YXJzLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJTdGFycyhlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL1BhZ2Ugb3V0IG9mIHZpZXcgc3RhcnQgc3RvcCBhbmltYXRlXG4gICAgICAgICAgICAgICAgaWYoICF0b2dnbGVBbmltYXRlLnN0YXJzICAmJiAgKGVsbVRvcCA+IGVsbUhlaWdodCB8fCBlbG1Cb3R0b20gPD0gMCkgKXtcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQW5pbWF0ZS5zdGFycyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlU3RhcnMudG9nZ2xlID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vRmx5aW5nIFJvYm90IC8gR3JhcGggZWxlbWVudFxuICAgICAgICAgICAgaWYobGVuZ3RoID09PSAzKXtcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihlbG1Ub3AgPCBlbG1IZWlnaHQpe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYoIV8oJ2Zsb2F0aW5nX3JvYm90Jykuc3R5bGUud2lsbENoYW5nZSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBfKCdmbG9hdGluZ19yb2JvdCcpLnN0eWxlLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKGVsbVRvcCA8IGVsbUhlaWdodCAvIDIgJiYgZWxtQm90dG9tID49IGVsbUhlaWdodCAmJiB0b2dnbGVBbmltYXRlLmZsaWdodFN0YXJzKXtcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlUm9ib3QuZmxpZ2h0ID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQW5pbWF0ZS5mbGlnaHRTdGFycyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSggcm9ib3RGbGlnaHQuZHJhd0J1cm5lcnMgKVxuICAgICAgICAgICAgICAgICAgICByb2JvdEZsaWdodC5mbHlJbnRvUGxhY2UuY3JlYXRlU3RhcnMoJ3VwJylcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJvYm90RmxpZ2h0LmZseUluKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiggIXRvZ2dsZUFuaW1hdGUuZmxpZ2h0U3RhcnMgICYmICAoZWxtVG9wID4gZWxtSGVpZ2h0IC0gNzUgfHwgZWxtQm90dG9tIDw9IDApICl7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL1JlbW92ZXMgcmF5XG4gICAgICAgICAgICAgICAgICAgIF8oJ2Zsb2F0aW5nX3JvYm90Jykuc3R5bGUud2lsbENoYW5nZSA9ICdhdXRvJ1xuICAgICAgICAgICAgICAgICAgICAvLyBfKCdyZWMtY2xpcCcpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQW5pbWF0ZS5mbGlnaHRTdGFycyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlUm9ib3QuZmxpZ2h0ID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gXG4gICAgICAgIH1cbiAgICB9XG4gIFxuICAgIHNjcm9sbCgpe1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgKGUpID0+IHtcbiAgICAgICAgICAgIC8vIElmIG5hdiBpdGVtIGlzIGNsaWNrZWQgdGhhdCBzY3JvbGwgZXZlbnQgd2lsbCBydW4gYW5kIG5vdCB0cmlnZ2VyIHRoaXMgc2Nyb2xsIGV2ZW50XG4gICAgICAgICAgICBpZihuYXZUb2dnbGUudG9nZ2xlKXtcblxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tFbGVtVG9wKGUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxufVxuY29uc3Qgc2Nyb2xsQW5pbWF0ZSA9IG5ldyBTY3JvbGxBbmltYXRlKClcbnNjcm9sbEFuaW1hdGUuc2Nyb2xsKClcblxuLy8qKiogSEFORCBTSEFLRSAqKipcbmNsYXNzIERpZ2l0YWwge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMucGF0aCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zdHJva2UnKVxuICAgICAgICB0aGlzLndhdGNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JvdGF0ZV93YXRjaCcpXG4gICAgfVxuXG4gICAgc3RhcnRIYW5kQW5pbWF0aW9uKCl7XG5cbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RpZ2l0YWxfc2hha2UnKS5jbGFzc0xpc3QuYWRkKCdzaGFrZS1oYW5kJylcbiAgICAgICAgdGhpcy53YXRjaC5jbGFzc0xpc3QuYWRkKCdyb3RhdGVXYXRjaCcpXG4gICAgICAgIHNldFRpbWVvdXQoICgpPT57XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCAzKSBfKCdjaXJjbGUtcGF0aCcpW2ldLnN0eWxlLm9wYWNpdHkgPSAxXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoW2ldLmNsYXNzTGlzdC5hZGQoJ3BhdGgnKVxuICAgICAgICAgICB9XG4gICAgICAgIH0sIDIwMDApICBcbiAgICB9XG4gICAgcmVtb3ZlRGlnaXRhbEFuaW1hdGlvbigpe1xuICAgICAgICB0aGlzLndhdGNoLmNsYXNzTGlzdC5yZW1vdmUoJ3JvdGF0ZVdhdGNoJylcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB0aGlzLnBhdGhbaV0uY2xhc3NMaXN0LnJlbW92ZSgncGF0aCcpXG4gICAgICAgIH0gXG4gICAgfVxufVxuXG5jb25zdCBjaXJjdWl0VG9nZ2xlID0ge1xuICAgIHRvZ2dsZUFuaW06IHRydWVcbn1cbi8vYnJhZC1qb3NodWFcbmNsYXNzIENpcmN1aXQgZXh0ZW5kcyBEaWdpdGFse1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5hbmltQ2lyY3VpdCA9IF8oJ2FuaW1hdGUtY2lyY3VpdCcpXG4gICAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24gPSB0aGlzLnN0YXJ0QW5pbWF0aW9uLmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5kYXRhID0gW11cbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IFtdXG4gICAgICAgIHRoaXMuaW5kZXggPSBbXVxuICAgICAgICB0aGlzLnBhdGhMZW5ndGggPSBbXVxuICAgIH1cbiAgICAvL1NWRyAuZ2V0VG90YWxMZW5ndGgoKSBmaXhcbiAgICBnZXRTdmdQb2x5bGluZUxlbmd0aChlbCkge1xuICAgICAgICBsZXQgdG90YWxMZW5ndGggPSAwO1xuICAgICAgICBsZXQgcHJldlBvcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgZWwucG9pbnRzLm51bWJlck9mSXRlbXM7aSsrKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gZWwucG9pbnRzLmdldEl0ZW0oaSk7XG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0b3RhbExlbmd0aCArPSBNYXRoLnNxcnQoTWF0aC5wb3coKHBvcy54IC0gcHJldlBvcy54KSwgMikgKyBNYXRoLnBvdygocG9zLnkgLSBwcmV2UG9zLnkpLCAyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmV2UG9zID0gcG9zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbExlbmd0aDtcbiAgICB9XG4gICAgLy9TVkcgLmdldFRvdGFsTGVuZ3RoKCkgZml4XG4gICAgZ2V0U3ZnRWVtZW50TGVuZ3RoKGVsKXtcblxuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IGVsLmNvbnN0cnVjdG9yXG4gICAgICAgXG4gICAgICAgIHN3aXRjaCAoY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgU1ZHUG9seWxpbmVFbGVtZW50OiByZXR1cm4gdGhpcy5nZXRTdmdQb2x5bGluZUxlbmd0aChlbCk7XG4gICAgICAgICAgICBjYXNlIFNWR0xpbmVFbGVtZW50OiByZXR1cm4gKCh4MSwgeDIsIHkxLCB5MikgPT4gTWF0aC5zcXJ0KCAoeDItPXgxKSp4MiArICh5Mi09eTEpKnkyICkpKGVsLmdldEF0dHJpYnV0ZSgneDEnKSwgZWwuZ2V0QXR0cmlidXRlKCd4MicpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsLmdldEF0dHJpYnV0ZSgneTEnKSwgZWwuZ2V0QXR0cmlidXRlKCd5MicpKTtcbiAgICAgICAgICAgIGNhc2UgU1ZHUmVjdEVsZW1lbnQ6IHJldHVybiAoZWwuZ2V0QXR0cmlidXRlKCd3aWR0aCcpKjIpICsgKGVsLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykqMik7XG4gICAgICAgICAgICBjYXNlIFNWR1BhdGhFbGVtZW50OiByZXR1cm4gZWwuZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLzNyZCBtZXRob2QgcmFuXG4gICAgZ2V0RGFzaFN0cm9rZShlbCl7XG4gICAgICAgIGxldCBsZW5ndGggPSBlbC5sZW5ndGhcbiAgICAgIFxuICAgICAgICB3aGlsZShsZW5ndGgtLSl7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBlbFtsZW5ndGhdXG4gICAgICAgICAgICAvLyBGaXggZm9yIFNWRy5nZXRUb3RhbExlbmd0aCgpICBub3Qgd29ya2luZyBvbiBzb21lIHBhdGhzLiBcbiAgICAgICAgICAgIHRoaXMucGF0aExlbmd0aC51bnNoaWZ0KCB0aGlzLmdldFN2Z0VlbWVudExlbmd0aChfKCdhbmltYXRlLWNpcmN1aXQnKVtpbmRleF0pIClcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRDbGFzc2VzKCl7XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLmVsZW1lbnRzLmxlbmd0aFxuICAgICAgICB3aGlsZShsZW5ndGgtLSl7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzW2xlbmd0aF0uY2xhc3NMaXN0LmFkZCgnYW5pbWF0ZVBhdGgnKVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vMm5kIG1ldGhvZCByYW5cbiAgICBnZXRSYW5kb21QYXRoKHBhdGhzKXtcbiAgICAgICAgbGV0IGkgPSAwXG4gICAgICAgIGxldCBsZW5ndGggPSBwYXRoc1xuXG4gICAgICAgIHdoaWxlKGkgPCBsZW5ndGgpe1xuICAgICAgICAgICAgLy8gaXRlbSBpcyB0aGUgbG9uZy1wYXRoIHdoaWNoIGlzIGF0IGluZGV4IDAgaWYgY291bnQgPT09IDEsIGVsc2UgcnVuIHJhbmRvbSBcbiAgICAgICAgICAgIGxldCBpdGVtID0gcGF0aHMgPT09IDEgPyAxMCA6IE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAxMCApXG5cbiAgICAgICAgICAgIC8vQ2hlY2tzIGZpcnN0IHRvIG1ha2Ugc3VyZSBubyBkdXBsaWNhdGUgaXRlbXMgaW4gYXJyYXlcbiAgICAgICAgICAgIGxldCBub3RJbkFycmF5ID0gdGhpcy5pbmRleC5pbmRleE9mKGl0ZW0pID09PSAtMVxuXG4gICAgICAgICAgICBpZihub3RJbkFycmF5KXtcbiAgICAgICAgICAgICAgICBpKytcbiAgICAgICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goIGl0ZW0gKVxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMucHVzaCggdGhpcy5hbmltQ2lyY3VpdFtpdGVtXSApXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFuaW1DaXJjdWl0ID0gdGhpcy5lbGVtZW50c1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleFxuICAgIH1cbiAgICAvLzR0aCBtZXRob2QgcmFuXG4gICAgYWRkRGF0YShpbmRleCl7XG5cbiAgICAgICAgd2hpbGUoaW5kZXgtLSl7XG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaCh7c3BlZWQ6IDAsIGo6IDAsIGRlbGF5OiBpbmRleCoxNTAsIHN0YXJ0OiAwLCBzdGFydFRpbWU6IDB9KVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24oKVxuICAgIH1cbiAgICAvLzFzdCBtZXRob2QgcmFuXG4gICAgc2V0RGFzaEFycmF5KGNvdW50KXtcbiAgICAgICAgbGV0IHBhdGhzID0gd1cgPCA3NjggPyAxIDogY291bnQgXG4gICAgICAgIGlmKHdXIDwgNzY4KSB0aGlzLnN0YXJ0SGFuZEFuaW1hdGlvbigpXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuZ2V0UmFuZG9tUGF0aChwYXRocylcbiAgICAgICAgdGhpcy5nZXREYXNoU3Ryb2tlKGluZGV4KVxuXG4gICAgICAgIHdoaWxlKHBhdGhzLS0pe1xuICAgICAgICAgICAgdGhpcy5hbmltQ2lyY3VpdFtwYXRoc10uc3R5bGUuc3Ryb2tlID0gJ29yYW5nZSdcbiAgICAgICAgICAgIHRoaXMuYW5pbUNpcmN1aXRbcGF0aHNdLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSAtdGhpcy5wYXRoTGVuZ3RoW3BhdGhzXVxuICAgICAgICAgICAgdGhpcy5hbmltQ2lyY3VpdFtwYXRoc10uc3R5bGUuc3Ryb2tlRGFzaGFycmF5ID0gdGhpcy5wYXRoTGVuZ3RoW3BhdGhzXVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkRGF0YSh3VyA8IDc2OCA/IDMgOiA2KVxuICAgIH1cbiAgICBcbiAgICAvL1JhbiBsYXN0XG4gICAgc3RhcnRBbmltYXRpb24oKXtcbiAgICAgICAgbGV0IGNpcmNsZSA9IF8oJ2NpcmNsZS1wYXRoJylcbiAgICAgICAgbGV0IGRpc3QgPSB0aGlzLnBhdGhMZW5ndGhcbiAgICAgICAgbGV0IGVsID0gdGhpcy5hbmltQ2lyY3VpdFxuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuZGF0YVxuICAgICAgICBsZXQgbGVuZ3RoID0gZWwubGVuZ3RoXG4gICAgICAgIGxldCBjb3VudFNwZWVkID0gNztcbiAgICAgICAgbGV0IGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aFxuICAgICAgICBsZXQgZGVsYXkgPSAwXG4gICAgICBcbiAgICAgICAgZnVuY3Rpb24gc3RhcnRDaXJjbGVBbmltYXRpb24odGltZXN0YW1wKXtcblxuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGRhdGFMZW5ndGg7IGkrKyl7XG5cbiAgICAgICAgICAgICAgICBpZihkZWxheSA+IGRhdGFbaV0uZGVsYXkpe1xuICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZighZGF0YVtpXS5zdGFydFRpbWUpIGRhdGFbaV0uc3RhcnRUaW1lID0gdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgICAgIGxldCBydW4gPSB0aW1lc3RhbXAgLSBkYXRhW2ldLnN0YXJ0VGltZSBcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByb2cgPSBNYXRoLm1pbiggcnVuIC8gMzAwMDAsIDEpXG4gICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7eCwgeX0gPSBlbFswXS5nZXRQb2ludEF0TGVuZ3RoKGRpc3RbMF0gKiBwcm9nKTtcbiAgICAgICAgICAgICAgICAgICAgY2lyY2xlW2ldLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHt4fXB4LCAke3l9cHgpYFxuICAgICAgICAgICAgICAgICAgICBpZihwcm9nID09PSAxKSBkYXRhW2ldLnN0YXJ0VGltZSA9IDBcbiAgICAgICAgICAgICAgICB9ICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsYXkrK1xuXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RhcnRDaXJjbGVBbmltYXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3RhcnRMaW5lQW5pbWF0aW9uKCl7XG4gICAgICAgICAgICAvL1JlbW92ZXMgQW5pbWF0aW9uXG4gICAgICAgICAgICBpZighdG9nZ2xlQW5pbWF0ZS5jaXJjdWl0KXtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IGVsLmxlbmd0aFxuICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB3aGlsZShpLS0pe1xuICAgICAgICAgICAgICAgICAgICBlbFtpXS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZGFzaEFycmF5ID0gZWxbaV0uc3R5bGUuc3Ryb2tlRGFzaGFycmF5XG4gICAgICAgICAgICAgICAgbGV0IGRhc2hPZmZzZXQgPSBlbFtpXS5zdHlsZS5zdHJva2VEYXNob2Zmc2V0XG5cbiAgICAgICAgICAgICAgICAvLyBTdHJva2VEYXNob2Zmc2V0IGlzIGxlc3MgdGhlbiAwIHJ1bnMgc2FtZSBkaXJlY3Rpb24gXG4gICAgICAgICAgICAgICAgaWYoZGFzaE9mZnNldCA+PSAwICYmICFkYXRhW2ldLmope1xuICAgICAgICAgICAgICAgICAgICBkYXRhW2ldLnNwZWVkID0gMFxuICAgICAgICAgICAgICAgICAgICBkYXRhW2ldLmogPSAxXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBzcGVlZCA9ICBkYXRhW2ldLnNwZWVkICs9IGNvdW50U3BlZWRcbiAgICAgICAgICAgICAgICBsZXQgaXRlcmF0b3IgPSBkYXNoT2Zmc2V0IDw9IDAgPyAtZGlzdFtpXSA6IDA7XG4gICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9TdG9wcyBzdHJva2VkYXNoYXJyYXkgYXQgYWJvdXQgYSAzcmQgdG8ga2VlcCB0aGUgbGVuZ3RoIHRoYXQgc2l6ZVxuICAgICAgICAgICAgICAgIGlmKGRhc2hBcnJheSA+PSAoZGlzdFtpXSAvIDEuOCkgKXtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGVsW2ldLnN0eWxlLnN0cm9rZURhc2hhcnJheSA9IGRpc3RbaV0gLSBzcGVlZFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsW2ldLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSBpdGVyYXRvciArIHNwZWVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RhcnRMaW5lQW5pbWF0aW9uKVxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh3VyA8IDc2OCA/IHN0YXJ0Q2lyY2xlQW5pbWF0aW9uIDogc3RhcnRMaW5lQW5pbWF0aW9uIClcbiAgICB9XG59XG5jb25zdCBkaWdpdGFsID0gbmV3IERpZ2l0YWwoKVxuY29uc3QgY2lyY3VpdCA9IG5ldyBDaXJjdWl0KClcblxuXG53aW5kb3cub25sb2FkID0gZnVuY3Rpb24oZSl7XG4gICAgc2V0VGltZW91dCggKCkgPT57XG4gICAgICAgIGNpcmN1aXQuc2V0RGFzaEFycmF5KDYpIFxuICAgIH0sMzAwKVxuICAgIFxuICAgXG4gICAgbGV0IG5ld1RlY2hub2xvZ2llcyA9IG5ldyBUZWNobm9sb2dpZXMoKTtcbiAgICBuZXdUZWNobm9sb2dpZXMubG9hZEltYWdlcygpO1xuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRlY2hub2xvZ2llcyAuc3RhcnQtY2FudmFzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgICBUZWNobm9sb2dpZXMucHJvdG90eXBlLnRvZ2dsZSA9IHRydWVcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG5ld1RlY2hub2xvZ2llcy5kcmF3LmJpbmQobmV3VGVjaG5vbG9naWVzKSkgXG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy50ZWNobm9sb2dpZXMgLnN0b3AtY2FudmFzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgICBUZWNobm9sb2dpZXMucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShuZXdUZWNobm9sb2dpZXMuZHJhdy5iaW5kKG5ld1RlY2hub2xvZ2llcykpIFxuICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICB2YXIgc3RhcnJ5TmlnaHQgPSBuZXcgU3RhcnJ5TmlnaHQoKVxuICAgIHN0YXJyeU5pZ2h0LmxvYWRJbWFnZXMoKVxuXG4gICAgaG92ZXJNYXAoKVxuICAgIFxuICAgIHZhciBkZXNpZ25TbGlkZXIgPSBuZXcgRGVzaWduU2xpZGVyKCk7XG4gICAgZGVzaWduU2xpZGVyKCk7XG5cbiAgICByb2JvdFsxXSgpIC8vdXBkYXRlcyByb2JvdCBsb2NhdGlvblxuICAgIHJvYm90WzBdLmxvYWRJbWFnZXMoKTsgLy90aGVuIGxvYWRlcyBpbWFnZXMgaW50byBzbGlkZXJcblxuICAgIHJvYm90RmxpZ2h0LmZseUludG9QbGFjZS5oaWRlUm9ib3QoMS4zKTsgLy9IaWRlcyBmbHlpbmcgcm9ib3Qgb3V0IG9mIHNjcmVlbiB2aWV3XG4gICAgXG59LmJpbmQodGhpcyk7XG5cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUlBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBaEJBO0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQWRBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFyQkE7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFlQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1QkE7QUFDQTtBQThCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFJQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUNBO0FBREE7QUFLQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUdBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQVZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBdkJBO0FBeUJBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQTVIQTtBQUNBO0FBOEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5QkE7QUFnQ0E7QUFDQTtBQUNBOzs7Ozs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWRBO0FBZUE7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQW5aQTtBQUNBO0FBcVpBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFjQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQWhOQTtBQUNBO0FBa05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBTUE7QUFBQTtBQU5BO0FBQUE7QUFBQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWpEQTtBQUFBO0FBQUE7QUFDQTtBQWtEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpDQTtBQUNBO0FBMkNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUZBO0FBR0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUF4RkE7QUFDQTtBQXlGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUdBO0FBQ0E7QUFFQTtBQUhBO0FBSUE7OztBQUNBO0FBQUE7QUFDQTtBQURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVFBO0FBQ0E7QUFDQTtBQUNBOzs7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUxBO0FBT0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUFBO0FBQUE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBcktBO0FBQ0E7QUFzS0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ })

/******/ });