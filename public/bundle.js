/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/******  GLOBAL VARIABLES  *******/\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar animate768 = \"M565.1,0v900H0c0,0,0-75.3,0-192.4c0-211.7,0-303.7,0-533.1C0,50.5,0,0,0,0H565.1z;\" + \"M565.1,0v900H182.7c0,0-44-72.5-44-191.7c0-107.5,121.8-396.1,121.8-533.8C260.5,41,245.9,0,245.9,0H565.1z;\" + \"M571.8,0v900H386.7c0,0-31.4-42.7-31.4-191.7C355.3,568,555,285,555,80.7C555,20,551.5,0,551.5,0H571.8z;\" + \"M573,0v900h-2.3c0,0,0.4-65.2,0.4-192.4c0-176.8-0.2-347.9-0.2-533.4c0-124-0.2-174.2-0.2-174.2H573z\";\n\nvar animate400 = \"M390,800H6c0,0-6-45.9-6-161.3C0,443.6,5,286.1,5,47.3C5,10.7,3,0,3,0h387V800z;\" + \"M390,800H96c0,0-46-45.9-46-161.3c0-195.1,130-352.6,130-591.3c0-36.7-3-47.3-3-47.3h213V800z;\" + \"M390,800H243c0,0-37-45.9-37-161.3c0-195.1,176-352.6,176-591.3c0-36.7-1-47.3-1-47.3h9V800z;\" + \"M390,800h-7c0,0,0-45.9,0-161.3c0-195.1,5-352.6,5-591.3c0-36.7-1-47.3-1-47.3h3V800z\";\n\nvar isFirefox = typeof InstallTrigger !== 'undefined';\nvar isSafari = navigator.userAgent.indexOf(\"Safari\") != -1 && navigator.userAgent.indexOf(\"Chrome\") === -1;\n\nvar wW = window.innerWidth;\nvar wH = window.innerHeight;\nvar lastDist;\n\n//Firefox Bug, transforms not working, so sets attribute to 0 instead\nif (isFirefox) {\n    //svg morfing problem\n    document.getElementsByTagName('feGaussianBlur')[0].setAttribute('stdDeviation', '6');\n    //svg css problem\n    _('svg-circle').setAttribute('r', 0);\n    _('svg-circle').style.transform = 'scale(1)';\n}\n\nif (isSafari) _('svg-page').style.visibility = \"hidden\";\n\nfunction _(clss) {\n\n    var classes = document.getElementsByClassName(clss);\n\n    if (classes.length === 1) {\n        return classes[0];\n    }\n    if (classes.length > 1) {\n        return classes;\n    } else return \"Not a working class\";\n};\n\nvar easeOut = function easeOut(progress) {\n    return Math.pow(--progress, 5) + 1;\n};\n\n//String: indicates new size of width or height that you want. Size: of the new size of the string. El: the element you want it for\nvar newSize = function newSize(string, size, el) {\n    if (typeof el !== 'undefined') {\n\n        var ogWidth = el.getBoundingClientRect().width;\n        var ogHeight = el.getBoundingClientRect().height;\n        if (ogWidth === 0 || ogHeight === 0) {\n            ogWidth = el.getAttribute('width');\n            ogHeight = el.getAttribute('height');\n        }\n    } else {\n        var ogWidth = 762.22;\n        var ogHeight = 668.97;\n    }\n\n    if (string === 'height') {\n        var ratio = ogHeight / size;\n        return {\n            height: size,\n            width: ogWidth / ratio\n        };\n    } else if (string === 'width') {\n        var _ratio = ogWidth / size;\n        return {\n            width: size,\n            height: ogHeight / _ratio\n        };\n    } else console.log('check parameters');\n};\n\nWebFont.load({\n    google: {\n        families: ['Do Hyeon', 'Orbitron']\n    },\n    active: function active() {\n        //Starts when google fonts are loaded     \n        slotMachine();\n        Stretch();\n    }\n});\n\nfunction slotMachine() {\n\n    var canvas = document.getElementById('slot-machine');\n    var ctx = canvas.getContext('2d');\n\n    var Slot = function Slot() {\n        this.x = 0;\n        this.width = canvas.width = wW < 970 ? 360 : 475;\n        this.height = canvas.height = wW < 970 ? 360 : 475;\n        this.text = 'PHOTO';\n        this.letters = [];\n\n        this.addLetter = function (n) {\n\n            var letterHeight = wW < 970 ? -124 : -158;\n\n            //Places letters at top index 1,3,5\n            var bottom = wW < 970 ? this.height + 60 : this.height + 96;\n            for (var j = 0; j < n; j++) {\n                //Resets x every iteration\n                this.x = 0;\n                //Adjust bottom and height all letters\n                letterHeight = wW < 970 ? letterHeight + 121 : letterHeight + 158;\n                for (var i = 0; i < this.text.length; i++) {\n\n                    var data = {\n                        top: letterHeight,\n                        letter: this.text[i],\n                        x: i === 0 ? -5 : wW < 970 ? this.x += 74 : this.x += 100.8,\n                        speed: 9,\n                        bottom: bottom - letterHeight,\n                        start: i % 2 === 0 ? \"up\" : \"down\"\n                    };\n                    n === 4 ? this.letters.push(data) : this.letters.unshift(data);\n\n                    var letter = data;\n\n                    if (i % 2 === 0) {\n                        this.drawUp(letter);\n                    } else {\n\n                        if (wW < 970) {\n                            //fixes spacing issue Orbitron font\n                            i === 3 ? letter.x += 3 : true;\n                            i === 1 ? letter.x -= 3 : true;\n                        }\n                        this.drawDown(letter);\n                    }\n                }\n            }\n        };\n        this.addLetter(4);\n    };\n\n    Slot.prototype.drawUp = function (text) {\n\n        ctx.font = wW < 970 ? \"Bold 62pt Orbitron\" : \"105pt Do Hyeon\";\n        ctx.fillText(text.letter, text.x, text.bottom);\n    };\n    Slot.prototype.drawDown = function (text) {\n\n        ctx.fillStyle = \"#0D1B56\";\n        ctx.font = wW < 970 ? \"Bold 62pt Orbitron\" : \"105pt Do Hyeon\";\n        ctx.fillText(text.letter, text.x, text.top);\n    };\n\n    Slot.prototype.update = function () {\n\n        // var push = wW < 970 ? -61 : -74\n        var push = wW < 970 ? -61 : -75;\n        if (!slotMachine.prototype.toggle) return;\n\n        //New set if letters drawn based on spacing\n        if (this.letters[19].bottom <= push) {\n\n            this.letters.splice(15, 5);\n            this.addLetter(1);\n        }\n\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        for (var i = 0; i < this.letters.length; i++) {\n\n            var letter = this.letters[i];\n\n            letter.top += letter.speed;\n            letter.bottom -= letter.speed;\n\n            if (letter.start === \"up\") {\n\n                this.drawUp(letter);\n            } else this.drawDown(letter);\n        }\n        requestAnimationFrame(this.update.bind(this));\n    };\n    var slot = new Slot();\n\n    document.querySelector('.photo .start-canvas').addEventListener('click', function () {\n\n        //Start Canvas\n        slotMachine.prototype.toggle = true;\n        requestAnimationFrame(slot.update.bind(slot));\n    });\n\n    document.querySelector('.photo .stop-canvas').addEventListener('click', function () {\n        //Stop Canvas\n        slotMachine.prototype.toggle = false;\n    });\n}\n\nfunction Stretch() {\n\n    var canvas = document.getElementById('stretch');\n    var ctx = canvas.getContext('2d');\n\n    if (wW < 970) {\n        var width = 400;\n        var height = 375;\n        var strtch = 15;\n        var letterDist = 53;\n        var x = 65;\n        var stretchX = 5;\n        var mixedNum = 5;\n    }\n    if (wW < 400) {\n        var width = 360;\n        var height = 375;\n        var x = 50;\n        var mixedNum = -10;\n    }\n    if (wW > 970) {\n        var width = 650;\n        var height = 450;\n        var strtch = 30;\n        var letterDist = 65;\n        var x = 125;\n        var mixedNum = 5;\n    }\n    /** CHANGE NUMBER FOR lineCount TO ADD OR SUBTRACT HOW MANY LINES OF WORDS **/\n    var lineCount = 7;\n    var count = 0;\n    var t = lineCount - 1;\n    var colors = [\"#DAF7A6\", \"#FFC300 \", \"#FF5733\", \"#C70039\", \"#900C3F\", \"#581845\", \"#37102b\"];\n    var Letters = function Letters() {\n        // this.text = 'SOLUTIONS'\n        this.letters = [];\n        this.total = this.letters.length - 1;\n        this.total = 0;\n        this.y = 0;\n\n        this.width = canvas.width = width;\n        this.height = canvas.height = height;\n        this.text = 'DEVELOPER';\n\n        this.pushLetters = function (x, dist) {\n            //If pushLetters is ran again makes sure this.y = 0\n            if (this.y) this.y = 0;\n            var canvasHeight = this.height;\n            for (var i = 0; i < lineCount; i++) {\n                var data = {\n                    x: x,\n                    letter: this.text,\n                    stretch: strtch,\n                    start: 0,\n                    speed: i,\n                    dist: typeof dist === 'number' ? dist : 0,\n                    //Letters distance between each other virticle \n                    distance: this.y += letterDist,\n                    //Letters start on the bottom\n                    bottom: wW < 970 ? canvasHeight + 45 : canvasHeight + 62,\n                    begin: 1,\n                    //When the next rotation starts\n                    beginY: 0,\n                    scaleTotal: 4,\n                    distY: 0,\n                    color: colors[i]\n                };\n                this.letters.push(data);\n            }\n        };\n        this.pushLetters(x);\n    };\n\n    var drawUp = function drawUp(letter, dist) {\n\n        ctx.setTransform(1, 0, 0, letter.scale, letter.x, letter.bottom - dist);\n        ctx.font = wW < 970 ? \"40pt Do Hyeon\" : \"60pt Do Hyeon\";\n        ctx.fillStyle = letter.color;\n        ctx.fillText(letter.letter, 0, letter.textY);\n        // var text = ctx.measureText(letter.letter)\n    };\n    var stretch = function stretch(text) {\n        ctx.canvas.style.letterSpacing = text.dist + 'px';\n        ctx.font = wW < 970 ? \"40pt Do Hyeon\" : \"60pt Do Hyeon\";\n        ctx.fillStyle = text.color;\n        ctx.fillText(text.letter, text.x, text.bottom - text.distance);\n    };\n\n    var drawDown = function drawDown(letter) {\n        ctx.font = wW < 970 ? \"40pt Do Hyeon\" : \"60pt Do Hyeon\";\n        ctx.fillStyle = letter.color;\n        ctx.fillText(letter.letter, letter.x, letter.y);\n    };\n\n    var drawBackFlip = function drawBackFlip(letter) {\n        ctx.font = wW < 970 ? \"40pt Do Hyeon\" : \"60pt Do Hyeon\";\n        ctx.fillStyle = letter.color;\n        ctx.setTransform(1, 0, 0, letter.scale, letter.x, letter.y);\n        ctx.fillText(letter.letter, 0, letter.textY);\n    };\n\n    Letters.prototype.addLetters = function (timestamp) {\n\n        if (!Stretch.prototype.toggle) return;\n        var j = 0;\n\n        ctx.globalCompositeOperation = 'destination-under';\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n        for (var i = 0; i < this.letters.length; i++) {\n\n            var letter = this.letters[i];\n            letter.y = letter.bottom - letter.distance;\n\n            //FOURTH AND LAST CALL, REMOVE WORDS\n            if (count === 3 && i === t) {\n\n                if (!letter.start) letter.start = timestamp;\n                var runtime = timestamp - letter.start;\n                var progress = Math.min(runtime / 600, 1);\n                letter.y += letter.distance * progress;\n\n                letter.scale = 0 || (letter.begin - letter.scaleTotal * progress).toFixed(2);\n                letter.textY = (letter.beginY + letter.distY * progress).toFixed(2);\n                drawBackFlip(letter);\n\n                if (letter.scale == -1 || letter.scale < -1) {\n\n                    letter.beginY = 10;\n                    letter.distY = wW < 970 ? -5 : -10;\n                    letter.scaleTotal = -4;\n                    letter.begin = -3;\n                }\n\n                if (progress === 1) {\n                    //Removes item from array after each word is finished animating\n                    this.letters.splice(t, 1);\n                    t--;\n                }\n                if (t === -1) {\n                    setTimeout(function () {\n                        this.total = 0;\n                        count = 0;\n                        t = lineCount - 1;\n                        this.letters.length = 0;\n                        this.pushLetters(x);\n                    }.bind(this), 200);\n                }\n            }\n            if (count === 3 && i !== t) drawDown(letter);\n\n            //THIRD, LETTER STRETCH IN\n            if (count === 2 && i === t) {\n                if (!letter.start) letter.start = timestamp;\n                var runtime = timestamp - letter.start;\n                var progress = Math.min(runtime / 125, 1);\n                letter.dist = letter.stretch - letter.stretch * progress;\n\n                letter.x = mixedNum + letter.stretch * progress * 4;\n\n                stretch(letter);\n\n                if (progress === 1) {\n                    t--;\n                }\n                //RESETS VARIABLES, CALLS FUNCTION ALL OVER AGAIN\n                if (t === -1) {\n                    setTimeout(function () {\n                        count++;\n                        t = lineCount - 1;\n                        this.letters.length = 0;\n                        this.pushLetters(x, 0);\n                    }.bind(this), 200);\n                }\n            }\n            if (count === 2 && i !== t) {\n\n                stretch(letter);\n            }\n\n            //SECOND, LETTER STRETCH OUT\n            if (count === 1 && i === j) {\n\n                if (!letter.start) letter.start = timestamp;\n                var runtime = timestamp - letter.start;\n                var progress = Math.min(runtime / 150, 1);\n\n                letter.dist = letter.stretch * progress;\n                letter.x = x - letter.dist * 4;\n\n                stretch(letter);\n\n                if (progress === 1) {\n                    j++;\n                }\n\n                if (j === this.letters.length) {\n                    count++;\n                    this.letters.length = 0;\n                    // -5 because letters stretched to far, need to fix numbers\n                    // wW < 970 ? this.pushLetters(5, 15) : this.pushLetters(5, 30);\n                    this.pushLetters(mixedNum, wW < 970 ? 15 : 30);\n                }\n            }\n            if (count == 1 && i !== j) {\n                letter.x = letter.x;\n                letter.dist = letter.dist;\n                stretch(letter);\n            }\n\n            //FIRST, LETTER CLIMBE\n            if (i === j && count === 0) {\n\n                if (!letter.start) letter.start = timestamp;\n                var runtime = timestamp - letter.start;\n                var progress = Math.min(runtime / 600, 1);\n                var dist = letter.distance * progress;\n\n                letter.scale = 0 || (letter.begin - letter.scaleTotal * progress).toFixed(2);\n                letter.textY = (letter.beginY + letter.distY * progress).toFixed(2);\n\n                drawUp(letter, dist);\n\n                //Adds second flip to make upright text half way up canvas\n                if (letter.scale == -1 || letter.scale < -1) {\n                    //When the next rotation starts for beginY and distY\n                    letter.beginY = wW < 970 ? 5 : 10;\n                    letter.distY = wW < 970 ? -5 : -10;\n                    letter.scaleTotal = -4;\n                    letter.begin = -3;\n                }\n\n                if (progress === 1) {\n                    j++;\n                }\n\n                if (j === this.letters.length) {\n                    count++;\n                    this.letters.length = 0;\n                    this.pushLetters(x, 0);\n                }\n            }\n        }\n        requestAnimationFrame(this.addLetters.bind(this));\n    };\n    var letters = new Letters();\n\n    document.querySelector('.developer .start-canvas').addEventListener('click', function (e) {\n\n        Stretch.prototype.toggle = true;\n        requestAnimationFrame(letters.addLetters.bind(letters));\n    });\n\n    document.querySelector('.developer .stop-canvas').addEventListener('click', function () {\n\n        Stretch.prototype.toggle = false;\n    });\n};\n\nfunction ImageShatter() {\n    var sizing = function sizing(content) {\n        if (content === 'dur') {\n            if (window.innerWidth < 600) return 2.6;else if (window.innerWidth > 600) return 3.5;\n        }\n        if (content === 'img') {\n            if (window.innerWidth <= 600) return 400;else if (window.innerWidth > 1200) return 580;else return 500;\n        }\n    };\n\n    var ns = 'http://www.w3.org/2000/svg';\n    var img = new Image();\n    var ctx, canvas;\n    var particleCanvas, particleCtx;\n    var canvasParentWidth;\n    var canvasParentHeight;\n    var ending = [];\n    var retractStart = 0;\n    var imgCanvas = function imgCanvas(width, height, img, callback) {\n        //Watch where this is loaded into when portfolio done\n        // document.body.innerHTML += '<canvas id=\"img-canvas\"></canvas>';\n        // canvas = document.getElementById('img-canvas')\n        canvas = document.getElementById('particle');\n        ctx = canvas.getContext(\"2d\");\n\n        canvas.width = width;\n        canvas.height = height;\n        canvasParentWidth = _('svg-page').getBoundingClientRect().width;\n        canvasParentHeight = _('svg-page').getBoundingClientRect().height;\n\n        ctx.drawImage(img, 0, 0, width, height);\n\n        //Calls function for clickable event listener to run and appends background canvas\n        callback(canvas, createParticleCanvas());\n    };\n\n    function createParticleCanvas() {\n\n        // Create our canvas\n        particleCanvas = document.createElement(\"canvas\");\n        particleCtx = particleCanvas.getContext(\"2d\");\n\n        // Size our canvas with additional sizing\n        particleCanvas.width = canvasParentWidth;\n        particleCanvas.height = canvasParentHeight;\n\n        // Position out canvas\n        particleCanvas.style.position = \"absolute\";\n        particleCanvas.style.top = \"0\";\n        particleCanvas.style.left = \"0\";\n\n        // Make sure it's on top of other elements\n        particleCanvas.style.zIndex = \"500\";\n\n        // Make sure other elements under it are clickable\n        particleCanvas.style.pointerEvents = \"none\";\n        var foreignObject = document.createElementNS(ns, \"foreignObject\");\n        foreignObject.setAttribute('class', \"particleObject\");\n        foreignObject.setAttribute('width', canvasParentWidth);\n        foreignObject.setAttribute('height', canvasParentHeight);\n        foreignObject.appendChild(particleCanvas);\n\n        document.querySelector('g.design').appendChild(foreignObject);\n    }\n\n    //Image comes appart\n    var ExplodingParticle = function ExplodingParticle() {\n        var _this2 = this;\n\n        this.begin = 0;\n\n        // Set how long we want our particle to animate for\n        this.animationDuration = 1000; // in ms\n\n        // Set the speed / distance for our particle\n        this.speed = {\n            x: window.innerWidth < 768 ? -5 + Math.random() * 10 : -10 + Math.random() * 20,\n            y: window.innerWidth < 768 ? -5 + Math.random() * 10 : -10 + Math.random() * 20\n        };\n\n        // Size our particle\n        window.innerWidth < 768 ? this.radius = 3 + Math.random() * 3 : this.radius = 4 + Math.random() * 4;\n\n        // Set a max time to live for our particle\n        this.life = 30 + Math.random() * 10;\n        this.remainingLife = this.life;\n\n        // This function will be called by our animation logic later on\n        this.draw = function (ctx) {\n\n            var p = _this2;\n\n            if (_this2.remainingLife > 0 && _this2.radius > 0) {\n\n                // Draw a circle at the current location\n                ctx.beginPath();\n                ctx.arc(p.startX, p.startY, p.radius, 0, Math.PI * 2);\n                ctx.fillStyle = \"rgba(\" + _this2.rgbArray[0] + ',' + _this2.rgbArray[1] + ',' + _this2.rgbArray[2] + \", 1)\";\n                ctx.fill();\n\n                // Update the particle's location and life\n                p.remainingLife--;\n                p.radius -= 0.25;\n                p.startX += p.speed.x;\n                p.startY += p.speed.y;\n            }\n        };\n        this.retract = function (begin, finale, timestamp) {\n\n            if (!retractStart) retractStart = timestamp;\n\n            var runtime = timestamp - retractStart;\n            var progress = Math.min(runtime / 3000, 1);\n\n            // canvas.style.opacity = 1 - progress\n            particleCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n\n            for (var i = 0; i < begin.length; i++) {\n                var start = begin[i];\n                var end = finale[i];\n\n                var distX = Math.abs(start.startX - end.x);\n                var distY = Math.abs(start.startY - end.y);\n\n                //If end x or y is greater than x or y subtract else add\n                start.x = start.startX > end.x ? start.startX - distX * progress : start.startX + distX * progress;\n                start.y = start.startY > end.y ? start.startY - distY * progress : start.startY + distY * progress;\n                start.rad = start.begin + end.rad * progress;\n\n                particleCtx.beginPath();\n\n                particleCtx.arc(start.x, start.y, start.rad, 0, Math.PI * 2);\n                particleCtx.fillStyle = \"rgba(\" + start.rgbArray[0] + ',' + start.rgbArray[1] + ',' + start.rgbArray[2] + ',' + start.rgbArray[3] + \")\";\n\n                particleCtx.fill();\n            }\n            if (progress === 1) {\n                //returns the photo back if ran again\n                return;\n            }\n\n            requestAnimationFrame(function (timestamp) {\n                this.retract(begin, finale, timestamp);\n            }.bind(_this2));\n        };\n    };\n\n    var particles = [];\n\n    function createParticleAtPoint(x, y, colorData) {\n        var particle = new ExplodingParticle();\n\n        particle.rgbArray = colorData;\n        particle.startX = x;\n        particle.startY = y;\n        particle.startTime = Date.now();\n\n        particles.push(particle);\n        var end = {};\n        end.start = 0;\n        end.rad = particle.radius;\n        end.x = x;\n        end.y = y;\n        ending.push(end);\n    }\n\n    var opac = 1;\n    function update() {\n        if (typeof particleCtx !== \"undefined\") {\n            particleCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n        }\n        //image fades as it's breaking apart\n        canvas.style.opacity = opac = opac - .08;\n\n        // Draw all of our particles in their new location\n        for (var i = 0; i < particles.length; i++) {\n\n            particles[i].draw(particleCtx);\n\n            // When particles \n            if (particles[i].radius < 0) {\n                var percent = (Date.now() - particles[i].startTime) / particles[i].animationDuration;\n                var dur = sizing('dur');\n\n                if (percent > dur) {\n\n                    var particle = new ExplodingParticle();\n\n                    particle.retract(particles, ending);\n\n                    return;\n                }\n            }\n        }\n        window.requestAnimationFrame(update);\n    }\n\n    var clearData = function clearData() {\n        retractStart = null;\n        canvas.removeAttribute('style');\n        particleCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n        ending = [];\n        particles = [];\n    };\n\n    img.onload = function () {\n        var width = sizing('img');\n        var height = width;\n        imgCanvas(width, height, this, runEvents);\n    };\n    img.src = 'images/design-img.png';\n\n    function runEvents(imgCanvas) {\n        var foreignObject = document.querySelector('.design .item-canvas');\n\n        var imageLeft = parseInt(foreignObject.getAttribute('x'));\n        var imageTop = parseInt(foreignObject.getAttribute('y'));\n        // let reductionFactor = window.width <= 400 ? 15 : Math.round(imgCanvas.width / 15)\n        if (window.innerWidth < 600) var reductionFactor = 15;\n        if (window.innerWidth >= 600) var reductionFactor = 22;\n        if (window.innerWidth >= 1200) var reductionFactor = 33;\n\n        //Removes canvas with particles made from when closing svg page\n        _('close-btn').addEventListener('click', clearData);\n\n        imgCanvas.addEventListener('click', function (e) {\n            if (e.target.style.opacity) {\n\n                return clearData();\n            }\n\n            //width first one pixel, then all of height pixels, width another pixel then all of height pixels \n            var rgbaData = ctx.getImageData(0, 0, this.width, this.height).data;\n            var count = 0;\n            for (var x = 0; x < this.width; x++) {\n                for (var y = 0; y < this.height; y++) {\n\n                    if (count % reductionFactor === 0) {\n\n                        var index = (y * this.width + x) * 4;\n                        var rgbaColorArr = rgbaData.slice(index, index + 4);\n\n                        var globalX = imageLeft + x;\n                        var globalY = imageTop + y;\n\n                        createParticleAtPoint(globalX, globalY, rgbaColorArr);\n                    }\n                    count++;\n                }\n            }\n            update();\n        });\n    }\n}\nImageShatter();\n\nfunction StarryNight() {\n\n    var canvas = document.getElementById('starryNight');\n    var ctx = canvas.getContext('2d');\n    var data = [];\n    var trailData = [];\n    var rgb = trailData.length > 1 && 150 / trailData.length;\n    var j = 0;\n    var houseWidth = window.innerWidth < 768 ? 380 : 600;\n    var houseHeight = newSize('width', houseWidth).height;\n    this.width = canvas.width = _('svg-page').getAttribute('width');\n    this.height = canvas.height = _('svg-page').getAttribute('height');\n    this.toggle = true;\n\n    this.images = [];\n\n    //Men Data\n    var menData = {\n        headArc: window.innerWidth < 768 ? 4 : 6,\n        stepDown: window.innerWidth < 768 ? 12 : 17,\n        rotatedPos: 0,\n        rotateDegree: 14,\n        j: 0, //Each point of animation, walk, stand still, rotate ,falling\n        start: 0,\n        begin: 0,\n        lastPosX: 90,\n        lastPosY: undefined,\n        arcStartX: window.innerWidth < 768 ? 7 : 10,\n        arcStartY: 5\n\n        //House animation Data\n    };this.house = {\n        houseImg: undefined,\n        toggle: undefined,\n        currentY: undefined,\n        start: 0,\n        right: this.width - houseWidth,\n        bottom: this.height - houseHeight,\n        startY: function startY() {\n            return this.bottom + houseWidth / 2.4;\n        },\n        startX: function startX() {\n            return this.right;\n        },\n        begin: function begin() {\n            menData.lastPosY = houseHeight / 2.24 - starryNight.images[0].height;\n            ctx.drawImage(this.houseImg, this.startX(), this.startY(), houseWidth, houseHeight);\n        },\n        rise: this.height / 2,\n        moveLeft: window.innerWidth < 500 ? this.width / 20 : this.width / 8\n\n        //Star Trail Data\n    };var lastPosition = function lastPosition(xPos, yPos, radius, alpha) {\n        trailData.push({\n            x: xPos,\n            y: yPos,\n            radius: radius,\n            alpha: alpha\n        });\n        if (trailData.length > 25) trailData.shift();\n    };\n\n    this.randomMax = function (min, max) {\n        return Math.floor(Math.random() * (max - min) + min);\n    };\n\n    //Adds data for Shooting star\n    this.addData = function () {\n        for (var i = 0; i < 8; i++) {\n            var measurements = {\n                // Starts randomly on the x axis\n                delay: i === 0 ? 0 : this.randomMax(1, 2),\n                x: this.randomMax(0, this.width / 2),\n                y: this.randomMax(200, this.height),\n                radius: window.innerWidth < 768 ? this.randomMax(5, 13) : this.randomMax(8, 16),\n                distance: this.width + 100,\n                globAlpha: 1,\n                opac: 1,\n                endPos: this.randomMax(100, this.width),\n                start: 0,\n                time: 0,\n                explodeStart: 0,\n                explodeSize: window.innerWidth < 768 ? 20 : 35\n            };\n            data.push(measurements);\n        }\n    }.bind(this);\n\n    //When prototype.toggle = false this automatically gets ran to be able to run animation again\n    this.restoreData = function () {\n        data = [];\n        trailData = [];\n        j = 0;\n        this.addData();\n        menData.begin = null;\n    };\n\n    function drawHouse(image, timestamp) {\n        if (!image.start) image.start = timestamp;\n        var runtime = timestamp - image.start;\n        var progress = runtime / 2000;\n\n        var distance = image.rise * progress;\n\n        //Floating in place\n        if (image.currentY) {\n\n            image.toggle ? image.x = image.currentX - distance : image.x = image.currentX + distance;\n            image.toggle ? image.y = image.currentY + distance : image.y = image.currentY - distance;\n        }\n\n        if (distance >= image.rise) {\n            //Makes currentY true and updates postion of the image\n            image.currentY = image.y;\n            image.currentX = image.x;\n            image.toggle ? image.toggle = false : image.toggle = true;\n            image.start = 0;\n            image.rise = 50;\n        }\n        //Ends the first rise of the image\n        if (!image.currentY) {\n            image.x = image.startX() - image.moveLeft * progress;\n            image.y = image.startY() - image.rise * progress;\n        }\n\n        ctx.drawImage(image.houseImg, image.x, image.y, houseWidth, houseHeight);\n    }\n\n    function drawStars(cir) {\n        ctx.save();\n        ctx.globalAlpha = cir.alpha;\n\n        ctx.beginPath();\n        ctx.arc(cir.xPos, cir.yPos, cir.radius, 0, 2 * Math.PI);\n        ctx.fillStyle = 'rgba(255, 255, 73, ' + cir.opacity + ')';\n        ctx.fill();\n        ctx.restore();\n        lastPosition(cir.xPos, cir.yPos, cir.radius, cir.alpha);\n    }\n\n    function drawTrail(trail) {\n        ctx.save();\n        ctx.globalAlpha = 0.2;\n        ctx.beginPath();\n        ctx.arc(trail.x, trail.y, trail.rad, 0, 2 * Math.PI, true);\n        ctx.fillStyle = 'rgba(238,' + trail.color + ', 6, ' + trail.fade + ')';\n        ctx.fill();\n        ctx.restore();\n    }\n    function drawExplosion(circle, timestamp) {\n\n        if (!circle.explodeStart) circle.explodeStart = timestamp;\n        var runtime = timestamp - circle.explodeStart;\n        var progress = runtime / 400;\n        var ease = easeOut(progress);\n        ctx.beginPath();\n        ctx.arc(circle.xPos, circle.yPos, 0 + circle.explodeSize * ease, 0, 2 * Math.PI, true);\n        ctx.fillStyle = 'rgba(249, 255, 0, ' + (1 - .9 * progress) + ')';\n        ctx.fill();\n    }\n    function drawMen(men) {\n\n        if (menData.j >= 4 && menData.j <= 5) {\n            ctx.translate(men.translateX, men.translateY);\n            ctx.rotate(men.rotate * Math.PI / 180);\n            ctx.drawImage(men.img, -men.width / 2, -men.height, men.width, men.height);\n            ctx.setTransform(1, 0, 0, 1, 0, 0);\n        } else {\n            ctx.save();\n            ctx.globalAlpha = men.opac;\n            ctx.beginPath();\n            ctx.arc(men.arcX, men.arcY, men.arcRadius, 0, 2 * Math.PI);\n            ctx.fillStyle = \"#000\";\n            ctx.fill();\n            ctx.drawImage(men.img, men.x, men.y, men.width, men.height);\n            ctx.restore();\n        }\n    }\n\n    var draw = function (timestamp) {\n        if (!StarryNight.prototype.toggle) {\n            return this.restoreData();\n        }\n\n        //House\n        var image = this.house;\n\n        ctx.clearRect(0, 0, this.width, this.height);\n\n        //Men running start , Stars start after house gets to top. \n        if (image.currentY) {\n\n            //**  START OF STARS  **/\n\n            // Draws the trail opacity  \n            if (menData.j >= 1) {\n                for (var i = 0; i < trailData.length; i++) {\n                    var trail = trailData[i];\n                    var fadeSize = i / trailData.length;\n\n                    //Trail tapers as it goes.\n                    var radiusTaper = (trail.radius - 2) / trailData.length;\n                    trail.color = 240 - (i + j);\n                    trail.fade = i / trailData.length;\n\n                    //Tapers down the raidus of the trail\n                    trail.rad = trail.radius = trail.radius - radiusTaper;\n                    // trail.rad = trail.radius\n                    drawTrail(trail);\n                }\n\n                //Draws stars\n                for (var _i = 0; _i < data.length; _i++) {\n                    var circle = data[_i];\n\n                    if (j >= _i) {\n\n                        if (!circle.start) circle.start = timestamp;\n                        var _runtime = timestamp - circle.start;\n                        var _progress = _runtime / 2000;\n                        var ease = easeOut(_progress);\n                        circle.time = circle.delay - ease;\n\n                        //If the current circle delay = progress draws next circle, (random drawing look)\n                        if (circle.time <= 0) {\n\n                            //current circle set to undefined keep from running again\n                            circle.delay = undefined;\n                            j++;\n                        }\n                        circle.alpha = circle.globAlpha - 1 * _progress;\n                        circle.opacity = circle.opac - .9 * _progress;\n                        // circle.duration = ease\n\n                        if (j % 3 !== 0 && menData.j >= 1) {\n                            circle.xPos = circle.x + circle.endPos * ease;\n                            circle.yPos = 0 + circle.y * ease;\n                            ctx.globalCompositeOperation = 'destination-over';\n                        } else {\n                            circle.xPos = circle.x + circle.endPos * ease;\n                            circle.yPos = 0 + circle.y * _progress;\n                            ctx.globalCompositeOperation = 'source-over';\n                        }\n\n                        drawStars(circle);\n\n                        //Explosion start\n                        if (circle.xPos > image.x && circle.yPos > image.y) {\n\n                            drawExplosion(circle, timestamp);\n                        }\n\n                        if (j === data.length) {\n                            j = 0;\n                            data = [];\n                            trailData = [];\n                            this.addData();\n                        }\n                    }\n                }\n            }\n            //**  START OF MEN  **/\n            var menLength = starryNight.images.length - 1;\n\n            for (var _i2 = 0; _i2 < menLength; _i2++) {\n                var men = starryNight.images[_i2];\n\n                if (!menData.begin) menData.begin = timestamp;\n                var runtime = timestamp - menData.begin;\n                var progress = Math.min(runtime / 2000, 1);\n\n                //First walk out\n                if (menData.j === 0) {\n                    menData.start = parseInt((progress * 15).toFixed(0));\n                    menData.distanceX = window.innerWidth < 768 ? 95 : 205;\n                }\n                //Second Walk stands still\n                if (menData.j === 1) {\n                    //Starts and ends with last dude\n                    menData.start = 15;\n                    // Keeping count at last man instead of counting through them to animate\n                    menData.distanceX = 0;\n                }\n\n                //Third walk down and to the end\n                if (menData.j === 2) {\n                    menData.start = parseInt((progress * 15).toFixed(0));\n                    men.walkDown = Math.min(progress * 6, 1) * menData.stepDown;\n                    // menData.distanceX = 250\n                    menData.distanceX = window.innerWidth < 768 ? 159 : 250;\n                }\n\n                //Looks down\n                if (menData.j === 3) {\n                    var headIterate = Math.min(runtime / 1000, 1);\n\n                    //updates men.walkdown that gets ran before back to 0\n                    men.walkDown = 0;\n                    menData.start = 16;\n                    menData.distanceX = 0;\n                    men.arcX = image.x + (menData.lastPosX + (men.width / 2 + 2)) + menData.arcStartX * headIterate;\n                    men.arcY = image.y + (menData.lastPosY + 4) + menData.arcStartY * headIterate;\n                    men.arcRadius = menData.headArc;\n                }\n                //Rotates back and forth\n                if (menData.j === 4) {\n                    //2nd rotated position\n                    var newRotatedPos = menData.rotatedPos - (menData.rotateDegree * iterate - menData.rotatedPos);\n                    menData.start = 14;\n\n                    menData.distanceX = 0;\n\n                    men.translateX = image.x + (menData.lastPosX + men.width / 1.8);\n                    men.translateY = image.y + (menData.lastPosY + men.height);\n                    var iterate = Math.min(progress * 3, 3);\n\n                    if (menData.rotatedPos <= menData.rotateDegree) {\n                        menData.rotatedPos = menData.rotateDegree * iterate;\n                        men.rotate = menData.rotatedPos;\n                    } else {\n                        //Rotate back and forth\n                        if (newRotatedPos >= 0) men.rotate = newRotatedPos;\n                        if (newRotatedPos <= 0) men.rotate = -newRotatedPos;\n                    }\n\n                    //updates roatedPos for mendata.js = 5 to be used below\n                    if (progress === 1) {\n                        men.arcRadius = 0;\n                        menData.roatedPos = men.rotate;\n                    }\n                }\n                //Falls Down\n                if (menData.j === 5) {\n                    menData.start = parseInt((progress * 10).toFixed(0));\n\n                    men.translateX = image.x + (menData.lastPosX + men.width / 2) + this.width / 6 * progress;\n                    men.translateY = image.y + (menData.lastPosY + men.height) + this.height / 2 * progress;\n                    men.rotate = menData.roatedPos + 180 * progress;\n                    menData.distanceX = 0;\n                    if (progress === 1) men.opacity = 0;\n                }\n                if (menData.j === 6) {\n\n                    men.opac = men.opacity + 1 * progress;\n                }\n\n                if (men.startPos === menData.start) {\n\n                    //Constanatly updates men location on the House\n                    var lastX = menData.lastPosX + menData.distanceX * progress;\n                    var lastY = menData.lastPosY + (men.walkDown || 0);\n\n                    men.x = image.x + (menData.lastPosX + menData.distanceX * progress);\n                    men.y = image.y + (menData.lastPosY + (men.walkDown || 0));\n\n                    drawMen(men);\n\n                    if (progress < 1) {} else {\n                        //Resets or updates positions\n                        menData.lastPosX = lastX;\n                        menData.lastPosY = lastY;\n                        menData.j++;\n                        menData.begin = 0;\n                        menData.start = 0;\n                    }\n                }\n            }\n        };\n        drawHouse(image, timestamp);\n\n        requestAnimationFrame(draw);\n    }.bind(this);\n\n    document.querySelector('.animations .start-canvas').addEventListener('click', function () {\n\n        StarryNight.prototype.toggle = true;\n        requestAnimationFrame(draw);\n    }.bind(this));\n\n    document.querySelector('.animations .stop-canvas').addEventListener('click', function () {\n\n        StarryNight.prototype.toggle = false;\n    });\n}\n\nStarryNight.prototype.loadImages = function () {\n    var height = window.innerWidth < 768 ? 60 : 80;\n    var width = window.innerWidth < 768 ? 48 : 64;\n    var $this = this;\n    var count = 0;\n    var images = [];\n    var ext = isFirefox ? \"png\" : \"svg\";\n\n    var men = [{ src: \"images/men/zero.\" + ext, height: height, width: width }, { src: \"images/men/one.\" + ext, height: height, width: width }, { src: \"images/men/two.\" + ext, height: height, width: width }, { src: \"images/men/three.\" + ext, height: height, width: width }, { src: \"images/men/four.\" + ext, height: height, width: width }, { src: \"images/men/five.\" + ext, height: height, width: width }, { src: \"images/men/six.\" + ext, height: height, width: width }, { src: \"images/men/seven.\" + ext, height: height, width: width }, { src: \"images/men/eight.\" + ext, height: height, width: width }, { src: \"images/men/nine.\" + ext, height: height, width: width }, { src: \"images/men/ten.\" + ext, height: height, width: width }, { src: \"images/men/eleven.\" + ext, height: height, width: width }, { src: \"images/men/twelve.\" + ext, height: height, width: width }, { src: \"images/men/thirteen.\" + ext, height: height, width: width }, { src: \"images/men/fourteen.\" + ext, height: height, width: width }, { src: \"images/men/fifteen.\" + ext, height: height, width: width }, { src: \"images/men/headless.\" + ext, height: height, width: width }, { src: \"images/men/house-floating.\" + ext }];\n\n    for (var i = 0; i < men.length; i++) {\n\n        var img = new Image();\n\n        try {\n            throw i;\n        } catch (i) {\n            img.onload = function () {\n\n                images.push({\n                    img: this,\n                    height: men[i].height,\n                    width: men[i].width,\n                    start: 0,\n                    startPos: i\n                });\n\n                if (++count === men.length) {\n\n                    //Sorts the men array in order due to loading images differently\n                    images.sort(function (a, b) {\n                        return a.startPos - b.startPos;\n                    });\n\n                    starryNight.images = images;\n                    //updates the undefined house property with this img\n                    $this.house.houseImg = img;\n                    $this.addData();\n                    $this.house.begin();\n                }\n            };\n            img.src = men[i].src;\n        }\n    }\n};\n\nvar Technologies = function Technologies() {\n    var svgPageWidth = _('svg-page').getAttribute('width');\n    var svgPageHeight = _('svg-page').getAttribute('height');\n    var width = svgPageWidth < 970 || svgPageHeight < 800;\n    this.canvas = document.getElementById('techIcons');\n\n    this.ctx = this.canvas.getContext('2d');\n    this.width = this.canvas.width = svgPageWidth;\n    this.height = this.canvas.height = svgPageHeight;\n    this.start = 0;\n    this.start;\n    this.bodyData = [];\n    this.icons;\n    this.j = 0;\n    var newTechnologies = this;\n    this.data = {\n        addBodyData: function addBodyData() {\n\n            if (width) {\n                //Body location X and Y\n                return {\n                    x: newTechnologies.width / 2 - newTechnologies.bodyData[1].width / 2.2,\n                    y: newTechnologies.height - newTechnologies.bodyData[1].height,\n                    translateX: newTechnologies.width / 2 - newTechnologies.bodyData[3].width / 2 + 60,\n                    translateY: newTechnologies.height - newTechnologies.bodyData[1].height + 70,\n                    headX: newTechnologies.width / 2 - newTechnologies.bodyData[1].width / 2.2 + 41,\n                    headY: newTechnologies.height - newTechnologies.bodyData[1].height - 61\n                };\n            } else {\n                return {\n                    x: newTechnologies.width / 2 - newTechnologies.bodyData[1].width / 2.2,\n                    y: newTechnologies.height - newTechnologies.bodyData[1].height,\n                    //Translate head rotation\n                    translateX: newTechnologies.width / 2 - newTechnologies.bodyData[3].width / 2 + 85,\n                    //Translate head rotation\n                    translateY: newTechnologies.height - newTechnologies.bodyData[1].height + 100,\n                    headX: newTechnologies.width / 2 - newTechnologies.bodyData[1].width / 2.2 + 57,\n                    headY: newTechnologies.height - newTechnologies.bodyData[1].height - 87\n                };\n            }\n        },\n        rotate: -140,\n        j: 0,\n        bookHeight: 200\n    };\n\n    this.sprites = [];\n\n    var ext = isFirefox ? \"png\" : \"svg\";\n\n    var bodyWidth = width ? 1.3 : 1.8;\n    var bodyHeight = width ? 1.3 : 1.8;\n    var src = [\"images/top-head.\" + ext, \"images/face-body.\" + ext, \"images/book.\" + ext, \"images/full-body.\" + ext];\n\n    if (width) {\n\n        var imgWidth = [284.5, 400, 320.96, 400];\n        var imgHeight = [170.9, 483.7, 226.8, 564.66];\n    } else {\n        var imgWidth = [553.5, 778.2, 629.9, 778];\n        var imgHeight = [332.49, 941, 443.27, 1098.9];\n    }\n\n    this.imgIcons = [{ src: \"images/icons/adobe-50-50.\" + ext, width: 40, height: 40 }, { src: \"images/icons/after-effects-52-52.\" + ext, width: 40, height: 40 }, { src: \"images/icons/artistic-52-54.\" + ext, width: 40, height: 42 }, { src: \"images/icons/bootstrap-50-50.\" + ext, width: 40, height: 40 }, { src: \"images/icons/camera-52-52.\" + ext, width: 40, height: 40 }, { src: \"images/icons/cloud-64-49.5.\" + ext, width: 42, height: 32.5 }, { src: \"images/icons/code-60-53.\" + ext, width: 43, height: 38 }, { src: \"images/icons/css-55-52.\" + ext, width: 42, height: 39.8 }, { src: \"images/icons/design-52-52.\" + ext, width: 40, height: 40 }, { src: \"images/icons/git-hub-55-55.\" + ext, width: 43, height: 43 }, { src: \"images/icons/google-drive-72-64.\" + ext, width: 46, height: 40.8 }, { src: \"images/icons/illustrator-52-52.\" + ext, width: 40, height: 40 }, { src: \"images/icons/js-55-56.\" + ext, width: 41, height: 42 }, { src: \"images/icons/node-50-50.\" + ext, width: 40, height: 40 }, { src: \"images/icons/nodejs-60.5-37.\" + ext, width: 55, height: 33.6 }, { src: \"images/icons/npm-70-27.2.\" + ext, width: 65, height: 25.2 }, { src: \"images/icons/photoshop-52-52.\" + ext, width: 40, height: 40 }, { src: \"images/icons/php-65-35.\" + ext, width: 45, height: 24.2 }, { src: \"images/icons/python-57-58.\" + ext, width: 40, height: 40.7 }, { src: \"images/icons/react-59-52.\" + ext, width: 42, height: 37 }, { src: \"images/icons/server-55-58.\" + ext, width: 40, height: 40 }];\n\n    this.loopImgs = function () {\n        var load = [];\n\n        for (var j = 0; j < 4; j++) {\n            load.push({\n                src: src[j],\n                width: imgWidth[j] / bodyWidth,\n                height: imgHeight[j] / bodyHeight\n            });\n        }\n        var icons = this.imgIcons;\n\n        for (var i = 0; i < icons.length; i++) {\n            var w = !width ? icons[i].src.replace(/^([a-z\\/]+)\\/([a-z-?]+)-(\\d\\d)(.+)/ig, \"$3\") : icons[i].width;\n            var h = !width ? icons[i].src.replace(/^(.+)(\\d{2})(.+)/ig, \"$2\") : icons[i].height;\n            // console.log(w,h, i);\n            load.push({\n                src: icons[i].src,\n                width: parseInt(w),\n                height: parseInt(h)\n            });\n        }\n        return load;\n    };\n    function random(min, max) {\n        return Math.floor(Math.random() * (max - min) + min);\n    };\n    this.addData = function (n) {\n        var icons = this.icons;\n        for (var i = 0; i < n; i++) {\n\n            this.sprites.push({\n                //Each icon draws for ever 30 mil sec\n                timing: 30,\n                endX: random(0, this.width / 2),\n                endY: random(0, this.height - (this.bodyData[1].height + 50)),\n                start: 0,\n                speed: random(4000, 9000),\n                x: this.width / 2,\n                y: this.data.addBodyData().y + 15, // plus 100 the sprite size\n                img: this.icons[i % icons.length].img,\n                width: this.icons[i % icons.length].width,\n                height: this.icons[i % icons.length].height,\n                X: 0,\n                Y: 0,\n                staticSpeed: 0,\n                rotate: random(180, 1440)\n            });\n        }\n    };\n};\n\nTechnologies.prototype.rotateHead = function (rotate, pos) {\n\n    var img = this.bodyData;\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.ctx.drawImage(img[1].img, pos.x, pos.y, img[1].width, img[1].height); //Face body\n    this.ctx.translate(pos.translateX, pos.translateY); // Translate \n    this.ctx.rotate(rotate * Math.PI / 180);\n    this.ctx.translate(-pos.translateX, -pos.translateY); // Translate back\n    this.ctx.drawImage(img[0].img, pos.headX, pos.headY, img[0].width, img[0].height); //Head draw in translated canves\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n};\n\nTechnologies.prototype.drawBook = function (data, pos) {\n    var img = this.bodyData;\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.ctx.globalCompositeOperation = 'destination-over';\n    this.ctx.drawImage(img[1].img, pos.x, pos.y, img[1].width, img[1].height); //Face body\n    this.ctx.translate(pos.translateX, pos.translateY); // Translate \n    this.ctx.rotate(-140 * Math.PI / 180);\n    this.ctx.translate(-pos.translateX, -pos.translateY); // Translate back\n    this.ctx.drawImage(img[0].img, pos.headX, pos.headY, img[0].width, img[0].height); //Head draw in translated canves\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n\n    this.ctx.translate(pos.translateX + img[2].width / 2, pos.translateY); // Translate  \n    this.ctx.scale(data.scale, data.scale); //Scales book\n    this.ctx.translate(-pos.translateX - img[2].width / 2, -pos.translateY); // Translate back for\n    this.ctx.drawImage(img[2].img, data.bookX, data.bookY, img[2].width, img[2].height); //book image\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n};\n\nTechnologies.prototype.drawBody = function (data, pos) {\n    var img = this.bodyData;\n\n    this.ctx.drawImage(img[1].img, pos.x, pos.y, img[1].width, img[1].height); //Face body\n    this.ctx.translate(pos.translateX, pos.translateY); // Translate \n    this.ctx.rotate(-140 * Math.PI / 180);\n    this.ctx.translate(-pos.translateX, -pos.translateY); // Translate back\n    this.ctx.drawImage(img[0].img, pos.headX, pos.headY, img[0].width, img[0].height); //Head draw in translated canves\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.translate(pos.translateX + img[2].width / 2, pos.translateY); // Translate  \n    this.ctx.scale(1.05, 1.05);\n    this.ctx.translate(-pos.translateX - img[2].width / 2, -pos.translateY); // Translate back\n    this.ctx.drawImage(img[2].img, data.bookX, data.bookY, img[2].width, img[2].height); //book image\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n};\n\nTechnologies.prototype.drawIcons = function (spr) {\n    this.ctx.setTransform(1, 0, 0, 1, spr.X, spr.Y);\n    this.ctx.rotate(spr.turn * Math.PI / 180);\n    this.ctx.drawImage(spr.img, -spr.width / 2, -spr.height / 2, spr.width, spr.height);\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n};\n\nTechnologies.prototype.draw = function (timestamp) {\n    if (!this.toggle) return;\n    var width = this.width < 970 || this.height < 800;\n    var img = this.bodyData;\n    var data = this.data;\n    var pos = data.addBodyData();\n\n    if (!this.start) this.start = timestamp;\n    var runtime = timestamp - this.start;\n    var progress = Math.min(runtime / 1000, 1);\n\n    if (progress < 1 && data.j <= 1) {\n\n        if (width) {\n            //Updates x loactions and y location of book\n            data.bookX = pos.translateX - 40 - 0;\n            data.bookY = pos.translateY - 110 - 60 * progress;\n        } else {\n            //Updates x loactions and y location of book\n            data.bookX = pos.translateX - 60 - 0;\n            data.bookY = pos.translateY - 180 - 60 * progress;\n        }\n        //Rotate head\n        if (data.j === 0) {\n\n            var rotate = data.rotate * progress;\n            this.rotateHead(rotate, pos);\n        }\n        //PUsh up book\n        if (data.j === 1) {\n\n            data.scale = .5 + .55 * progress;\n            this.drawBook(data, pos);\n        }\n    } else {\n\n        //Draw Icons\n        if (data.j === 2) {\n            this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n            this.drawBody(data, pos);\n\n            var sprites = this.sprites.length;\n\n            for (var i = 0; i < sprites; i++) {\n\n                var spr = this.sprites[i];\n\n                if (i <= this.j) {\n\n                    spr.staticSpeed++;\n\n                    if (!spr.start) spr.start = timestamp;\n                    var run = timestamp - spr.start;\n                    var prog = run / spr.speed;\n\n                    if (i % 2) {\n                        //left up\n                        spr.X = spr.x - spr.endX * prog;\n                        spr.Y = spr.y - spr.endY * prog;\n                        spr.turn = -spr.rotate * prog;\n                    } else {\n                        //right up;\n                        spr.X = spr.x + spr.endX * prog;\n                        spr.Y = spr.y - spr.endY * prog;\n                        spr.turn = spr.rotate * prog;\n                    }\n\n                    spr.totalX = spr.X;\n                    spr.totalY = spr.Y;\n\n                    if (spr.totalX + spr.width <= 0 || spr.totalY + spr.height <= 0 || spr.totalX > this.width + spr.width) {\n\n                        //Resets values, for same icon to run again\n                        this.sprites[i].start = 0;\n                    }\n                    this.drawIcons(spr);\n                    if (spr.staticSpeed === spr.timing) this.j++;\n                }\n            }\n        } else {\n            this.start = 0;\n            data.j++;\n        }\n    }\n    requestAnimationFrame(this.draw.bind(this));\n};\n\nTechnologies.prototype.loadImages = function () {\n    var $this = this;\n    var counter = 0;\n    var loadedImages = 0;\n    var imgs = [];\n\n    this.loopImgs().forEach(function (image, i) {\n        counter++;\n        var img = new Image();\n\n        img.onload = function () {\n\n            //Width or height doesn't exist updates 0 for it\n            imgs.push({ img: this, i: i, width: image.width, height: image.height });\n\n            if (++loadedImages >= counter) {\n                imgs.sort(function (a, b) {\n                    return a.i - b.i;\n                });\n                //When Icons load full body image gets added\n                $this.ctx.drawImage(imgs[3].img, $this.width / 2 - imgs[1].width / 2.2, $this.height - imgs[3].height, imgs[3].width, imgs[3].height); //Full-body image\n\n                var bodyImgs = imgs.splice(0, 4);\n\n                $this.bodyData = bodyImgs;\n                $this.icons = imgs;\n\n                //Icon data\n                $this.addData(imgs.length);\n            }\n        };\n        img.src = image.src;\n    });\n};\n\nfunction SvgPage() {\n    var svgCloseButton = document.getElementsByClassName('close-btn svg-button')[0];\n    var svgCircle = document.getElementsByClassName('svg-circle')[0];\n    var toggle, btnOpen, event;\n    var hovermap = hoverMap();\n\n    var removeGooey = function removeGooey(e) {\n        setTimeout(function () {\n            hovermap[1](e);\n        }, 1400);\n\n        //    console.log( hovermap[1])\n        //     var dist = hovermap[1](e)[0]; // Position distance of show-icon gooey\n        //     hovermap[0]( dist, true )  // handler(e) function\n    };\n    this.start;\n    //Page animated down removes circle to be animated again\n    this.animateEnd = function (e) {\n        console.log('hey you');\n        _('interactive-container').style.pointerEvents = 'auto';\n\n        if (toggle) {\n            //Safari only\n            _('svg-page').style.visibility = 'hidden';\n            svgCircle.classList.remove('circle-animate');\n\n            _(btnOpen)[0].style.display = 'none';\n            document.querySelector('g.' + btnOpen + ' .items').classList.remove('items-active');\n\n            toggle = false;\n        }\n    };\n\n    this.animateCircle = function (timestamp, elem) {\n\n        if (!this.start) this.start = timestamp;\n\n        var runtime = timestamp - this.start;\n        var progress = Math.min(runtime / this.speed, 1);\n        isFirefox ? svgCircle.setAttribute('r', 1500 * progress) : svgCircle.style.transform = 'scale(' + (0 + 1 * progress) + ')';\n\n        if (progress < 1) {\n            requestAnimationFrame(function (timestamp) {\n                this.animateCircle(timestamp, elem);\n            }.bind(this));\n        } else {\n            //Canvas fades in after page is animated open\n            document.querySelector('g.' + elem + ' .items').classList.add('items-active');\n            document.getElementsByClassName(elem)[1].parentElement.classList.add('showCanvas');\n            this.start = null;\n        }\n    };\n    var closeButtonShow = function closeButtonShow(num) {\n        var opposite = !num ? -56 : 0;\n        _('x-circle').style.transform = 'translateX(' + num + 'px)';\n        _('line')[0].style.transform = 'translateX(' + opposite + 'px) rotate(-45deg)';\n        _('line')[1].style.transform = 'translateX(' + opposite + 'px) rotate(45deg)';\n    };\n\n    // Open page function\n    this.openModals = function (e) {\n\n        try {\n            btnOpen = e.target.id;\n        } catch (err) {\n            btnOpen = e;\n        }\n\n        _('interactive-container').style.pointerEvents = 'none';\n        event = e;\n        _(btnOpen)[0].style.display = 'block';\n        closeButtonShow(-56);\n        //Google 'Do Hyeon' font bug, function has to be ran again in view\n        if (btnOpen === 'photo') slotMachine();\n        //Throbbing Finger image icon\n        if (btnOpen === 'design') document.getElementById('finger').classList.add('finger-scale');\n\n        if (isSafari) {\n\n            toggle = true;\n            _('svg-page').style.visibility = \"visible\";\n            svgCircle.classList.add('circle-animate');\n\n            svgCircle.onanimationend = function () {\n\n                document.querySelector('g.' + btnOpen + ' .items').classList.add('items-active');\n                document.getElementsByClassName(btnOpen)[1].parentElement.classList.add('showCanvas');\n            };\n\n            //Closes the page animated down\n            svgCloseButton.addEventListener('click', function () {\n                toggle = true;\n\n                //Automatically stops canvas \n                Stretch.prototype.toggle = false;\n                slotMachine.prototype.toggle = false;\n                StarryNight.prototype.toggle = false;\n                Technologies.prototype.toggle = false;\n\n                //Canvas / Items fades out\n                document.getElementsByClassName(btnOpen)[1].parentElement.classList.remove('showCanvas');\n            });\n        } else {\n            toggle = false;\n\n            requestAnimationFrame(function (timestamp) {\n                this.speed = 600;\n                this.animateCircle(timestamp, btnOpen);\n            }.bind(this));\n\n            svgCloseButton.addEventListener('click', function (e) {\n                closeButtonShow(0);\n                Stretch.prototype.toggle = false;\n                slotMachine.prototype.toggle = false;\n                StarryNight.prototype.toggle = false;\n                Technologies.prototype.toggle = false;\n                document.getElementsByClassName(btnOpen)[1].parentElement.classList.remove('showCanvas');\n\n                setTimeout(function () {\n                    isFirefox ? _('svg-circle').setAttribute('r', 0) : _('svg-circle').style.transform = 'scale(0)';\n\n                    //Current SVG element hides\n                    document.getElementsByClassName(btnOpen)[0].style.display = 'none';\n                    document.querySelector('g.' + btnOpen + ' .items').classList.remove('showCanvas');\n                    // document.getElementsByClassName(btnOpen)[1].parentElement.classList.remove('showCanvas')\n                }, 1900);\n            });\n        }\n    }.bind(this);\n\n    var popUpCards = function () {\n        var open_modals = this.openModals;\n\n        var popUpcards = _('card-popups');\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n            for (var _iterator = popUpcards[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var cards = _step.value;\n\n                cards.addEventListener('click', function (e) {\n                    removeGooey(e);\n                    open_modals(this.attributes[3].value);\n                });\n            }\n        } catch (err) {\n            _didIteratorError = true;\n            _iteratorError = err;\n        } finally {\n            try {\n                if (!_iteratorNormalCompletion && _iterator.return) {\n                    _iterator.return();\n                }\n            } finally {\n                if (_didIteratorError) {\n                    throw _iteratorError;\n                }\n            }\n        }\n    }.bind(this);\n    if (wW < 768) popUpCards();\n\n    _('circle-thumbnails').addEventListener('click', function (e) {\n        if (wW < 768) {\n            hovermap[1](e);\n        } else {\n            removeGooey(e);\n            this.openModals(e);\n        }\n    }.bind(this));\n};\n//Add to window object to be used for html page onend function\nwindow.svgPage = new SvgPage();\n\nfunction getPos(ele) {\n\n    var elemRect = ele.getBoundingClientRect();\n    var mainSvg = document.getElementsByClassName('svg-page')[0].getBoundingClientRect();\n    var elemLeft = (mainSvg.width - (parseInt(ele.getAttribute('width')) || elemRect.width)) / 2;\n\n    return {\n        width: elemRect.width,\n        mainSvg: mainSvg,\n        left: elemRect.left,\n        top: elemRect.top,\n        height: elemRect.height,\n        //Places image's property left to the center of it's container (center of page)\n        centeredLeft: elemLeft\n    };\n};\n\n//Different screen sizing , elements adjust to it\nfunction adjustElements() {\n    var pathD768 = \"M565.1,0v900H0c0,0,0-75.3,0-192.4c0-211.7,0-303.7,0-533.1C0,50.5,0,0,0,0H565.1z\";\n    var pathD400 = \"M390,800H0c0,0,0-87.3,0-161.3S0,84,0,47.3S0,0,0,0h390V800z\";\n    var smallSplines = \".42 0 1 1;.42 0 1 1;.42 0 1 1;.42 0 1 1;\";\n    var smallKeyTimes = \"0; 0.20; 0.45; 1\";\n    var svg = document.getElementsByClassName('svg-page')[0];\n\n    //Sets sizing for opening closing svg-page wave\n    if (wH < 840 && wW) {\n        var svgWidth = wW < 500 ? wW - 20 : wW - 50;\n        var svgHeight = wH < 680 ? wH - 15 : wH - 50;\n    } else {\n        var svgWidth = wW < 500 ? wW - 20 : wW - 50;\n        var svgHeight = 840;\n    }\n\n    if (wW <= 615) {\n        document.getElementById('path').setAttribute('d', pathD768);\n        _('path').setAttribute('values', animate768);\n        _('path').setAttribute('keyTimes', smallKeyTimes);\n        _('path').setAttribute('keySplines', smallSplines);\n    }\n\n    if (wW <= 400) {\n        document.getElementById('path').setAttribute('d', pathD400);\n        _('path').setAttribute('values', animate400);\n    }\n\n    if (wW >= 970 && wH) {\n\n        svg.setAttribute(\"height\", svgHeight);\n    } else {\n        if (wH > 840) {\n\n            svg.setAttribute(\"viewBox\", \"0 0 \" + \" \" + svgWidth + \" \" + svgHeight);\n            svg.setAttribute(\"width\", svgWidth);\n            svg.setAttribute(\"height\", svgHeight);\n        }\n        if (wH < 840) {\n            svg.setAttribute(\"viewBox\", \"0 0 \" + \" \" + svgWidth + \" \" + svgHeight);\n            svg.setAttribute(\"width\", svgWidth);\n            svg.setAttribute(\"height\", svgHeight);\n        }\n    }\n\n    if (wW && wH) {\n\n        //Add to element when more canvases are added to HTML\n        var elementG = document.querySelectorAll('g.photo, g.developer, g.design, g.animations, g.technologies');\n\n        elementG.forEach(function (el, i) {\n            var groupName = el.classList[0];\n\n            if (groupName === 'photo') {\n                var canvas = document.getElementById('slot-machine');\n                document.getElementById('canvas-area').setAttribute('transform', 'translate(157, 0)');\n\n                Array.prototype.forEach.call(el.children, function (elem, i) {\n\n                    //Camera SVG\n                    if (i === 0) {\n\n                        var newHeight = newSize('width', 700, elem).height;\n\n                        elem.setAttribute('width', 700);\n                        elem.setAttribute('height', newHeight);\n\n                        var _pos = getPos(elem);\n                        var setAttributeY = _pos.mainSvg.height - newHeight - 5;\n\n                        elem.setAttribute('x', _pos.centeredLeft);\n                        elem.setAttribute('y', setAttributeY);\n\n                        if (wW <= 500 || wH <= 800) {\n\n                            elem.style.visibility = 'hidden';\n                        }\n                    }\n                    //ForeignObject holds canvas\n                    if (i === 2) {\n\n                        if (wW < 970) {\n                            var canvasArea = document.getElementById('canvas-area');\n\n                            var _pos2 = getPos(canvasArea);\n\n                            if (wH < 640 && wW < 800) {\n\n                                elem.setAttribute('y', 240);\n                            } else {\n\n                                //firefox\n                                !isFirefox ? elem.setAttribute('y', svg.getAttribute('height') - _pos2.height - 16) : svg.getAttribute('width') / 2 - 397.6 / 2;\n                                elem.setAttribute('y', svg.getAttribute('height') - 397.6 - 16);\n                                // elem.setAttribute('y', 250)\n                            }\n\n                            elem.setAttribute('width', 360);\n                            elem.setAttribute('height', 360);\n                            !isFirefox ? elem.setAttribute('x', _pos2.left - 6) : elem.setAttribute('x', svg.getAttribute('width') / 2 - 397.6 / 2 + 20);\n                            // elem.setAttribute('y', svg.getAttribute('height') - pos.height - 16)\n                        } else {\n                            var posHeight = getPos(elem);\n                            var width = parseInt(elem.getAttribute('width'));\n                            var elemLeft = posHeight.mainSvg.width - width - 15;\n\n                            elem.setAttribute('y', 60);\n                            elem.setAttribute('x', elemLeft);\n                        }\n\n                        if (wW <= 500) {\n                            var _thisPos = getPos(elem);\n                            elem.setAttribute('x', _thisPos.centeredLeft);\n\n                            if (wH < 620) {\n                                elem.setAttribute('y', 200);\n                            }\n                        }\n                    }\n                    //Items\n                    if (i === 1) {\n                        var pos = getPos(document.getElementById('canvas-area'));\n\n                        elem.childNodes[1].setAttribute('width', 400);\n                        elem.childNodes[1].setAttribute('height', 235);\n                        elem.childNodes[1].setAttribute('x', 20);\n                        if (wW < 970) {\n                            elem.childNodes[1].setAttribute('y', 0);\n                        } else {\n                            elem.childNodes[1].setAttribute('y', 100);\n                        }\n                        if (window.innerWidth <= 500) {\n                            elem.childNodes[1].setAttribute('width', 335);\n                            elem.childNodes[1].setAttribute('x', 10);\n                            var thisPos = getPos(elem.childNodes[1]);\n                        }\n                    }\n                });\n            };\n            if (groupName === 'developer') {\n                Array.prototype.forEach.call(el.children, function (elem, i) {\n\n                    //foreignObject holds canvas\n                    if (i === 1) {\n                        if (wW < 970) {\n                            elem.setAttribute('width', 400);\n                            elem.setAttribute('height', 375);\n                        }\n                        var pos = getPos(el.children[0]);\n                        elem.setAttribute('y', 200);\n\n                        if (window.innerWidth <= 850) {\n                            if (wH < 690) {\n                                elem.setAttribute('y', 25);\n                                elem.setAttribute('x', 5);\n                            } else {\n                                elem.setAttribute('x', 50);\n                                elem.setAttribute('y', 75);\n                            }\n                        }\n                        if (window.innerWidth < 505) {\n                            if (wH < 690) {\n                                elem.setAttribute('y', 50);\n                                elem.setAttribute('x', 0);\n                            }\n                            elem.childNodes[1].setAttribute('width', 360);\n                            elem.setAttribute('height', 375);\n\n                            var thisPos = getPos(elem.childNodes[1]);\n                            elem.setAttribute('y', 50);\n                            elem.setAttribute('x', 5);\n                        }\n                    }\n                    //items\n                    if (i === 0) {\n                        if (window.innerWidth < 505) {\n                            elem.childNodes[1].setAttribute('x', 10);\n                            elem.childNodes[1].setAttribute('y', 424);\n                            elem.childNodes[1].setAttribute('width', 370);\n                        }\n                        if (wW > 505 && wW < 850) {\n                            if (wH < 690) {\n                                elem.childNodes[1].setAttribute('y', 425);\n                                elem.childNodes[1].setAttribute('width', 370);\n                            } else elem.childNodes[1].setAttribute('y', 460);\n                        }\n                    }\n                });\n            }\n            if (groupName === 'design') {\n                var items = el.children[0].children[0];\n                var canvasArea = el.children[1];\n\n                if (wH && wW > 970) {\n\n                    if (canvasArea) {\n                        if (wW > 1200) {\n                            canvasArea.setAttribute('width', 580);\n                            canvasArea.setAttribute('height', 580);\n                        }\n                        canvasArea.setAttribute('y', 80);\n                    }\n                    if (items) {\n                        items.setAttribute('y', 200);\n                    }\n                } else if (wW > 750 && wW < 970) {\n\n                    if (canvasArea) {\n                        //For Safari overflow not working\n                        wW < 810 ? canvasArea.setAttribute('x', 210) : canvasArea.setAttribute('x', 255);\n                        canvasArea.setAttribute('y', 160);\n                        if (wH < 703) {\n                            //For Safari overflow not working\n                            canvasArea.setAttribute('height', 450);\n                        }\n                    }\n                    if (items) {\n                        items.setAttribute('y', 0);\n                    }\n                } else {\n                    items.setAttribute('y', 0);\n                    items.setAttribute('x', 10);\n                    wH < 700 ? items.setAttribute('height', 250) : items.setAttribute('height', 260);\n                    items.setAttribute('width', 340);\n\n                    var height = items.getAttribute('height');\n                    canvasArea.setAttribute('y', height);\n\n                    wW < 600 ? canvasArea.setAttribute('width', 400) : canvasArea.setAttribute('width', 500);\n                    wW < 600 ? canvasArea.setAttribute('height', 400) : canvasArea.setAttribute('height', 500);\n\n                    var canvasPos = getPos(canvasArea);\n                    canvasArea.setAttribute('x', canvasPos.centeredLeft);\n                    //For safari, so photo doesn't show the overflow\n                    canvasArea.setAttribute('height', svg.getAttribute('height') - items.getAttribute('height'));\n                }\n            }\n            if (groupName === 'animations') {\n                var items = el.children[0].children[0];\n                var canvasArea = el.children[1];\n                var svgPageHeight = svg.getAttribute('height');\n\n                if (wH && wW > 970) {\n                    canvasArea.setAttribute('height', svgPageHeight);\n                }\n                if (wW < 768) {\n                    var _bottom = (svg.getAttribute('height') - 310) / 2;\n                    items.setAttribute('x', 15);\n                    items.setAttribute('y', _bottom);\n                    items.setAttribute('height', 320);\n                    items.setAttribute('width', 370);\n                } else {\n                    canvasArea.setAttribute('height', svgPageHeight);\n                }\n            }\n            if (groupName === 'technologies') {\n                var items = el.children[0].children[0];\n                var canvasArea = el.children[1];\n\n                if (wW < 650 && wH < 655) {\n                    var bottom = (svg.getAttribute('height') - 370) / 2;\n                    items.setAttribute('y', bottom);\n                    items.setAttribute('x', 5);\n                }\n            }\n        });\n    }\n};\n\nif (wW < 970 || wH < 800) {\n    adjustElements();\n} else {\n    //Adds margin between full height threshhold for svg-page\n    if (wH < 840) {\n        _('svg-page').setAttribute('height', wH - 40);\n    }\n    if (wW < 1000) {\n        _('svg-page').setAttribute('width', wW - 40);\n    }\n    var designCanvas = document.querySelector('.design .item-canvas');\n    designCanvas.setAttribute('width', 580);\n    designCanvas.setAttribute('height', 580);\n}\n\n//Moves close button to right of svg-page\nfunction placeCloseButton() {\n\n    var btnPos = getPos(_('close-btn'));\n    _('close-btn').style.transform = 'translateX(' + (btnPos.mainSvg.width - 56) + 'px)';\n}\nplaceCloseButton();\n\nfunction hoverMap() {\n    var btnWrap = _('button-wrap');\n    var dist;\n    var lastDist;\n    var currentPath; //Path to be removed when mouseout\n\n    var mouseOut = function mouseOut(dist) {\n        // dist from opening popups to remove pointer\n        var pointerDist = typeof dist === 'number' ? dist : lastDist;\n\n        _('oval-pointer').style.transform = 'translate(-80px, 0px )';\n\n        if (isFirefox) {\n\n            _('show-icon').style.transform = 'translate(-24px,' + pointerDist + 'px )';\n        } else if (isSafari) {\n\n            _('show-icon').style.transform = 'translate(-24px,' + pointerDist + 'px )';\n        } else {\n\n            _('show-icon').style.transform = 'translate(-22px,' + pointerDist + 'px )';\n        }\n    };\n\n    if (wW > 768) btnWrap.onmouseover = handler;\n\n    function handler(e) {\n        dist = getDistance(e.target.className, e.target.id);\n\n        function getDistance(el, id) {\n            var totalDist = function totalDist(n) {\n                return n * 37;\n            };\n            var nodelist = _(el);\n            var elArray = [].slice.call(nodelist);\n\n            for (var i = 0; i < elArray.length; i++) {\n                if (elArray[i].id == id) return totalDist(i);\n            }\n        }\n\n        function getPathElement(el, map_paths) {\n            var newPathArray = [];\n            var pathArray = [].slice.call(map_paths);\n\n            //Puts elements in correct order\n            for (var i = pathArray.length - 1; i >= 0; i--) {\n                newPathArray.push(pathArray[i]);\n            }\n\n            var target = document.getElementById(el);\n            var targetArray = [].slice.call(_(target.className));\n\n            for (var i = 0; i < targetArray.length; i++) {\n                if (targetArray[i] === target) return newPathArray[i];\n            }\n        };\n\n        var animateGooey = function animateGooey() {\n\n            if (!_('show-icon').classList.contains('icon-transition')) {\n\n                // transforms only up and down before out.\n                _('show-icon').style.transform = 'translate(-22px,' + dist + 'px )';\n\n                setTimeout(function () {\n                    _('show-icon').classList.add('icon-transition');\n                    _('show-icon').style.transform = 'translate(-15px,' + dist + 'px )';\n                    _('oval-pointer').style.transform = 'translate(0px, 0px )';\n                }, 100);\n            } else {\n                _('show-icon').style.transform = 'translate(-15px,' + dist + 'px )';\n                _('oval-pointer').style.transform = 'translate(0px, 0px )';\n            }\n        };\n\n        var animatePathLines = function animatePathLines(path, map_paths) {\n            var classId = path.id.replace(/-sm$/ig, \"\");\n\n            for (var i = 0; i < map_paths.length; i++) {\n                //Removes all classes before target element class gets added\n                if (map_paths[i].classList.length === 2) {\n\n                    var className = map_paths[i].classList[1];\n                    map_paths[i].classList.remove(className);\n                }\n            }\n            path.classList.add(classId);\n            return classId;\n        };\n\n        var removeCardsClass = function removeCardsClass(target) {\n\n            var card = _('card-icon');\n            var length = card.length;\n\n            while (length--) {\n                var styleTransform = +card[length].style.transform.replace(/([^-\\d])/ig, '');\n                if (styleTransform !== 0) card[length].style.transform = 'translateY(0px)';\n            }\n        };\n        var animateCardsUp = function animateCardsUp(path) {\n\n            var card = _('card-icon');\n            var regEx = /-.+$/ig;\n            var target = path.id.replace(regEx, '');\n            var length = card.length;\n\n            //If target also has 2 classList, remove that class and add p0opupcard\n            while (length--) {\n                var cardParent = card[length].parentNode;\n                var styleTransform = +card[length].style.transform.replace(/([^-\\d])/ig, '');\n\n                if (target === cardParent.id.replace(regEx, '')) {\n                    // card[length].style.transform = 'translateY(-140px)'\n\n                    card[length].style.transform = 'translateY(-140px)';\n                } else if (styleTransform !== 0) {\n                    card[length].style.transform = 'translateY(0px)';\n                }\n            }\n        };\n\n        function AnimateCircles(path, map_paths) {\n\n            var circles = document.querySelectorAll('#pulse-circles circle');\n            var paths = [];\n            //Removes all classes before target elements classes gets added\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n                for (var _iterator2 = circles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                    var cir = _step2.value;\n\n                    if (cir.classList.length > 1) {\n                        cir.classList.remove(cir.classList[1]);\n                    }\n                }\n                //Stops before error when not passing arguments from click handler\n            } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                        _iterator2.return();\n                    }\n                } finally {\n                    if (_didIteratorError2) {\n                        throw _iteratorError2;\n                    }\n                }\n            }\n\n            if (!arguments.length) return;\n\n            //Pairs circles and returns the pairs so classes can be added\n            var pairCircles = function pairCircles() {\n                var cir = [];\n                for (var j = 0; j < circles.length; j += 2) {\n\n                    cir.push([circles[j], circles[j + 1]]);\n                }\n                return cir;\n            };\n\n            for (var i = 0; i < map_paths.length; i++) {\n\n                paths.unshift(map_paths[i].id);\n            }\n\n            var index = paths.indexOf(path.id);\n            var cirPairs = pairCircles()[index];\n\n            cirPairs[0].classList.add('middle-pulse');\n            cirPairs[1].classList.add('ring-pulse');\n        };\n\n        var removeCircles = function removeCircles(string) {\n            var activeCircles = document.querySelectorAll('.middle-pulse, .ring-pulse');\n\n            var _iteratorNormalCompletion3 = true;\n            var _didIteratorError3 = false;\n            var _iteratorError3 = undefined;\n\n            try {\n                for (var _iterator3 = activeCircles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n                    var cir = _step3.value;\n\n\n                    cir.addEventListener('animationend', function (e) {\n\n                        e.target.classList.remove(e.target.classList[1]);\n                    });\n                }\n            } catch (err) {\n                _didIteratorError3 = true;\n                _iteratorError3 = err;\n            } finally {\n                try {\n                    if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                        _iterator3.return();\n                    }\n                } finally {\n                    if (_didIteratorError3) {\n                        throw _iteratorError3;\n                    }\n                }\n            }\n        };\n        function removeAll(string) {\n            removeCircles(string);\n            mouseOut(dist);\n            removeCardsClass();\n            try {\n                //Path to be removed when mouseout\n                document.getElementById(currentPath).classList.remove(currentPath);\n            } catch (err) {}\n        }\n        function handleMap(e) {\n            var target = e.target.classList.value;\n\n            //If click comes from opening svg modals\n            if (target === 'card-color-st39' || wW > 768 && e.type === 'click') {\n\n                return removeAll(path);\n            }\n            // mouse over\n            if (e.target.id) {\n                //Start the path animated lines\n                var map_paths = wW > 768 ? _('map-paths') : _('map-paths-sm');\n                var path = getPathElement(e.target.id, map_paths);\n\n                //Used to update translate for button location\n                lastDist = dist;\n\n                animateGooey();\n                currentPath = animatePathLines(path, map_paths);\n                AnimateCircles(path, map_paths);\n                animateCardsUp(path);\n\n                //Only runs after mouseover elements run first, then initiated. \n                _('interactive-container').onmouseover = function (e) {\n                    if (e.target.className !== 'open-canvas-page' && wW > 768) {\n\n                        removeAll();\n                    }\n                };\n            }\n        }\n\n        if (e.type == 'mouseover' && wW > 768) {\n            handleMap(e);\n        } else if (e.type === 'click') {\n\n            handleMap(e);\n        }\n        return [dist];\n    }\n    return [mouseOut, handler]; // To be able to use mouseOut function and handler function that returns dist to use for mouseOut Func\n};\n\nvar toggleStars = {\n    toggle: false\n};\n\nvar robotSection = function robotSection(e) {\n\n    var stars = [];\n    var animateStars = function animateStars() {\n\n        var canvas = document.getElementById('star-canvas');\n        var ctx = canvas.getContext('2d');\n        var width = canvas.width = window.innerWidth;\n        var height = canvas.height = window.innerHeight;\n\n        var randomWidth = function randomWidth() {\n            //max and min\n            return Math.random() * (width / 2 - width / 9) + width / 9;\n        };\n\n        var NightStars = function NightStars() {\n            var _this3 = this;\n\n            var randomStart = randomWidth();\n\n            this.duration = 2000; //used to delay stars\n            this.radius = 13 + Math.random() * 5; //size of stars\n\n            this.i = 0; //x and y speed\n            this.k = 0; //opacity speed\n\n            this.start = {\n                y: Math.random() * height\n            };\n\n            this.Flicker = function (increntment) {\n                return Math.cos(increntment - Math.PI / 180) * .2;\n            };\n\n            this.radSize = function (increntment) {\n                return Math.sin(increntment - Math.PI / 180) * 7;\n            };\n\n            this.x = function (increntment, starSize) {\n                //full screen animate change this.randomWidth back to width / 2\n                return Math.cos(increntment - Math.PI / 180) * (randomStart + starSize);\n            };\n\n            this.y = function (increntment) {\n                return Math.sin(-increntment - Math.PI / 180) * 160;\n            };\n\n            this.draw = function (ctx) {\n                var s = _this3;\n\n                var opacSpeed = s.k += .3;\n                var speed = s.i += s.randomSpeed;\n\n                var radSize = s.radSize(speed);\n                var flicker = s.Flicker(opacSpeed);\n\n                var y = s.y(speed);\n                var x = s.x(speed, s.radius);\n\n                ctx.translate(width / 2, s.start.y);\n                var gradient = ctx.createRadialGradient(x, y, .4, x, y, 14);\n\n                gradient.addColorStop(0, 'LightSkyBlue');\n                gradient.addColorStop(.9, 'DodgerBlue');\n                gradient.addColorStop(1, 'RoyalBlue');\n\n                ctx.beginPath();\n                ctx.arc(x, y, s.radius - radSize - flicker, 0, Math.PI * 2);\n                ctx.fillStyle = gradient;\n                ctx.fill();\n\n                ctx.translate(-width / 2, -s.start.y);\n            };\n        };\n\n        function createStars(starCount, update) {\n            var delay = 0;\n\n            for (var i = 0; i < starCount; i++) {\n                delay += Math.random() * width;\n\n                var nightStars = new NightStars();\n                nightStars.randomSpeed = .001 + Math.random() * .006;\n                nightStars.startTime = Date.now();\n                nightStars.duration += delay; //sets a random delay for stars to start\n                stars.push(nightStars);\n            }\n            update();\n        }\n\n        function update() {\n            //Stopping stars\n            if (toggleStars.toggle) {\n                stars.length = 0;\n                ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n                return;\n            }\n\n            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n\n            var all = stars.length;\n            for (var i = 0; i < all; i++) {\n                // let percent = Math.min( ( Date.now() - stars[i].startTime ) / stars[i].duration, 1 )  //Delay to start stars\n                var percent = Math.min(Date.now() - stars[i].startTime, 1); // No delay\n\n                if (percent === 1) {\n                    stars[i].draw(ctx);\n                }\n            }\n            requestAnimationFrame(update);\n        }\n\n        return {\n            createStars: createStars,\n            update: update\n        };\n    };\n\n    var updateText = function () {\n\n        var toggle = true;\n        var textField = _('text-field');\n\n        function changeToggle(boolean) {\n            toggle = boolean;\n        }\n        return {\n            toggleFalse: function toggleFalse() {\n                changeToggle(false);\n            },\n            updateImgText: function updateImgText(img) {\n\n                changeToggle(true);\n\n                var imgText = img.getAttribute('data-target');\n                var textLength = imgText.length;\n\n                for (var i = 0; i < textLength; i++) {\n\n                    (function (i) {\n                        setTimeout(function () {\n\n                            if (!toggle) return;\n\n                            textField.textContent += imgText[i];\n                        }, 100 * i);\n                    })(i);\n                }\n            }\n        };\n    }();\n\n    function electricBox() {\n        var randomCir = [0, 1, 2, 3, 4, 5];\n\n        function getRandom(num) {\n            return Math.floor(Math.random() * Math.floor(num));\n        }\n        function findNum(item) {\n\n            var newNum = randomCir.splice(item, 1);\n\n            _('robot-st34')[newNum].classList.add('blink');\n            if (randomCir.length) {\n                relay(randomCir);\n            }\n        }\n        function relay(el) {\n            window.setTimeout(function () {\n                var item = getRandom(el.length - 1);\n                findNum(item);\n            }, 80);\n        }\n        relay(randomCir);\n    };\n\n    function checkForClasses() {\n        var circles = _('robot-st34').length;\n\n        // Add blinking light classes\n        for (var i = 0; i < circles; i++) {\n            if (_('robot-st34')[i].classList.contains('blink')) {\n\n                _('robot-st34')[i].classList.remove('blink');\n            }\n        }\n        electricBox();\n    };\n\n    // Add electricity for robot box stomach\n    function addElectricity() {\n        var pathLength = _('electric-path').length;\n        for (var i = 0; i < pathLength; i++) {\n            _('electric-path')[i].style.strokeDasharray = 20;\n            _('electric-path')[i].style.strokeDashoffset = 280;\n        }\n        var start = 0;\n\n        function draw(timestamp) {\n            if (!start) start = timestamp;\n            var runtime = timestamp - start;\n            var progress = Math.min(runtime / 1200, 1);\n\n            for (var i = 0; i < pathLength; i++) {\n                _('electric-path')[i].style.strokeDashoffset = 280 + 280 * progress;\n            }\n\n            if (progress < 1) {\n                requestAnimationFrame(draw);\n            } else {\n                for (var i = 0; i < pathLength; i++) {\n                    _('electric-path')[i].setAttribute('style', '');\n                }\n                return;\n            }\n        }\n        requestAnimationFrame(draw);\n    };\n\n    /** Outter function scope variables **/\n    var designImages = document.getElementsByClassName('designImages');\n    var img_container = document.getElementsByClassName('image-container')[0];\n\n    var animateSlider = {\n        target: null,\n        partialDist: 0,\n        j: 0,\n        dist: 0,\n        start: 0,\n        images: [],\n        imgStart: 0,\n        newStart: function newStart(num) {\n\n            return parseInt(this.images[num].style.transform.replace(/^([\\w]*)\\(|(px.*)$/ig, ''));\n        },\n        containerWidth: function containerWidth() {\n            return parseInt(img_container.style.width.replace(/px/ig, ''));\n        },\n        cloneImage: function cloneImage(img) {\n            var clonedImg = img.cloneNode(true);\n            clonedImg.className = '';\n            clonedImg.removeAttribute('style');\n            imgInlarge.checkForDuplicates('designVisible');\n            imgInlarge.moveElement(clonedImg, 'designVisible');\n        },\n        draw: function draw(timestamp) {\n\n            if (!this.start) this.start = timestamp;\n\n            var runtime = timestamp - this.start;\n            var progress = Math.min(runtime / 700, 1);\n\n            this.images[0].style.transform = 'translate(' + (this.imgStart - this.dist * progress) + 'px, -50%)';\n\n            if (progress === 1) {\n\n                //Second photo following the first to be animated automatically\n                if (this.j === 1) {\n\n                    //checks if left or right button click with a negative left or positive right and updates imgStart\n                    this.imgStart = this.dist < 0 ? -this.containerWidth() : this.containerWidth();\n                    this.dist = this.dist < 0 ? -this.containerWidth() : this.containerWidth();\n\n                    this.start = 0;\n                    var item = this.images.shift();\n                    this.images.push(item);\n                    this.j = 0;\n                } else {\n\n                    //User double clicks same button when 2nd image isn't finished it draws again\n                    if (this.imgStart !== this.dist) {\n\n                        this.draw();\n                    } else {\n                        //Stops typed text from running only when photo stops into place\n                        _('text-field').textContent = '';\n                        updateText.updateImgText(this.images[0]); //Starts the typed text function\n\n                        this.cloneImage(this.images[0]);\n                    }\n                    return this.j++;\n                }\n            }\n            requestAnimationFrame(animateSlider.draw.bind(this));\n        },\n        animateData: function animateData(e) {\n            var target = this.target.innerText;\n            var newStart = this.newStart(0);\n            this.partialDist = newStart;\n\n            //If user clicks before image done animating, updates current location and starts again\n            if (newStart !== 0 && !isNaN(newStart)) {\n\n                if (target === '<') {\n                    //If user double clicks same button right away\n                    if (newStart < 0) {\n                        this.imgStart = newStart;\n                        this.dist = this.containerWidth() + newStart;\n                    } else {\n                        this.j = 0;\n                        this.dist = newStart;\n                        this.imgStart = newStart;\n                    }\n                }\n                if (target === '>') {\n\n                    if (newStart < 0) {\n                        this.j = 0;\n                        this.imgStart = newStart;\n                        this.dist = newStart;\n                        //If user double clicks same button right away\n                    } else {\n                        this.imgStart = newStart;\n                        this.dist = -this.containerWidth() + newStart;\n                    }\n                }\n                this.start = 0;\n            } else {\n                this.start = 0;\n\n                if (target === '<') {\n                    //first click starts image outside the head\n                    this.j >= 1 ? this.imgStart = 0 : this.imgStart = this.containerWidth();\n                    this.dist = this.containerWidth();\n                } else {\n                    //first click starts image outside the head\n                    this.j >= 1 ? this.imgStart = 0 : this.imgStart = -this.containerWidth();\n                    this.dist = -this.containerWidth();\n                }\n\n                this.draw();\n            }\n        },\n        // load images into array to be used for slider\n        loadImages: function loadImages() {\n            for (var i = 0; i < designImages.length; i++) {\n                var element = designImages[i];\n                this.images.push(element);\n            }\n        }\n    };\n\n    // Keeps from resize event loading click handler\n    if (e.type !== 'resize' && e.type !== 'scroll') {\n\n        _('btnContainer').addEventListener('click', function (e) {\n            e.stopPropagation();\n            animateSlider.target = e.target;\n            animateSlider.animateData(e);\n\n            checkForClasses();\n            addElectricity();\n            updateText.toggleFalse();\n            _('text-field').textContent = '';\n        });\n    }\n\n    return [animateSlider, animateStars]; // To be used in the window.onload section\n};\n\nfunction DesignSlider() {\n    var img_container = document.getElementsByClassName('image-container')[0];\n    var img_container_rect = img_container.getBoundingClientRect();\n    this.ellipse = document.getElementsByClassName('clip-ellipse')[0];\n    this.rec = document.getElementsByClassName('screen-path')[0].getBoundingClientRect();\n    this.sectionContainer = document.getElementsByClassName('section-three-robot')[0].getBoundingClientRect();\n\n    var actualTop = this.rec.top - this.sectionContainer.top; //when page not fully scrolled into view it's the actual top\n\n    this.setEllipseAttributes = function () {\n        this.ellipse.setAttribute('rx', this.rec.width / 2);\n        this.ellipse.setAttribute('ry', this.rec.height / 2);\n        this.ellipse.setAttribute('cx', this.rec.left + this.rec.width / 2 - 5);\n        this.ellipse.setAttribute('cy', actualTop + this.rec.height / 2);\n    };\n    this.setImgContainer = function () {\n        var container_Width = this.rec.width / 9 + this.rec.width;\n        var img_containerY = actualTop - (img_container_rect.height - this.rec.height) / 2;\n        img_container.style.transform = 'translate(-50%,' + img_containerY + 'px)'; //-48% to make up for 53% robot-svg offset\n        img_container.style.width = container_Width + 'px';\n    };\n    this.setButtonLocation = function () {\n\n        var addedWidth = window.innerWidth < 768 ? 70 : 200; //Distance bigger than robot head\n\n        var x = (window.innerWidth - (this.rec.width + addedWidth)) / 2;\n        var y = window.innerWidth > 768 ? actualTop + this.rec.height / 2 - 25 : this.rec.bottom - this.sectionContainer.top; // - 25 for the btnContainer height / 2\n\n        _('btnContainer').style.width = this.rec.width + addedWidth + 'px';\n        _('btnContainer').style.transform = 'translate(' + x + 'px,' + y + 'px)';\n    };\n    return function () {\n\n        return [this.setEllipseAttributes(), this.setImgContainer(), this.setButtonLocation()];\n    }.bind(this);\n}\n\nwindow.addEventListener('resize', function (e) {\n\n    var updateRobot = robotSection(e);\n\n    var designSlider = new DesignSlider();\n    designSlider(); //updates canvas size\n    updateRobot[1](); //updates button, image location , attributes of robot\n});\n\n// **** ASSEMBLY LINE SECTION ****\n\nvar AssemblyLine = function () {\n    function AssemblyLine() {\n        _classCallCheck(this, AssemblyLine);\n\n        this.mainSVG = _('assembly-line-svg');\n        this.sliders = _('roller_unit');\n        this.codeContainers = _('code-container');\n    }\n\n    _createClass(AssemblyLine, [{\n        key: \"getRect\",\n        value: function getRect(el) {\n            var rect = el.getBoundingClientRect();\n            var bBox = el.getBBox();\n            return { rect: rect, bBox: bBox };\n        }\n    }, {\n        key: \"getElemValue\",\n        value: function getElemValue(pos) {\n            var _$exec = /[1-9].*/.exec(this.mainSVG.getAttribute('viewBox')),\n                _$exec2 = _slicedToArray(_$exec, 1),\n                size = _$exec2[0];\n\n            var regEx = /^(\\d{4})\\s(\\d{3})$/ig;\n            var values = [];\n            values.length = 0;\n            var length = this.sliders.length;\n            var rollerUnit = this.sliders;\n            var codeElements = this.codeContainers;\n            for (var i = 0; i < length; i++) {\n                var rollerElem = rollerUnit[i];\n                var codeElem = codeElements[i];\n\n                switch (pos) {\n                    case 'container':\n                        return slidersContainer;\n                    case 'viewBoxWidth':\n                        return size.replace(regEx, '$1');\n                    case 'viewBoxHeight':\n                        return size.replace(regEx, '$2');\n                    case 'el':\n                        values.push(rollerElem);\n                        break;\n                    case 'rectX':\n                        values.push(this.getRect(rollerElem).rect.x); // not in use\n                        break;\n                    case 'codeBox.x':\n                        values.push(this.getRect(codeElem).rect.x);\n                        break;\n                    case 'codebBox.x':\n                        values.push(this.getRect(codeElem).bBox.x);\n                        break;\n                    case 'bBoxX':\n                        values.push(this.getRect(rollerElem).bBox.x); // not in use\n                        break;\n                    case 'y':\n                        values.push(this.getRect(rollerElem).bBox.y);\n                        break;\n                    case 'width':\n                        values.push(this.getRect(rollerElem).bBox.width);\n                        break;\n                    case 'height':\n                        values.push(this.getRect(rollerElem).bBox.height);\n                        break;\n                }\n            }\n            return values;\n        }\n    }]);\n\n    return AssemblyLine;\n}();\n\n;\n\nvar RollerUnit = function (_AssemblyLine) {\n    _inherits(RollerUnit, _AssemblyLine);\n\n    function RollerUnit() {\n        _classCallCheck(this, RollerUnit);\n\n        var _this4 = _possibleConstructorReturn(this, (RollerUnit.__proto__ || Object.getPrototypeOf(RollerUnit)).call(this));\n\n        _this4.getRect = _this4.getRect;\n        _this4.draw = _this4.draw.bind(_this4);\n        _this4.beginPos = [];\n        _this4.dist = [];\n        _this4.lessThan = '';\n        _this4.start = 0;\n        _this4.time = 1000;\n        _this4.current = {};\n        _this4.click = 0;\n        _this4.beltClick = 0;\n        _this4.foreinObjs = _('assembly-img-foreignObj');\n        _this4.foreinGroup = _('assembly-img-wrap');\n        _this4.belts = _('belt');\n        return _this4;\n    }\n\n    _createClass(RollerUnit, [{\n        key: \"startPos\",\n        value: function startPos(elem) {\n            var arr = [];\n            var el = elem;\n            var length = el.length;\n            for (var i = 0; i < length; i++) {\n                if (el[i].hasAttribute('style')) {\n                    arr.push(parseInt(el[i].style.transform.replace(/^([\\w]*)\\(([?-\\d].*)px\\)/ig, \"$2\")));\n                } else {\n                    arr.push(0);\n                }\n            }\n            return arr;\n        }\n    }, {\n        key: \"min\",\n        value: function min(start) {\n            var actual = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n            var rect = Math.min.apply(Math, _toConsumableArray(start));\n            var dist = Math.min.apply(Math, _toConsumableArray(actual));\n            var index = start.indexOf(rect);\n            return { index: index, dist: dist };\n        }\n    }, {\n        key: \"max\",\n        value: function max(start, actual) {\n            var rect = Math.max.apply(Math, _toConsumableArray(start));\n            var dist = Math.max.apply(Math, _toConsumableArray(actual));\n            var index = start.indexOf(rect);\n            return { index: index, dist: dist };\n        }\n    }, {\n        key: \"getDistance\",\n        value: function getDistance() {\n            var _this5 = this;\n\n            var width = this.getElemValue('width')[0];\n            var arr = [];\n            var startingPoint = this.getElemValue('codeBox.x');\n            var actualDist = this.getElemValue('codebBox.x');\n\n            var maxElement = this.max(startingPoint, actualDist);\n            var minElement = this.min(startingPoint, actualDist);\n\n            var moveEnd = function moveEnd(k) {\n                var dist = _this5.left ? 431 : -431; // moveBeginning dist * 2    \n                arr.push({ dist: dist, index: k });\n            };\n\n            var moveBeginning = function moveBeginning(k) {\n                var dist = _this5.left ? minElement.dist + width : -(minElement.dist + width);\n                var rightPageStart = _this5.left ? actualDist.reverse()[k] + width : -actualDist[k] - width;\n\n                _this5.lessThan = k; //Updates the smallest distance\n                arr.push({ dist: dist * 2, index: k, rightPageStart: rightPageStart, pageRight: true });\n            };\n\n            for (var k = 0; k < 3; k++) {\n\n                if (minElement.index === k) {\n                    this.right ? moveEnd(k) : moveBeginning(k);\n                } else if (maxElement.index === k) {\n                    this.right ? moveBeginning(k) : moveEnd(k);\n                } else {\n                    var dist = this.left ? 431 : -431; // moveBeginning dist * 2\n                    arr.push({ dist: dist, index: k });\n                }\n            }\n            arr.sort = function (a, b) {\n                return a.place - b.place;\n            };\n            return arr;\n        }\n\n        // Add and remove foreignObjects into slider\n\n    }, {\n        key: \"foreinObjArr\",\n        value: function foreinObjArr() {\n            // let length =  this.foreinObjs.length\n            var length = this.foreinGroup.length;\n            var arr = new Array(length);\n\n            // Puts image foreignobjects into array\n            while (length) {\n                length--;\n                arr[length] = this.foreinGroup[length];\n            }\n\n            var startingPoint = this.getElemValue('codeBox.x');\n            var index = this.min(startingPoint).index;\n\n            var add = arr.splice(3, 1);\n            var removed = arr.splice(index, 1);\n\n            var removedChild = removed[0].childNodes[1];\n            var addChild = add[0].childNodes[1];\n            arr.splice(index, 0, add[0]);\n            arr.push(removed[0]);\n\n            //Add and remove just transforms first\n            var styleTransform = removed[0].attributes[1];\n            removed[0].removeAttribute(styleTransform.name);\n            add[0].setAttribute(styleTransform.name, styleTransform.value);\n\n            //Strips attributes of removed and add same attributes to added foreignobject\n            while (removedChild.attributes.length > 1) {\n\n                var attrName = removedChild.attributes[1].name;\n                var attrValue = removedChild.attributes[1].value;\n\n                addChild.setAttribute(attrName, attrValue);\n                removedChild.removeAttribute(removedChild.attributes[1].name);\n            }\n\n            this.foreinGroup = arr;\n        }\n\n        // Ran once when page reloads\n\n    }, {\n        key: \"positionForiegnObject\",\n        value: function positionForiegnObject(_this) {\n            var sliders = this.codeContainers;\n            var foreignObjects = this.foreinObjs;\n            var length = sliders.length;\n\n            for (var i = 0; i < length; i++) {\n\n                var slider_x = this.getRect(this.codeContainers[i]).bBox.x;\n                var slider_y = this.getRect(this.codeContainers[i]).bBox.y;\n                var slider_width = this.getRect(this.codeContainers[i]).bBox.width;\n                var slider_height = this.getRect(this.codeContainers[i]).bBox.height;\n\n                foreignObjects[i].setAttribute('x', slider_x);\n                foreignObjects[i].setAttribute('y', slider_y);\n                foreignObjects[i].setAttribute('width', slider_width);\n                foreignObjects[i].setAttribute('height', slider_height);\n            }\n            //Inputs image into container\n            _this.targetElem();\n        }\n    }, {\n        key: \"moreThanHalf\",\n        value: function moreThanHalf(dist, positiveCurrent, startDist) {\n            return dist - (startDist - positiveCurrent);\n        }\n    }, {\n        key: \"lessThanHalf\",\n        value: function lessThanHalf(current, dist, startDist) {\n            var d = dist.dist < 0 ? dist.dist * -1 : dist.dist;\n\n            if (startDist === 0) {\n                if (dist.rightPageStart) {\n                    var diff = current - startDist;\n                    var totalDiff = d - (current - startDist);\n                    return diff + totalDiff;\n                }\n                return d - current;\n            } else {\n                if (dist.rightPageStart) {\n                    var _diff2 = current - startDist;\n                    var _totalDiff = d - Math.abs(current - startDist);\n                    return _diff2 + _totalDiff;\n                }\n                var _diff = d - Math.abs(current - startDist);\n                return _diff;\n            }\n        }\n    }, {\n        key: \"oppisiteDir\",\n        value: function oppisiteDir(current, startDist) {\n            if (startDist === 0) {\n                return current;\n            } else {\n                if (current > startDist) {\n                    // more than half\n                    return current - startDist;\n                }\n                return startDist - current; //less than half    \n            }\n        }\n    }, {\n        key: \"handleRightPageStart\",\n        value: function handleRightPageStart(d, rightPageStart, posCurrent, startDist) {\n\n            if (startDist < 0) {\n                //more than half\n                if (d > posCurrent) {\n                    var _distance = posCurrent;\n                    return { distance: _distance, pageRight: false\n                        //less than half\n                    };\n                }\n                var difference = 1141.2 - posCurrent;\n                var totalDif = d - (1141.2 - posCurrent);\n                var distance = difference + totalDif;\n                return { distance: distance, pageRight: true };\n            } else {\n\n                //less than half only element with a rightPageStart of 1141.2\n                if (rightPageStart > 1160) {\n                    //1160\n                    var _difference = d / 2 - posCurrent;\n                    var _totalDif = d - _difference;\n                    var _distance2 = _totalDif + _difference;\n                    return { distance: _distance2, pageRight: true\n                        //more than half\n                    };\n                } else if (posCurrent < startDist) {\n                    var _distance3 = startDist - posCurrent;\n                    return { distance: _distance3, pageRight: false\n                        //less than half \n                    };\n                } else {\n                    var diff = posCurrent - startDist;\n                    var totalDiff = d - (posCurrent - startDist);\n                    var _distance4 = diff + totalDiff;\n                    return { distance: _distance4, pageRight: true };\n                }\n            }\n        }\n        // ** RIGHT BUTTON IS NEGATIVE DIST, LEFT BUTTON IS POSITIVE DIST**\n\n    }, {\n        key: \"handleDoubleClick\",\n        value: function handleDoubleClick(current, dist, beginPos) {\n            //Updates how many times back and forth before animation finishes\n            this.click++;\n\n            var currentDirection = Math.sign(this.currentDist[1].dist);\n            var distDirection = Math.sign(dist[1].dist);\n\n            for (var i = 0; i < 3; i++) {\n\n                //Middle dist not equal both negative or positives then use current dist\n                var dist_i = currentDirection !== distDirection ? this.currentDist[i] : dist[i];\n                var d = dist_i.dist < 0 ? dist_i.dist * -1 : dist_i.dist; //changed this\n\n                //Starts off with positive variables\n                var rightPageStart = dist_i.rightPageStart < 0 ? dist_i.rightPageStart * -1 : dist_i.rightPageStart;\n                var startDist = beginPos[i] < 0 ? beginPos[i] * -1 : beginPos[i];\n                var posCurrent = current[i] < 0 ? current[i] * -1 : current[i];\n\n                // When clicked opposite direction\n                if (currentDirection !== distDirection) {\n\n                    if (rightPageStart) {\n                        var rightStart = this.right ? -rightPageStart : rightPageStart;\n\n                        var cur = this.handleRightPageStart(d, rightPageStart, posCurrent, startDist, this.currentDist[i].index);\n                        var curDist = this.right ? -cur.distance : cur.distance;\n                        var pageRight = cur.pageRight;\n\n                        this.dist.push({ dist: curDist, index: dist_i.index, rightPageStart: rightStart, pageRight: pageRight });\n                        this.beginPos.push(current[i]);\n                    } else {\n                        var distance = this.oppisiteDir(posCurrent, startDist);\n                        var _dist = this.right && distance > 0 ? -distance : distance;\n\n                        this.dist.push({ dist: _dist, index: dist_i.index, rightPageStart: dist_i.rightPageStart, pageRight: false });\n                        this.beginPos.push(current[i]);\n                    }\n                    //Clicked same direction\n                } else {\n                    //After element starts from hidden part of page\n                    if (this.right && rightPageStart && current[i] < 0 || this.left && current[i] > 0 && rightPageStart) {\n\n                        this.lessThan = dist_i.index; //have to update rightPageStart again due to running this.getDistance() twice\n                        var _distance5 = d / 2 - (rightPageStart - posCurrent);\n                        var PosOrNegDistance = this.right && _distance5 > 0 ? _distance5 * -1 : _distance5;\n\n                        this.dist.push({ dist: PosOrNegDistance, index: dist_i.index, rightPageStart: dist_i.rightPageStart, pageRight: false });\n                        this.beginPos.push(current[i]);\n                    } else {\n                        var lessThanhalf = startDist < posCurrent || startDist && posCurrent < d ? true : false;\n                        var _distance6 = lessThanhalf ? this.lessThanHalf(posCurrent, dist_i, startDist) : this.moreThanHalf(d, posCurrent, startDist);\n                        var _PosOrNegDistance = this.right ? -_distance6 : _distance6;\n\n                        this.dist.push({ dist: _PosOrNegDistance, index: dist_i.index, rightPageStart: dist_i.rightPageStart, pageRight: true });\n                        this.beginPos.push(current[i]);\n                    }\n                }\n            }\n            //Removes prior values in arrays\n            this.dist.splice(0, 3), this.beginPos.splice(0, 3);\n            console.log(this.dist, this.beginPos);\n        }\n        //Updates sliders positions\n\n    }, {\n        key: \"updatePos\",\n        value: function updatePos() {\n            // Handles back and forth clicking\n            if (this.start) {\n                this.start = 0;\n\n                this.currentDist = this.getDistance();\n                this.currentBeginPos = this.startPos(this.sliders);\n                return this.handleDoubleClick(this.current, this.dist, this.beginPos);\n            } else {\n                this.updateBeltPos();\n                this.beginPos.length = 0;\n                this.dist.length = 0;\n                var dist = this.getDistance();\n                var beginPos = this.startPos(this.sliders);\n                // 3 is length of slider elements\n                for (var i = 0; i < 3; i++) {\n\n                    this.beginPos.push(beginPos[i]);\n                    this.dist.push(dist[i]);\n                }\n                requestAnimationFrame(this.draw);\n            }\n        }\n    }, {\n        key: \"animateBelts\",\n        value: function animateBelts(topGears, bottomGears) {\n            _('teeth-wrapper-top').style.transform = \"translate(\" + topGears + \"px)\";\n            _('teeth-wrapper-bottom').style.transform = \"translate(\" + bottomGears + \"px)\";\n        }\n    }, {\n        key: \"animate\",\n        value: function animate(sliders, imgGroup, value) {\n            sliders.style.transform = \"translate(\" + value + \"px)\";\n            imgGroup.style.transform = \"translate(\" + value + \"px)\";\n        }\n    }, {\n        key: \"draw\",\n        value: function draw(timestamp) {\n            var time = this.time;\n            if (!this.start) this.start = timestamp;\n            this.runtime = timestamp - this.start;\n            var progress = Math.min(this.runtime / time, 1);\n\n            var j = this.lessThan;\n\n            for (var i = 0; i < 3; i++) {\n\n                var num = i !== j ? i : j;\n                var sliders = this.sliders[num];\n\n                var imgGroup = this.foreinGroup[num];\n\n                var beginPos = this.beginPos[num];\n                var dist = this.dist[num].dist;\n                var rightStart = this.dist[num].rightPageStart;\n                var pageRight = this.dist[num].pageRight;\n                //Right or Left side element animate to other side of screen\n                if (num === j && pageRight) {\n\n                    if (progress <= .5) {\n                        var value = beginPos - dist * progress;\n                        this.current[num] = value;\n                        this.animate(sliders, imgGroup, value);\n                    } else {\n                        var _value = rightStart - dist * (progress - .5);\n                        this.current[num] = _value;\n                        this.animate(sliders, imgGroup, _value);\n                    }\n                } else {\n                    var _value2 = beginPos - dist * progress;\n                    this.current[num] = _value2;\n                    this.animate(sliders, imgGroup, _value2);\n                }\n            }\n            // Belts Animation\n            var topGears = this.beltPos.startPos[0] + this.beltPos.dist * progress;\n            var bottomGears = this.beltPos.startPos[1] - this.beltPos.dist * progress;\n            this.animateBelts(topGears, bottomGears);\n            if (progress < 1) {\n                requestAnimationFrame(this.draw);\n            } else {\n                this.foreinObjArr();\n                this.start = 0;\n                this.beltClick++;\n                this.click = 0;\n                imgInlarge.targetElem();\n                return;\n            }\n        }\n        //Stars gears inline left or right depending on left or right click\n\n    }, {\n        key: \"beltDirections\",\n        value: function beltDirections() {\n            var beltWidth = _('bottom-main').getBBox().width;\n\n            if (this.right) {\n                _('bottom-teeth').style.transform = \"translate( \" + beltWidth + \"px )\";\n                _('top-teeth').style.transform = \"translate( \" + -beltWidth + \"px )\";\n            } else {\n                _('bottom-teeth').style.transform = \"translate( \" + -beltWidth + \"px )\";\n                _('top-teeth').style.transform = \"translate( \" + beltWidth + \"px )\";\n            }\n        }\n    }, {\n        key: \"updateBeltPos\",\n        value: function updateBeltPos() {\n            var belts = this.startPos(this.belts);\n            var startPos = void 0,\n                dist = void 0;\n\n            // Starts gears on one side of the page or the other \n            if (this.beltClick === 0 || this.beltClick && belts[0] === 0) this.beltDirections();\n\n            if (this.right) {\n                startPos = belts;\n                dist = _('top-teeth').getBBox().width / 3;\n            }\n            if (this.left) {\n                startPos = belts;\n                dist = -(_('top-teeth').getBBox().width / 3);\n            }\n\n            //Keeps Gears always looking like their never ending\n            if (this.beltClick === 3) {\n                this.beltClick = 0;\n                this.animateBelts(0, 0);\n                this.beltDirections();\n                startPos = [0, 0];\n            }\n            this.beltPos = { dist: dist, startPos: startPos };\n        }\n    }]);\n\n    return RollerUnit;\n}(AssemblyLine);\n\nvar InLargeImg = function (_RollerUnit) {\n    _inherits(InLargeImg, _RollerUnit);\n\n    function InLargeImg() {\n        _classCallCheck(this, InLargeImg);\n\n        var _this6 = _possibleConstructorReturn(this, (InLargeImg.__proto__ || Object.getPrototypeOf(InLargeImg)).call(this));\n\n        _this6.container = _('img-inlarge-container');\n        _this6.animateClipPath = _this6.animateClipPath.bind(_this6);\n        _this6.img = document.querySelector('.inlarge-img-wrap img');\n        _this6.imgWrap = document.getElementsByClassName('inlarge-img-wrap')[0];\n        _this6.mouseMove = _this6.mouseMove.bind(_this6);\n        _this6.removeListener = _this6.removeListener.bind(_this6);\n        _this6.mouseY = 0;\n        _this6.imageClose = _this6.imageClose.bind(_this6);\n        _this6.targetElem = _this6.targetElem;\n        _this6.checkForDuplicates = _this6.checkForDuplicates;\n        _this6.moveElement = _this6.moveElement;\n        _this6.Y = 0;\n        return _this6;\n    }\n\n    _createClass(InLargeImg, [{\n        key: \"addClickListener\",\n        value: function addClickListener() {\n            _('img-inlarge-container').addEventListener('click', this.imageClose);\n        }\n    }, {\n        key: \"removeClickListener\",\n        value: function removeClickListener() {\n            _('img-inlarge-container').removeEventListener('click', this.imageClose);\n        }\n    }, {\n        key: \"checkForDuplicates\",\n        value: function checkForDuplicates(clssName) {\n            var imgs = this.imgWrap.children;\n            var length = imgs.length;\n            while (length--) {\n                if (imgs[length].className === clssName) {\n                    this.img = imgs[length];\n                    this.removeImg();\n                }\n            }\n        }\n        //Recursion\n\n    }, {\n        key: \"targetElem\",\n        value: function targetElem(elemX) {\n\n            var length = this.foreinObjs.length;\n            var arr = [];\n            var groupArr = [];\n\n            for (var i = length - 1; i >= 0; i--) {\n\n                // 1st pushes only elements with style attribtues of x\n                if (!elemX && this.foreinObjs[i].hasAttribute('x')) {\n\n                    arr.push(this.foreinObjs[i].getBoundingClientRect().x);\n                    groupArr.push(this.foreinObjs[i].parentNode);\n                }\n                // Scaling image only\n                if (this.foreinObjs[i].parentNode.getBoundingClientRect().x === elemX && this.toggleMoveElement) {\n                    this.group = this.foreinObjs[i].parentNode;\n                    return;\n                }\n                if (this.foreinObjs[i].getBoundingClientRect().x === elemX) {\n                    this.checkForDuplicates('webVisible');\n                    var imgNode = this.foreinObjs[i].childNodes[1];\n                    var clonedImg = imgNode.cloneNode(true);\n                    return this.moveElement(clonedImg, 'webVisible');\n                }\n            }\n            // Middle element which is the median of the three elements\n            var sorted = arr.sort(function (a, b) {\n                return a - b;\n            })[1];\n            this.targetElem(sorted);\n        }\n    }, {\n        key: \"insertText\",\n        value: function insertText(img) {\n            var imgContent = _('img-content');\n            var url = img.attributes[2].value;\n            var text = img.attributes[1].textContent;\n            imgContent.textContent = text;\n            imgContent.innerHTML += '<br>' + '<a href=\"' + url + '\"> ' + url + ' </a>' + '</br>';\n        }\n    }, {\n        key: \"moveElement\",\n        value: function moveElement(el, cls) {\n            this.img = el; //updates image to be used elsewhere \n            el.classList.add(cls);\n            var img_content = _('img-content');\n            var fragment = document.createDocumentFragment();\n            fragment.appendChild(el);\n            this.imgWrap.insertBefore(fragment, img_content);\n            this.imgWrap.classList.add('show-img');\n            this.imgWrap.classList.remove('hide-img');\n        }\n    }, {\n        key: \"removeImg\",\n        value: function removeImg(e) {\n            var _this7 = this;\n\n            //Only ran to exit out of image from click handler\n            if (e) {\n                this.container.style.opacity = 0;\n                this.imgWrap.classList.replace('show-img', 'hide-img');\n                setTimeout(function () {\n                    _this7.imgWrap.classList.replace('hide-img', 'show-img');\n                    _this7.container.removeAttribute('style');\n                    _this7.img.style.display = 'none';\n                }, 1100);\n            } else {\n\n                _('img-content').textContent = '';\n                this.img.parentNode.removeChild(this.img);\n            }\n        }\n        // Removes images \n\n    }, {\n        key: \"imageClose\",\n        value: function imageClose(e) {\n            this.removeClickListener();\n            if (e.target.tagName !== 'IMG') {\n\n                this.removeImg(e);\n            }\n        }\n        // Displays image\n\n    }, {\n        key: \"showImage\",\n        value: function showImage(clssName) {\n            this.img = document.getElementsByClassName(clssName)[0];\n            this.insertText(this.img);\n            this.img.style.display = 'block';\n            this.addClickListener();\n            this.container.style.display = 'flex';\n            this.container.style.opacity = 1;\n        }\n        // **  REMOVE ANIMATECLIPPATH IF I DON'T REALLLY HAVE TO USE IT FOR FIREFOX **\n        //Firefox only\n\n    }, {\n        key: \"animateClipPath\",\n        value: function animateClipPath(timestamp) {\n            if (!this.start) this.start = timestamp;\n            this.runtime = timestamp - this.start;\n            var progress = Math.min(this.runtime / 1000, 1);\n            this.imgWrap.style.clipPath = \"circle(\" + (this.clipStart + this.clipValue * progress) + \"%)\";\n\n            if (progress < 1) {\n                requestAnimationFrame(this.animateClipPath);\n            } else {\n\n                if (this.container.style.opacity == 0) {\n\n                    // Removes flex and opacity, sets back to display none\n                    this.container.removeAttribute('style');\n                    // this.img.parentNode.removeChild(this.img)\n                }\n                this.start = 0;\n            }\n        }\n    }, {\n        key: \"getTransform\",\n        value: function getTransform() {\n            var regEx = /^scale/g;\n            var transform = this.group.style.transform.replace(/^(\\w*\\(-?\\d*.\\w*\\))(.*)/ig, \"$1\");\n            var checkForScale = transform.match(regEx);\n            //So two scale values don't get added to element when translate doesn't exist\n            if (checkForScale) {\n                return '';\n            } else {\n                return transform;\n            }\n        }\n    }, {\n        key: \"scalePhoto\",\n        value: function scalePhoto(dist, scale, translate) {\n            document.getElementById('slider_1_').style.transform = \"translateY(\" + dist + \"px)\";\n            this.group.style.transform = translate + (\"scale( \" + (1 + scale) + \" )\");\n        }\n    }, {\n        key: \"mouseMove\",\n        value: function mouseMove(e) {\n            // multipy by 1.5 because of the lag, so I speed it up just a bit\n            var dist = e.clientY - this.mouseY;\n            var value = dist / this.Y;\n            var scale = Math.min(value < 0 ? -value : -value, 1);\n            var translate = this.getTransform();\n            var translateValue = +translate.replace(/[^-\\d.]/ig, \"\");\n\n            //Checks if element is either -431 or 431 so the correct transform origin can be added\n            if (translateValue > 2) {\n                this.group.style.transformOrigin = 165 + \"px \" + 450 + \"px\";\n            } else if (translateValue < -1) {\n                this.group.style.transformOrigin = 1034 + \"px \" + 458 + \"px\";\n            }\n            //scale is 1 when clicked somewhere else\n            if (scale < 1 && dist <= 6) this.scalePhoto(dist, scale, translate);\n        }\n    }, {\n        key: \"mouseDown\",\n        value: function mouseDown(e) {\n\n            _('slide-group').addEventListener('mouseup', this.removeListener, true);\n\n            this.toggleMoveElement = true;\n            this.targetElem();\n            var verPiece = document.getElementById('vert_piece');\n            var vertY = verPiece.getBBox().y;\n            var handleY = _('img-scale').getBBox().y;\n\n            //Gets distance slider needs to go  \n            this.Y = handleY - vertY;\n\n            //Start position for distance\n            if (!this.mouseY) this.mouseY = e.clientY;\n            _('slide-group').addEventListener('mousemove', this.mouseMove, true);\n        }\n    }, {\n        key: \"removeListener\",\n        value: function removeListener(e) {\n            _('slide-group').removeEventListener('mousemove', this.mouseMove, true);\n\n            var translate = this.getTransform();\n            this.scalePhoto(0, 0, translate);\n\n            _('slide-group').removeEventListener('mouseup', this.removeListener, true);\n            _('img-scale').removeEventListener('mousedown', this.mouseDown, true);\n\n            //Updates position when mouseUp\n            this.mouseY = 0;\n            this.toggleMoveElement = false;\n        }\n    }]);\n\n    return InLargeImg;\n}(RollerUnit);\n\nvar rollerUnit = new RollerUnit();\nvar imgInlarge = new InLargeImg();\nrollerUnit.positionForiegnObject(imgInlarge);\n\n_('img-scale').addEventListener('mousedown', function (e) {\n\n    imgInlarge.mouseDown(e);\n}, true);\n\n_('buttons').addEventListener('click', function (e) {\n\n    e.stopPropagation();\n    var target = e.target.parentElement.classList[0];\n\n    if (target === 'img-left' || target === 'img-right') {\n        if (rollerUnit.click === 1) return;\n\n        rollerUnit.left = target === 'img-left' ? true : false;\n        rollerUnit.right = target === 'img-right' ? true : false;\n        rollerUnit.updatePos();\n    } else if (target === 'img-inlarge') {\n        imgInlarge.showImage('webVisible');\n    }\n});\n\ndocument.getElementById('button-inlarge').addEventListener('click', function (e) {\n    imgInlarge.showImage('designVisible');\n});\n\n// **** GRAPH SECTION ****\n\nvar random = function random(min, max) {\n    return Math.random() * (max - min) + min;\n};\n\nvar toggleRobot = {\n    toggle: false,\n    flight: false, //Toggles when scrolled out of screen view\n    direction: 'up'\n};\n\nfunction startRobotFlight() {\n    // *** Burners ***\n\n    var flames = _('robot-flame');\n    var length = flames.length;\n\n    var from = { x: 1, y: 1 };\n    var to = {};\n    var distance = {};\n    var keys = Object.keys(from);\n\n    var next = function next(timestamp) {\n        //starts all over from gets starting point of the last size\n        Object.assign(from, to);\n        var length = keys.length;\n        for (var i = 0; i < length; i++) {\n            var axis = keys[i];\n            to[axis] = random(.8, 1);\n            distance[axis] = from[axis] - to[axis];\n        }\n\n        time.start = timestamp;\n    };\n\n    var time = {\n        total: 40\n    };\n\n    var drawBurners = function drawBurners(timestamp) {\n        if (toggleRobot.flight) return;\n        if (time.runtime > time.total || !to.x) next(timestamp);\n\n        time.runtime = timestamp - time.start;\n        var progress = time.runtime / time.total;\n\n        var _keys$map = keys.map(function (axis) {\n            return from[axis] - progress * distance[axis];\n        }),\n            _keys$map2 = _slicedToArray(_keys$map, 2),\n            x = _keys$map2[0],\n            y = _keys$map2[1];\n\n        for (var i = 0; i < length; i++) {\n            var flame = flames[i];\n            flame.style.transform = \"scale(\" + x + \", \" + y + \")\";\n        }\n        requestAnimationFrame(drawBurners);\n    };\n\n    //*** Draws Stars ***\n    var graphs = document.getElementsByClassName('graph-st20');\n    var recClip = document.getElementsByClassName('rec-clip')[0];\n    var fragment = document.createDocumentFragment();\n    var robotRect = _('floating_robot').getBoundingClientRect();\n    var graph = document.getElementById('graph-svg');\n\n    var _$exec3 = /[1-9].*/.exec(graph.getAttribute('viewBox')),\n        _$exec4 = _slicedToArray(_$exec3, 1),\n        size = _$exec4[0];\n\n    var regEx = /([1-9.]*)\\s([1-9.].*)/ig;\n    var graphWidth = size.replace(regEx, '$1');\n    var graphHeight = size.replace(regEx, '$2');\n\n    var robotHeight = robotRect.height;\n    var robotWidth = robotRect.width;\n    var startY = graphHeight - robotHeight;\n    var startX = robotRect.x - (window.innerWidth - graphWidth) / 2;\n\n    //starts stars randomly\n    var randomInterval = function randomInterval(callback, data, min, max) {\n\n        var time = {\n            start: performance.now(),\n            total: random(min, max)\n        };\n        var draw = function draw(timestamp) {\n            if (toggleRobot.flight) return;\n            if (time.total <= timestamp - time.start) {\n                time.start = timestamp;\n                time.total = random(min, max);\n                callback(data);\n            }\n            requestAnimationFrame(draw);\n        };\n        requestAnimationFrame(draw);\n    };\n\n    var createStar = function createStar(cx, cy, radius) {\n        var star = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n        star.setAttribute(\"r\", radius);\n        star.setAttribute(\"cy\", cy);\n        star.setAttribute(\"cx\", cx);\n        star.setAttribute(\"fill\", \"white\");\n        star.setAttribute(\"fill-opacity\", 0);\n        return star;\n    };\n\n    var FallingStars = function FallingStars(data) {\n\n        var attr = new data(toggleRobot.direction);\n\n        var radius = attr.radius;\n        var cx = attr.cx;\n        var cy = attr.cy;\n        var dist = attr.dist;\n        var star = createStar(cx, cy, radius);\n\n        var time = {\n            start: performance.now(),\n            total: random(1900, 2000)\n        };\n\n        var draw = function draw(timestamp) {\n            if (toggleRobot.toggle || toggleRobot.flight) {\n                graph.removeChild(star);\n                return;\n            }\n            time.elapsed = timestamp - time.start;\n            var progress = Math.min(time.elapsed / time.total, 1);\n\n            var opacity = progress * 2;\n\n            star.setAttribute(\"cy\", cy + progress * dist);\n            star.setAttribute(\"fill-opacity\", progress < .5 ? opacity : 2 - opacity);\n            time.elapsed < time.total ? requestAnimationFrame(draw) : graph.removeChild(star);\n        };\n        requestAnimationFrame(draw);\n\n        //Inserts new star based on randomInterval runing throughStars()\n        fragment.appendChild(star);\n        graph.insertBefore(fragment, graph.firstChild);\n    };\n\n    var flyIntoPlace = {\n        beginY: graphHeight - robotHeight / 12,\n        hiddenX: function hiddenX() {\n            var difference = graphWidth - wW;\n            if (!wW < graphWidth) {\n\n                return robotRect.width + robotRect.x + difference;\n            }\n        },\n        hideRobot: function hideRobot(size) {\n            if (size === 1.3) {\n                var beginX = this.hiddenX();\n                _('floating_robot').style.transform = \"translate(\" + 0 + \"px, -\" + this.beginY + \"px)\";\n            }\n        },\n        createStars: function createStars() {\n            var attributes = function attributes(direction) {\n\n                if (direction === 'down') {\n\n                    toggleRobot.toggle = false;\n                    var radius = random(.5, 2.7);\n                    var cx = random(startX - 100, startX + robotWidth + 100);\n                    var cy = random(startY - 120, startY - 175);\n                    var dist = 100 + robotHeight;\n\n                    return { radius: radius, cx: cx, cy: cy, dist: dist };\n                } else if (direction === 'up') {\n\n                    var _radius = random(1.5, 3.7);\n                    var _cx = random(0 - 25, graphWidth + 25);\n                    var _cy = random(graphHeight - 80, graphHeight + 50);\n                    var _dist2 = -graphHeight;\n\n                    return { radius: _radius, cx: _cx, cy: _cy, dist: _dist2 };\n                }\n            };\n            //Every 80ms through 180ms of time.total it will draw a star\n            //**** STARTS STARS MOVING *****\n            randomInterval(FallingStars, attributes, 80, 180);\n        }\n    };\n\n    var graphData = {\n        start: 0,\n        total: 2000\n    };\n    var subtractRay = function subtractRay() {\n        _('left-text-panel').removeAttribute('clip-path');\n        _('rec-clip').style.transform = \"translate(485px, 520px)\";\n    };\n    var getStrokeLength = function getStrokeLength() {\n        var i = graphs.length;\n        var value = new Array(i);\n        function getLength() {\n            while (i--) {\n                value[i] = graphs[i].getTotalLength();\n            }\n        }\n        return {\n            runValue: function runValue() {\n                getLength();\n            },\n            getValue: function getValue() {\n                return value;\n            }\n        };\n    };\n    var strokeLength = getStrokeLength();\n    strokeLength.runValue();\n\n    var drawPercentStroke = function drawPercentStroke(progress) {\n        var stroke = strokeLength.getValue();\n        var i = graphs.length;\n        while (i--) {\n            graphs[i].style.stroke = 'url(#design-gradient)';\n\n            graphs[0].style.strokeDashoffset = stroke[0] + stroke[0] * progress;\n            graphs[1].style.strokeDashoffset = stroke[1] - stroke[1] * progress;\n        }\n    };\n    var animateGraph = function animateGraph(timestamp) {\n        if (!graphData.start) graphData.start = timestamp;\n        var runtime = timestamp - graphData.start;\n        var progress = Math.min(runtime / graphData.total, 1);\n\n        _('graph-percentage-top').textContent = Math.round(0 + 90 * progress) + ' %';\n        _('graph-percentage-bottom').textContent = Math.round(0 + 70 * progress) + ' %';\n        _('graph-rect').style.transform = 'translate(' + 412 * progress + 'px)';\n        drawPercentStroke(progress);\n\n        if (progress < 1) requestAnimationFrame(animateGraph);else return subtractRay();\n    };\n\n    var startAnimateGraph = function startAnimateGraph() {\n        recClip.style.transform = 'translate(0px, 0px)';\n        _('graph-clipping').classList.add('show-graphs');\n\n        //Animate graphs after recClip transform is done\n        setTimeout(function () {\n            requestAnimationFrame(animateGraph);\n        }, 2500);\n    };\n\n    var begin = {\n        start: 0,\n        total: 4000\n    };\n\n    var flyIn = function flyIn(timestamp) {\n        if (!begin.start) begin.start = timestamp;\n        begin.runtime = timestamp - begin.start;\n        var progress = Math.min(begin.runtime / begin.total, 1);\n        var curve = 624.9 / 2;\n        var ease = easeOut(progress);\n        var increment = curve * progress / 50;\n\n        var y = -flyIntoPlace.beginY + flyIntoPlace.beginY * progress;\n        var x = -Math.cos(increment + Math.PI / 180) * curve + curve;\n        // !begin.toggle\n        _('floating_robot').style.transform = \"translate(\" + -x + \"px, \" + y + \"px)\";\n        // : document.querySelector('#section-five-web .container-lg').style.transform = `scale(${1.3 - .3 * ease})`\n\n        if (progress === 1) {\n            // toggleRobot.toggle = true;\n            toggleRobot.direction = 'down';\n\n            //Resizes the whole container so robot fits into screen\n            if (wW > 1050) {\n                setTimeout(startAnimateGraph, 600);\n                document.querySelector('#section-five-web .container-lg').classList.add('scale-container');\n            } else {\n\n                startAnimateGraph();\n            }\n            return;\n        }\n        requestAnimationFrame(flyIn);\n    };\n    return { flyIn: flyIn, flyIntoPlace: flyIntoPlace, drawBurners: drawBurners };\n}\n\nvar navToggle = {\n    toggle: true\n};\n\nvar Navigation = function () {\n    function Navigation() {\n        _classCallCheck(this, Navigation);\n\n        this.navItems = document.querySelectorAll('.nav-list button');\n        this.scrollTo = this.scrollTo.bind(this);\n        this.animateScroll = this.animateScroll.bind(this);\n        this.start = 0;\n    }\n\n    _createClass(Navigation, [{\n        key: \"getDistance\",\n        value: function getDistance(el) {\n\n            var top = el.getBoundingClientRect().top;\n            var height = el.getBoundingClientRect().height;\n            var bottom = el.getBoundingClientRect().bottom;\n            return { top: top, height: height, bottom: bottom };\n        }\n    }, {\n        key: \"getScrolltoElement\",\n        value: function getScrolltoElement(target, regEx) {\n            var section = document.getElementsByTagName('section');\n            var length = section.length;\n            while (length--) {\n                if (target === section[length].id.replace(regEx, \"$1\")) {\n                    return {\n                        el: section[length],\n                        index: length\n                    };\n                }\n            }\n        }\n    }, {\n        key: \"outExpo\",\n        value: function outExpo(n) {\n            return 1 == n ? n : 1 - Math.pow(2, -10 * n);\n        }\n    }, {\n        key: \"animateScroll\",\n        value: function animateScroll(timestamp) {\n            if (!this.start) this.start = timestamp;\n            var runtime = timestamp - this.start;\n            var progress = this.outExpo(Math.min(runtime / 1000, 1));\n            var y = this.startPos + this.elDist * progress;\n\n            window.scroll(0, y);\n            if (progress < 1) {\n                requestAnimationFrame(this.animateScroll);\n            } else return navToggle.toggle = true;\n        }\n    }, {\n        key: \"toggleOpenBtn\",\n        value: function toggleOpenBtn() {\n            var i = this.navItems.length;\n            while (i--) {\n\n                if (this.navItems[i].style.transform) {\n                    console.log(this.navItems[i].removeAttribute('style'));\n                }\n            }\n        }\n    }, {\n        key: \"scrollTo\",\n        value: function scrollTo(e) {\n            this.toggleOpenBtn();\n            if (e.target.className === 'contact-modal') return;\n            var regEx = /(\\w+\\-\\w+)\\-\\w+/ig;\n            var sectionId = e.target.className.replace(regEx, \"$1\");\n\n            var scrollToElem = this.getScrolltoElement(sectionId, regEx).el;\n            var index = this.getScrolltoElement(sectionId, regEx).index;\n            var elDist = this.getDistance(scrollToElem, index).top;\n            this.elDist = elDist;\n            this.startPos = window.pageYOffset;\n            this.start = 0;\n\n            requestAnimationFrame(this.animateScroll);\n        }\n    }, {\n        key: \"scrollTo768\",\n        value: function scrollTo768(e) {\n\n            var targetBtn = e.target.parentNode.parentNode;\n            console.log(targetBtn);\n\n            if (targetBtn.hasAttribute('style')) {\n                return this.toggleOpenBtn();\n            }\n            this.toggleOpenBtn();\n            targetBtn.style.pointerEvents = 'auto';\n            targetBtn.style.transform = \"translateX(\" + -130 + \"px)\";\n        }\n    }, {\n        key: \"controller\",\n        value: function controller() {\n            var _this8 = this;\n\n            _('nav-list').addEventListener('click', function (e) {\n                console.log(e.target);\n                navToggle.toggle = false;\n                if (e.target.nodeName === \"BUTTON\") {\n\n                    _this8.scrollTo(e);\n                }\n                // Only @ screen size 768 and smaller\n                if (e.target.parentNode.classList[1] === 'nav-icon') {\n\n                    _this8.scrollTo768(e);\n                }\n            });\n        }\n    }]);\n\n    return Navigation;\n}();\n\nvar navigation = new Navigation();\nnavigation.controller();\n\nvar toggleAnimate = {\n    stars: true,\n    flightStars: true,\n    circuit: true\n    // circuitToggle.toggleAnim = false\n};var robot = new robotSection('event');\nvar robotFlight = startRobotFlight();\n\nvar triggerStars = function triggerStars(e) {\n    console.log(e.type);\n    var update = robot[1](e).update;\n    var star_count = 25;\n    var makeStars = robot[1]();\n    makeStars.createStars(star_count, update);\n};\n\nvar ScrollAnimate = function (_Navigation) {\n    _inherits(ScrollAnimate, _Navigation);\n\n    function ScrollAnimate() {\n        _classCallCheck(this, ScrollAnimate);\n\n        var _this9 = _possibleConstructorReturn(this, (ScrollAnimate.__proto__ || Object.getPrototypeOf(ScrollAnimate)).call(this));\n\n        _this9.sections = document.querySelectorAll('.section-three-robot, #section-five-web, #section-one-digital, #section-two-popups');\n        return _this9;\n    }\n\n    _createClass(ScrollAnimate, [{\n        key: \"checkElemTop\",\n        value: function checkElemTop(e) {\n            var length = this.sections.length;\n\n            while (length--) {\n                var dist = this.getDistance(this.sections[length]);\n                var elmTop = dist.top;\n                var elmHeight = dist.height;\n                var elmBottom = dist.bottom;\n\n                //Digital Hand\n                if (length === 0) {\n\n                    if (elmBottom < 100) toggleAnimate.circuit = false;\n                }\n                //Map\n                if (length === 1) {\n                    var pointerLocation = _('oval-pointer').getBoundingClientRect().x;\n\n                    //Stops scroll from running hovermap function over and over\n                    if (pointerLocation > 0) {\n                        var hovermap = hoverMap();\n                        var _dist3 = hovermap[1](e)[0]; // Position distance of show-icon gooey\n                        hovermap[0](_dist3, true); // handler(e) function remove gooey\n                    }\n                }\n                // Robot Design stars element\n                if (length === 2) {\n\n                    //Page in view start animate stars\n                    if (elmTop <= elmHeight && elmBottom >= elmHeight && toggleAnimate.stars) {\n\n                        toggleAnimate.stars = false;\n                        toggleStars.toggle = false;\n                        // triggerStars(e)\n                    }\n                    //Page out of view start stop animate\n                    if (!toggleAnimate.stars && (elmTop > elmHeight || elmBottom <= 0)) {\n                        toggleAnimate.stars = true;\n                        toggleStars.toggle = true;\n                    }\n                }\n                //Flying Robot / Graph element\n                if (length === 3) {\n\n                    if (elmTop < elmHeight / 2 && elmBottom >= elmHeight && toggleAnimate.flightStars) {\n                        toggleRobot.flight = false;\n                        toggleAnimate.flightStars = false;\n                        requestAnimationFrame(robotFlight.drawBurners);\n                        robotFlight.flyIntoPlace.createStars('up');\n                        requestAnimationFrame(robotFlight.flyIn);\n                    }\n                    if (!toggleAnimate.flightStars && (elmTop > elmHeight - 75 || elmBottom <= 0)) {\n\n                        //Removes ray\n                        _('rec-clip').style.display = \"none\";\n                        toggleAnimate.flightStars = true;\n                        toggleRobot.flight = true;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"scroll\",\n        value: function scroll() {\n            var _this10 = this;\n\n            window.addEventListener('scroll', function (e) {\n                // If nav item is clicked that scroll event will run and not trigger this scroll event\n                if (navToggle.toggle) {\n\n                    _this10.checkElemTop(e);\n                }\n            });\n        }\n    }]);\n\n    return ScrollAnimate;\n}(Navigation);\n\nvar scrollAnimate = new ScrollAnimate();\nscrollAnimate.scroll();\n\n//*** HAND SHAKE ***\n\nvar Digital = function () {\n    function Digital() {\n        _classCallCheck(this, Digital);\n\n        this.path = document.querySelectorAll('.stroke');\n        this.watch = document.getElementById('rotate_watch');\n    }\n\n    _createClass(Digital, [{\n        key: \"startHandAnimation\",\n        value: function startHandAnimation() {\n            var _this11 = this;\n\n            console.log('hey');\n            this.watch.classList.add('rotateWatch');\n            for (var i = 0; i < this.path.length; i++) {\n                this.path[i].classList.add('path');\n            }\n            //Removes animation after 4 intervals \n            setTimeout(function () {\n                _this11.removeDigitalAnimation();\n            }, 8100);\n        }\n    }, {\n        key: \"removeDigitalAnimation\",\n        value: function removeDigitalAnimation() {\n            this.watch.classList.remove('rotateWatch');\n            for (var i = 0; i < this.path.length; i++) {\n                this.path[i].classList.remove('path');\n            }\n        }\n    }]);\n\n    return Digital;\n}();\n\nvar circuitToggle = {\n    toggleAnim: true\n};\n\nvar Circuit = function () {\n    function Circuit() {\n        _classCallCheck(this, Circuit);\n\n        this.animCircuit = _('animate-circuit');\n        this.startAnimation = this.startAnimation.bind(this);\n        this.speed = [];\n        this.elements = [];\n        this.index = [];\n        this.pathLength = [];\n    }\n\n    _createClass(Circuit, [{\n        key: \"getDashStroke\",\n        value: function getDashStroke(el) {\n\n            var length = el.length;\n            while (length--) {\n                var index = el[length];\n                this.pathLength.unshift(_('animate-circuit')[index].getTotalLength());\n            }\n        }\n    }, {\n        key: \"getRandomPath\",\n        value: function getRandomPath(count) {\n            var i = 0;\n            var length = count;\n\n            while (i < length) {\n\n                var item = Math.floor(Math.random() * 10);\n\n                //Checks first to make sure same index is not in array\n                var notInArray = this.index.indexOf(item) === -1;\n\n                if (notInArray) {\n                    i++;\n                    this.index.push(item);\n                    this.elements.push(_('animate-circuit')[item]);\n                }\n            }\n\n            //Updates new random elements and returns them\n            this.animCircuit = this.elements;\n            return this.index;\n        }\n    }, {\n        key: \"addData\",\n        value: function addData(index) {\n\n            this.speed.push({ speed: 0, j: 0, delay: 25 * index });\n        }\n    }, {\n        key: \"setDashArray\",\n        value: function setDashArray(count) {\n            var allElements = _('animate-circuit').length;\n            var index = this.getRandomPath(count);\n            var i = count;\n            this.getDashStroke(index);\n\n            while (i--) {\n\n                this.animCircuit[i].style.stroke = 'orange';\n                this.animCircuit[i].style.strokeDashoffset = -this.pathLength[i];\n                this.animCircuit[i].style.strokeDasharray = this.pathLength[i];\n\n                this.addData(count);\n\n                if (i === 0) this.startAnimation();\n            }\n        }\n    }, {\n        key: \"startAnimation\",\n        value: function startAnimation() {\n            var dist = this.pathLength;\n            var el = this.animCircuit;\n            var duration = this.speed;\n            var length = el.length;\n\n            function draw() {\n                //Removes Animation\n                if (!toggleAnimate.circuit) {\n                    var i = el.length;\n\n                    while (i--) {\n                        el[i].removeAttribute('style');\n                    }\n                    return;\n                }\n\n                for (var _i3 = length - 1; _i3 >= 0; _i3--) {\n                    var dashArray = el[_i3].style.strokeDasharray;\n                    var dashOffset = el[_i3].style.strokeDashoffset;\n                    // StrokeDashoffset is less then 0 runs same direction \n                    if (dashOffset >= 0 && !duration[_i3].j) {\n                        duration[_i3].speed = 0;\n                        duration[_i3].j = 1;\n                        _iterator4 = 0;\n                    }\n\n                    var speed = duration[_i3].speed += 4;\n                    var _iterator4 = dashOffset <= 0 ? -dist[_i3] : 0;\n\n                    //Stops strokedasharray at about a 3rd to keep the length that size\n                    if (dashArray >= dist[_i3] / 1.8) {\n\n                        dashArray = dist[_i3] - speed;\n                    }\n\n                    el[_i3].style.strokeDashoffset = _iterator4 + speed;\n                }\n                requestAnimationFrame(draw);\n            }\n            requestAnimationFrame(draw.bind(this));\n        }\n    }]);\n\n    return Circuit;\n}();\n\nvar digital = new Digital();\nvar circuit = new Circuit();\n\ncircuitToggle.toggleAnim = false;\n\nwindow.onload = function (e) {\n    circuit.setDashArray(6);\n    // digital.startHandAnimation()\n    // console.log(document.getElementById('test-line').getTotalLength());\n\n    var newTechnologies = new Technologies();\n    newTechnologies.loadImages();\n\n    document.querySelector('.technologies .start-canvas').addEventListener('click', function () {\n        Technologies.prototype.toggle = true;\n        requestAnimationFrame(newTechnologies.draw.bind(newTechnologies));\n    }.bind(this));\n\n    document.querySelector('.technologies .stop-canvas').addEventListener('click', function () {\n        Technologies.prototype.toggle = false;\n        requestAnimationFrame(newTechnologies.draw.bind(newTechnologies));\n    }.bind(this));\n\n    var starryNight = new StarryNight();\n    starryNight.loadImages();\n\n    hoverMap();\n\n    var designSlider = new DesignSlider();\n    designSlider();\n\n    robot[1](); //updates robot location\n    robot[0].loadImages(); //then loades images into slider\n\n    robotFlight.flyIntoPlace.hideRobot(1.3); //Hides flying robot out of screen view\n\n}.bind(undefined);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9zcmMvbWFpbi5qcz8yZWUyIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqKioqKiAgR0xPQkFMIFZBUklBQkxFUyAgKioqKioqKi8gXG52YXIgYW5pbWF0ZTc2OCA9IFwiTTU2NS4xLDB2OTAwSDBjMCwwLDAtNzUuMywwLTE5Mi40YzAtMjExLjcsMC0zMDMuNywwLTUzMy4xQzAsNTAuNSwwLDAsMCwwSDU2NS4xejtcIitcbiAgICAgICAgICAgICAgICAgXCJNNTY1LjEsMHY5MDBIMTgyLjdjMCwwLTQ0LTcyLjUtNDQtMTkxLjdjMC0xMDcuNSwxMjEuOC0zOTYuMSwxMjEuOC01MzMuOEMyNjAuNSw0MSwyNDUuOSwwLDI0NS45LDBINTY1LjF6O1wiK1xuICAgICAgICAgICAgICAgICBcIk01NzEuOCwwdjkwMEgzODYuN2MwLDAtMzEuNC00Mi43LTMxLjQtMTkxLjdDMzU1LjMsNTY4LDU1NSwyODUsNTU1LDgwLjdDNTU1LDIwLDU1MS41LDAsNTUxLjUsMEg1NzEuOHo7XCIrXG4gICAgICAgICAgICAgICAgIFwiTTU3MywwdjkwMGgtMi4zYzAsMCwwLjQtNjUuMiwwLjQtMTkyLjRjMC0xNzYuOC0wLjItMzQ3LjktMC4yLTUzMy40YzAtMTI0LTAuMi0xNzQuMi0wLjItMTc0LjJINTczelwiO1xuXG52YXIgYW5pbWF0ZTQwMCA9IFwiTTM5MCw4MDBINmMwLDAtNi00NS45LTYtMTYxLjNDMCw0NDMuNiw1LDI4Ni4xLDUsNDcuM0M1LDEwLjcsMywwLDMsMGgzODdWODAwejtcIitcbiAgICAgICAgICAgICAgICAgXCJNMzkwLDgwMEg5NmMwLDAtNDYtNDUuOS00Ni0xNjEuM2MwLTE5NS4xLDEzMC0zNTIuNiwxMzAtNTkxLjNjMC0zNi43LTMtNDcuMy0zLTQ3LjNoMjEzVjgwMHo7XCIrXG4gICAgICAgICAgICAgICAgIFwiTTM5MCw4MDBIMjQzYzAsMC0zNy00NS45LTM3LTE2MS4zYzAtMTk1LjEsMTc2LTM1Mi42LDE3Ni01OTEuM2MwLTM2LjctMS00Ny4zLTEtNDcuM2g5VjgwMHo7XCIrXG4gICAgICAgICAgICAgICAgIFwiTTM5MCw4MDBoLTdjMCwwLDAtNDUuOSwwLTE2MS4zYzAtMTk1LjEsNS0zNTIuNiw1LTU5MS4zYzAtMzYuNy0xLTQ3LjMtMS00Ny4zaDNWODAwelwiO1xuXG52YXIgaXNGaXJlZm94ID0gdHlwZW9mIEluc3RhbGxUcmlnZ2VyICE9PSAndW5kZWZpbmVkJztcbnZhciBpc1NhZmFyaSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIlNhZmFyaVwiKSAhPSAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoXCJDaHJvbWVcIikgPT09IC0xO1xuXG52YXIgd1cgPSB3aW5kb3cuaW5uZXJXaWR0aDtcbnZhciB3SCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbnZhciBsYXN0RGlzdDtcblxuXG4vL0ZpcmVmb3ggQnVnLCB0cmFuc2Zvcm1zIG5vdCB3b3JraW5nLCBzbyBzZXRzIGF0dHJpYnV0ZSB0byAwIGluc3RlYWRcbmlmKGlzRmlyZWZveCl7XG4gICAgLy9zdmcgbW9yZmluZyBwcm9ibGVtXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ZlR2F1c3NpYW5CbHVyJylbMF0uc2V0QXR0cmlidXRlKCdzdGREZXZpYXRpb24nLCAnNicpXG4gICAgLy9zdmcgY3NzIHByb2JsZW1cbiAgICBfKCdzdmctY2lyY2xlJykuc2V0QXR0cmlidXRlKCdyJywgMCk7XG4gICAgXygnc3ZnLWNpcmNsZScpLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgxKSdcbn0gXG5cbmlmKGlzU2FmYXJpKSBfKCdzdmctcGFnZScpLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiXG5cbmZ1bmN0aW9uIF8oY2xzcyl7XG5cbiAgICBsZXQgY2xhc3NlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoY2xzcyk7XG5cbiAgICBpZihjbGFzc2VzLmxlbmd0aCA9PT0gMSl7XG4gICAgICAgIHJldHVybiBjbGFzc2VzWzBdXG4gICAgfVxuICAgIGlmKGNsYXNzZXMubGVuZ3RoID4gMSl7XG4gICAgICAgIHJldHVybiBjbGFzc2VzXG4gICAgfWVsc2UgcmV0dXJuIFwiTm90IGEgd29ya2luZyBjbGFzc1wiXG59O1xuXG52YXIgZWFzZU91dCA9IGZ1bmN0aW9uKHByb2dyZXNzKXtcbiAgICByZXR1cm4gTWF0aC5wb3coLS1wcm9ncmVzcywgNSkgKyAxO1xufTtcblxuLy9TdHJpbmc6IGluZGljYXRlcyBuZXcgc2l6ZSBvZiB3aWR0aCBvciBoZWlnaHQgdGhhdCB5b3Ugd2FudC4gU2l6ZTogb2YgdGhlIG5ldyBzaXplIG9mIHRoZSBzdHJpbmcuIEVsOiB0aGUgZWxlbWVudCB5b3Ugd2FudCBpdCBmb3JcbnZhciBuZXdTaXplID0gZnVuY3Rpb24oc3RyaW5nLCBzaXplLCBlbCl7XG4gICAgaWYodHlwZW9mIGVsICAhPT0gJ3VuZGVmaW5lZCcpe1xuICAgICAgICBcblxuICAgICAgICB2YXIgb2dXaWR0aCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoXG4gICAgICAgIHZhciBvZ0hlaWdodCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodFxuICAgICAgICBpZihvZ1dpZHRoID09PSAwIHx8IG9nSGVpZ2h0ID09PSAwKXtcbiAgICAgICAgICAgIG9nV2lkdGggPSBlbC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJylcbiAgICAgICAgICAgIG9nSGVpZ2h0ID0gZWwuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKVxuICAgICAgICB9XG4gICAgfWVsc2V7XG4gICAgICAgIHZhciBvZ1dpZHRoID0gNzYyLjIyXG4gICAgICAgIHZhciBvZ0hlaWdodCA9IDY2OC45N1xuICAgIH1cbiAgICBcbiAgICBpZihzdHJpbmcgPT09ICdoZWlnaHQnICl7XG4gICAgICAgIGxldCByYXRpbyA9IG9nSGVpZ2h0IC8gc2l6ZVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVpZ2h0OiBzaXplLFxuICAgICAgICAgICAgd2lkdGg6IG9nV2lkdGggLyByYXRpb1xuICAgICAgICB9XG5cbiAgICB9ZWxzZSBpZihzdHJpbmcgPT09ICd3aWR0aCcgKXtcbiAgICAgICAgbGV0IHJhdGlvID0gb2dXaWR0aCAvIHNpemVcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiBzaXplLFxuICAgICAgICAgICAgaGVpZ2h0OiBvZ0hlaWdodCAvIHJhdGlvXG4gICAgICAgIH1cbiAgICB9ZWxzZSBjb25zb2xlLmxvZygnY2hlY2sgcGFyYW1ldGVycycpO1xufVxuXG5cbldlYkZvbnQubG9hZCh7XG4gICAgZ29vZ2xlOiB7XG4gICAgICBmYW1pbGllczogWydEbyBIeWVvbicsICdPcmJpdHJvbiddXG4gICAgfSxcbiAgICBhY3RpdmU6IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vU3RhcnRzIHdoZW4gZ29vZ2xlIGZvbnRzIGFyZSBsb2FkZWQgICAgIFxuICAgICAgICBzbG90TWFjaGluZSgpO1xuICAgICAgICBTdHJldGNoKCk7XG4gICAgfVxufSlcblxuZnVuY3Rpb24gc2xvdE1hY2hpbmUoKXtcblxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2xvdC1tYWNoaW5lJyk7XG4gICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgXG4gICAgdmFyIFNsb3QgPSBmdW5jdGlvbigpe1xuXHQgICAgdGhpcy54ID0gMDtcblx0XHR0aGlzLndpZHRoID0gY2FudmFzLndpZHRoID0gd1cgPCA5NzAgPyAzNjAgOiA0NzU7XG5cdCAgICB0aGlzLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSB3VyA8IDk3MCA/IDM2MCA6IDQ3NTtcblx0XHR0aGlzLnRleHQgPSAnUEhPVE8nXG5cdCAgICB0aGlzLmxldHRlcnMgPSBbXTtcblxuXHQgICAgdGhpcy5hZGRMZXR0ZXIgPSBmdW5jdGlvbihuKXtcblxuXHQgICAgICAgIHZhciBsZXR0ZXJIZWlnaHQgPSB3VyA8IDk3MCA/IC0xMjQgOiAtMTU4O1xuXG5cdCAgICAgICAgLy9QbGFjZXMgbGV0dGVycyBhdCB0b3AgaW5kZXggMSwzLDVcblx0ICAgICAgICB2YXIgYm90dG9tID0gd1cgPCA5NzAgPyB0aGlzLmhlaWdodCArIDYwIDogdGhpcy5oZWlnaHQgKyA5Njtcblx0ICAgICAgICBmb3IodmFyIGogPSAwOyBqIDwgbjsgaisrICl7XG5cdCAgICAgICAgICAgIC8vUmVzZXRzIHggZXZlcnkgaXRlcmF0aW9uXG5cdCAgICAgICAgICAgIHRoaXMueCA9IDBcblx0ICAgICAgICAgICAgLy9BZGp1c3QgYm90dG9tIGFuZCBoZWlnaHQgYWxsIGxldHRlcnNcblx0ICAgICAgICAgICAgbGV0dGVySGVpZ2h0ID0gd1cgPCA5NzAgPyBsZXR0ZXJIZWlnaHQgKyAxMjEgOiBsZXR0ZXJIZWlnaHQgKyAxNThcblx0ICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMudGV4dC5sZW5ndGg7IGkrKyl7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBkYXRhID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHRvcDogbGV0dGVySGVpZ2h0LFxuXHQgICAgICAgICAgICAgICAgICAgIGxldHRlcjogdGhpcy50ZXh0W2ldLFxuXHQgICAgICAgICAgICAgICAgICAgIHg6IGkgPT09IDAgPyAtNSA6IHdXIDwgOTcwID8gdGhpcy54Kz03NCA6IHRoaXMueCs9MTAwLjgsXG5cdCAgICAgICAgICAgICAgICAgICAgc3BlZWQ6IDksIFxuXHQgICAgICAgICAgICAgICAgICAgIGJvdHRvbTogYm90dG9tIC0gbGV0dGVySGVpZ2h0LFxuXHQgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBpICUgMiA9PT0gMCA/IFwidXBcIiA6IFwiZG93blwiXG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBuID09PSA0ID8gdGhpcy5sZXR0ZXJzLnB1c2goZGF0YSkgOiB0aGlzLmxldHRlcnMudW5zaGlmdChkYXRhKVxuXG5cdCAgICAgICAgICAgICAgICB2YXIgbGV0dGVyID0gZGF0YVxuXHQgICAgICAgIFxuXHQgICAgICAgICAgICAgICAgaWYoaSUyID09PSAwKXtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdVcChsZXR0ZXIpXG5cdCAgICAgICAgICAgICAgICB9ZWxzZXtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIHdXIDwgOTcwICl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9maXhlcyBzcGFjaW5nIGlzc3VlIE9yYml0cm9uIGZvbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID09PSAzID8gbGV0dGVyLnggKz0gMyA6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID09PSAxID8gbGV0dGVyLnggLT0gMyA6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdEb3duKGxldHRlcilcblx0ICAgICAgICAgICAgICAgIH0gXG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9XG5cdCAgIHRoaXMuYWRkTGV0dGVyKDQpXG5cdH1cblxuICAgIFNsb3QucHJvdG90eXBlLmRyYXdVcCA9IGZ1bmN0aW9uKHRleHQpe1xuICAgICAgXG4gICAgICAgIGN0eC5mb250ID0gd1cgPCA5NzAgPyAgXCJCb2xkIDYycHQgT3JiaXRyb25cIiA6IFwiMTA1cHQgRG8gSHllb25cIjtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQubGV0dGVyLHRleHQueCwgdGV4dC5ib3R0b20pXG4gICAgfVxuICAgIFNsb3QucHJvdG90eXBlLmRyYXdEb3duID0gZnVuY3Rpb24odGV4dCl7XG4gICAgICAgIFxuXHRcdGN0eC5maWxsU3R5bGUgPSBcIiMwRDFCNTZcIjtcbiAgICAgICAgIGN0eC5mb250ID0gd1cgPCA5NzAgPyBcIkJvbGQgNjJwdCBPcmJpdHJvblwiIDogXCIxMDVwdCBEbyBIeWVvblwiO1xuICAgICAgICBjdHguZmlsbFRleHQodGV4dC5sZXR0ZXIsdGV4dC54LCB0ZXh0LnRvcClcblxuICAgIH1cblxuICAgIFNsb3QucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgLy8gdmFyIHB1c2ggPSB3VyA8IDk3MCA/IC02MSA6IC03NFxuICAgICAgICB2YXIgcHVzaCA9IHdXIDwgOTcwID8gLTYxIDogLTc1XG4gICAgXHRpZighc2xvdE1hY2hpbmUucHJvdG90eXBlLnRvZ2dsZSkgcmV0dXJuO1xuICAgIFxuICAgICAgICAvL05ldyBzZXQgaWYgbGV0dGVycyBkcmF3biBiYXNlZCBvbiBzcGFjaW5nXG4gICAgICAgIGlmKHRoaXMubGV0dGVyc1sxOV0uYm90dG9tIDw9IHB1c2ggKXtcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmxldHRlcnMuc3BsaWNlKDE1LDUpXG4gICAgICAgICAgICB0aGlzLmFkZExldHRlcigxKVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLDAsY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KVxuICAgICAgICBcbiAgICBcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxldHRlcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGxldHRlciA9IHRoaXMubGV0dGVyc1tpXVxuXG4gICAgICAgICAgICBsZXR0ZXIudG9wICs9IGxldHRlci5zcGVlZCBcbiAgICAgICAgICAgIGxldHRlci5ib3R0b20gLT0gbGV0dGVyLnNwZWVkIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZihsZXR0ZXIuc3RhcnQgPT09IFwidXBcIil7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmRyYXdVcChsZXR0ZXIpXG5cbiAgICAgICAgICAgIH1lbHNlIHRoaXMuZHJhd0Rvd24obGV0dGVyKVxuICAgIFx0fVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGUuYmluZCh0aGlzKSlcbiAgICB9XG4gICAgdmFyIHNsb3QgPSBuZXcgU2xvdCgpXG4gICAgXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBob3RvIC5zdGFydC1jYW52YXMnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCl7XG4gICAgICAgIFxuICAgIFx0Ly9TdGFydCBDYW52YXNcbiAgICBcdHNsb3RNYWNoaW5lLnByb3RvdHlwZS50b2dnbGUgPSB0cnVlXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzbG90LnVwZGF0ZS5iaW5kKHNsb3QpKVxuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnBob3RvIC5zdG9wLWNhbnZhcycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKXtcbiAgICAgIFx0Ly9TdG9wIENhbnZhc1xuICAgIFx0c2xvdE1hY2hpbmUucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgfSk7XG5cbn1cblxuXG5cbmZ1bmN0aW9uIFN0cmV0Y2goKXtcblxuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3RyZXRjaCcpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgXG4gICAgaWYod1cgPCA5NzApe1xuICAgICAgICB2YXIgd2lkdGggPSA0MDBcbiAgICAgICAgdmFyIGhlaWdodCA9ICAzNzVcbiAgICAgICAgdmFyIHN0cnRjaCA9IDE1XG4gICAgICAgIHZhciBsZXR0ZXJEaXN0ID0gNTNcbiAgICAgICAgdmFyIHggPSA2NVxuICAgICAgICB2YXIgc3RyZXRjaFggPSA1XG4gICAgICAgIHZhciBtaXhlZE51bSA9IDVcbiAgICB9XG4gICAgaWYod1cgPCA0MDApe1xuICAgICAgICB2YXIgd2lkdGggPSAzNjBcbiAgICAgICAgdmFyIGhlaWdodCA9ICAzNzVcbiAgICAgICAgdmFyIHggPSA1MFxuICAgICAgICB2YXIgbWl4ZWROdW0gPSAtMTBcbiAgICB9XG4gICAgaWYod1cgPiA5NzApe1xuICAgICAgICB2YXIgd2lkdGggPSA2NTBcbiAgICAgICAgdmFyIGhlaWdodCA9ICA0NTBcbiAgICAgICAgdmFyIHN0cnRjaCA9IDMwXG4gICAgICAgIHZhciBsZXR0ZXJEaXN0ID0gNjVcbiAgICAgICAgdmFyIHggPSAxMjVcbiAgICAgICAgdmFyIG1peGVkTnVtID0gNVxuICAgIH1cbiAgICAvKiogQ0hBTkdFIE5VTUJFUiBGT1IgbGluZUNvdW50IFRPIEFERCBPUiBTVUJUUkFDVCBIT1cgTUFOWSBMSU5FUyBPRiBXT1JEUyAqKi9cbiAgICB2YXIgbGluZUNvdW50ID0gNztcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciB0ID0gbGluZUNvdW50IC0gMTtcbiAgICB2YXIgY29sb3JzID0gW1wiI0RBRjdBNlwiLCBcIiNGRkMzMDAgXCIsIFwiI0ZGNTczM1wiLCBcIiNDNzAwMzlcIiwgXCIjOTAwQzNGXCIsIFwiIzU4MTg0NVwiLCBcIiMzNzEwMmJcIl1cbiAgICB2YXIgTGV0dGVycyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIC8vIHRoaXMudGV4dCA9ICdTT0xVVElPTlMnXG4gICAgICAgIHRoaXMubGV0dGVycyA9IFtdO1xuICAgICAgICB0aGlzLnRvdGFsID0gdGhpcy5sZXR0ZXJzLmxlbmd0aCAtIDFcbiAgICAgICAgdGhpcy50b3RhbCA9IDA7XG4gICAgICAgIHRoaXMueSA9IDA7XG5cbiAgICAgICAgXG4gICAgICAgIHRoaXMud2lkdGggPSBjYW52YXMud2lkdGggPSB3aWR0aFxuICAgICAgICB0aGlzLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQgPSBoZWlnaHRcbiAgICAgICAgdGhpcy50ZXh0ID0gJ0RFVkVMT1BFUidcbiAgICAgICAgXG4gICAgICAgIHRoaXMucHVzaExldHRlcnMgPSBmdW5jdGlvbih4LCBkaXN0KXtcbiAgICAgICAgICAgIC8vSWYgcHVzaExldHRlcnMgaXMgcmFuIGFnYWluIG1ha2VzIHN1cmUgdGhpcy55ID0gMFxuICAgICAgICAgICAgaWYodGhpcy55KSB0aGlzLnkgPSAwXG4gICAgICAgICAgICB2YXIgY2FudmFzSGVpZ2h0ID0gdGhpcy5oZWlnaHRcbiAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBsaW5lQ291bnQ7IGkrKyl7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgICAgIGxldHRlcjogdGhpcy50ZXh0LFxuICAgICAgICAgICAgICAgICAgICBzdHJldGNoOiBzdHJ0Y2gsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgICAgICAgICAgICBzcGVlZDogaSxcbiAgICAgICAgICAgICAgICAgICAgZGlzdDogdHlwZW9mIGRpc3QgPT09ICdudW1iZXInID8gZGlzdCA6IDAsXG4gICAgICAgICAgICAgICAgICAgIC8vTGV0dGVycyBkaXN0YW5jZSBiZXR3ZWVuIGVhY2ggb3RoZXIgdmlydGljbGUgXG4gICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogdGhpcy55ICs9IGxldHRlckRpc3QsXG4gICAgICAgICAgICAgICAgICAgICAvL0xldHRlcnMgc3RhcnQgb24gdGhlIGJvdHRvbVxuICAgICAgICAgICAgICAgICAgICBib3R0b206IHdXIDwgOTcwID8gY2FudmFzSGVpZ2h0ICsgNDUgOiBjYW52YXNIZWlnaHQgKyA2MixcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IDEsXG4gICAgICAgICAgICAgICAgICAgIC8vV2hlbiB0aGUgbmV4dCByb3RhdGlvbiBzdGFydHNcbiAgICAgICAgICAgICAgICAgICAgYmVnaW5ZOiAwLFxuICAgICAgICAgICAgICAgICAgICBzY2FsZVRvdGFsOiA0LFxuICAgICAgICAgICAgICAgICAgICBkaXN0WTogMCxcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yc1tpXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxldHRlcnMucHVzaChkYXRhKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHVzaExldHRlcnMoeClcbiAgICB9XG5cbiAgICB2YXIgZHJhd1VwID0gZnVuY3Rpb24obGV0dGVyLCBkaXN0KXtcblxuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsMCwwLCBsZXR0ZXIuc2NhbGUsbGV0dGVyLngsIGxldHRlci5ib3R0b20gLSBkaXN0IClcbiAgICAgICAgY3R4LmZvbnQgPSB3VyA8IDk3MCA/IFwiNDBwdCBEbyBIeWVvblwiIDogXCI2MHB0IERvIEh5ZW9uXCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsZXR0ZXIuY29sb3JcbiAgICAgICAgY3R4LmZpbGxUZXh0KGxldHRlci5sZXR0ZXIsIDAsIGxldHRlci50ZXh0WSk7XG4gICAgICAgIC8vIHZhciB0ZXh0ID0gY3R4Lm1lYXN1cmVUZXh0KGxldHRlci5sZXR0ZXIpXG4gICAgfVxuICAgIHZhciBzdHJldGNoID0gZnVuY3Rpb24odGV4dCl7XG4gICAgICAgIGN0eC5jYW52YXMuc3R5bGUubGV0dGVyU3BhY2luZyA9IHRleHQuZGlzdCArJ3B4J1xuICAgICAgICBjdHguZm9udCA9IHdXIDwgOTcwID8gXCI0MHB0IERvIEh5ZW9uXCIgOiBcIjYwcHQgRG8gSHllb25cIjtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRleHQuY29sb3JcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRleHQubGV0dGVyLCB0ZXh0LngsIHRleHQuYm90dG9tIC0gdGV4dC5kaXN0YW5jZSApXG4gICAgfVxuXG4gICAgdmFyIGRyYXdEb3duID0gZnVuY3Rpb24obGV0dGVyKXtcbiAgICAgICAgY3R4LmZvbnQgPSB3VyA8IDk3MCA/IFwiNDBwdCBEbyBIeWVvblwiIDogXCI2MHB0IERvIEh5ZW9uXCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsZXR0ZXIuY29sb3JcbiAgICAgICAgY3R4LmZpbGxUZXh0KGxldHRlci5sZXR0ZXIsIGxldHRlci54LCBsZXR0ZXIueSlcbiAgICB9XG5cbiAgICB2YXIgZHJhd0JhY2tGbGlwID0gZnVuY3Rpb24obGV0dGVyKXtcbiAgICAgICAgY3R4LmZvbnQgPSB3VyA8IDk3MCA/IFwiNDBwdCBEbyBIeWVvblwiIDogXCI2MHB0IERvIEh5ZW9uXCI7XG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBsZXR0ZXIuY29sb3JcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwgbGV0dGVyLnNjYWxlLGxldHRlci54LCBsZXR0ZXIueSApXG4gICAgICAgIGN0eC5maWxsVGV4dChsZXR0ZXIubGV0dGVyLCAwLCBsZXR0ZXIudGV4dFkpO1xuICAgIH1cbiAgICBcbiAgICBMZXR0ZXJzLnByb3RvdHlwZS5hZGRMZXR0ZXJzID0gZnVuY3Rpb24odGltZXN0YW1wKXtcblxuICAgIFx0aWYoIVN0cmV0Y2gucHJvdG90eXBlLnRvZ2dsZSkgcmV0dXJuO1xuICAgICAgIFx0dmFyIGogPSAwO1xuXHRcbiAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi11bmRlcic7XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApO1xuICAgICAgICBjdHguY2xlYXJSZWN0KDAsMCxjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpXG5cbiAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGV0dGVycy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBsZXR0ZXIgPSB0aGlzLmxldHRlcnNbaV07XG4gICAgICAgICAgICBsZXR0ZXIueSA9IGxldHRlci5ib3R0b20gLSBsZXR0ZXIuZGlzdGFuY2VcblxuICAgICAgICAgICAgLy9GT1VSVEggQU5EIExBU1QgQ0FMTCwgUkVNT1ZFIFdPUkRTXG4gICAgICAgICAgICBpZihjb3VudCA9PT0gMyAmJiBpID09PSB0KSB7XG5cbiAgICAgICAgICAgICAgICBpZighbGV0dGVyLnN0YXJ0KSBsZXR0ZXIuc3RhcnQgPSB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICB2YXIgcnVudGltZSA9IHRpbWVzdGFtcCAtIGxldHRlci5zdGFydFxuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IE1hdGgubWluKHJ1bnRpbWUgLyA2MDAsIDEpXG4gICAgICAgICAgICAgICAgbGV0dGVyLnkgKz0gKGxldHRlci5kaXN0YW5jZSAqIHByb2dyZXNzKVxuXG4gICAgICAgICAgICAgICAgbGV0dGVyLnNjYWxlID0gMCB8fCAobGV0dGVyLmJlZ2luIC0gKCBsZXR0ZXIuc2NhbGVUb3RhbCAqIHByb2dyZXNzKSApLnRvRml4ZWQoMilcbiAgICAgICAgICAgICAgICBsZXR0ZXIudGV4dFkgPSAgKGxldHRlci5iZWdpblkgKyAoIGxldHRlci5kaXN0WSAqIHByb2dyZXNzKSApLnRvRml4ZWQoMilcbiAgICAgICAgICAgICAgICBkcmF3QmFja0ZsaXAobGV0dGVyKVxuXG4gICAgICAgICAgICAgICAgIGlmKGxldHRlci5zY2FsZSA9PSAtMSB8fCBsZXR0ZXIuc2NhbGUgPCAtMSl7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGxldHRlci5iZWdpblkgPSAxMFxuICAgICAgICAgICAgICAgICAgICBsZXR0ZXIuZGlzdFkgPSB3VyA8IDk3MCA/IC01IDogLTEwXG4gICAgICAgICAgICAgICAgICAgIGxldHRlci5zY2FsZVRvdGFsID0gLTRcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVyLmJlZ2luID0gLTNcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiggcHJvZ3Jlc3MgPT09IDEgKXtcbiAgICAgICAgICAgICAgICAgICAgLy9SZW1vdmVzIGl0ZW0gZnJvbSBhcnJheSBhZnRlciBlYWNoIHdvcmQgaXMgZmluaXNoZWQgYW5pbWF0aW5nXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGV0dGVycy5zcGxpY2UodCwxKVxuICAgICAgICAgICAgICAgICAgICB0LS1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYoIHQgPT09IC0xICl7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG90YWwgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBsaW5lQ291bnQgLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxldHRlcnMubGVuZ3RoID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTGV0dGVycyh4KVxuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksIDIwMClcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoIGNvdW50ID09PSAzICYmIGkgIT09IHQgKSBkcmF3RG93bihsZXR0ZXIpXG5cblxuICAgICAgICAgICAgLy9USElSRCwgTEVUVEVSIFNUUkVUQ0ggSU5cbiAgICAgICAgICAgIGlmKCBjb3VudCA9PT0gMiAmJiBpID09PSB0ICkge1xuICAgICAgICAgICAgICAgIGlmKCFsZXR0ZXIuc3RhcnQpIGxldHRlci5zdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgIHZhciBydW50aW1lID0gdGltZXN0YW1wIC0gbGV0dGVyLnN0YXJ0XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gTWF0aC5taW4ocnVudGltZSAvIDEyNSwgMSlcbiAgICAgICAgICAgICAgICBsZXR0ZXIuZGlzdCA9IGxldHRlci5zdHJldGNoIC0gKGxldHRlci5zdHJldGNoICogcHJvZ3Jlc3MpXG5cbiAgICAgICAgICAgICAgICBsZXR0ZXIueCA9IG1peGVkTnVtICsgKGxldHRlci5zdHJldGNoICogcHJvZ3Jlc3MpICogNFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHN0cmV0Y2gobGV0dGVyKVxuXG4gICAgICAgICAgICAgICBpZihwcm9ncmVzcyA9PT0gMSApe1xuICAgICAgICAgICAgICAgICAgICB0LS1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9SRVNFVFMgVkFSSUFCTEVTLCBDQUxMUyBGVU5DVElPTiBBTEwgT1ZFUiBBR0FJTlxuICAgICAgICAgICAgICAgIGlmKHQgPT09IC0xKXtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrK1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IGxpbmVDb3VudCAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubGV0dGVycy5sZW5ndGggPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnB1c2hMZXR0ZXJzKHgsIDApXG4gICAgICAgICAgICAgICAgICAgIH0uYmluZCh0aGlzKSwgMjAwKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGNvdW50ID09PSAyICYmIGkgIT09IHQpIHtcblxuICAgICAgICAgICAgICAgIHN0cmV0Y2gobGV0dGVyKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgICAgLy9TRUNPTkQsIExFVFRFUiBTVFJFVENIIE9VVFxuICAgICAgICAgICAgaWYoIGNvdW50ID09PSAxICYmIGkgPT09IGogKSB7XG5cbiAgICAgICAgICAgICAgICBpZighbGV0dGVyLnN0YXJ0KSBsZXR0ZXIuc3RhcnQgPSB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICB2YXIgcnVudGltZSA9IHRpbWVzdGFtcCAtIGxldHRlci5zdGFydFxuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IE1hdGgubWluKHJ1bnRpbWUgLyAxNTAsIDEpO1xuXG4gICAgICAgICAgICAgICAgbGV0dGVyLmRpc3QgPSBsZXR0ZXIuc3RyZXRjaCAqIHByb2dyZXNzO1xuICAgICAgICAgICAgICAgIGxldHRlci54ID0geCAtIChsZXR0ZXIuZGlzdCAqIDQpXG4gICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHN0cmV0Y2gobGV0dGVyKVxuXG4gICAgICAgICAgICAgICAgaWYoIHByb2dyZXNzID09PSAxICl7XG4gICAgICAgICAgICAgICAgICAgIGorK1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmKCBqID09PSB0aGlzLmxldHRlcnMubGVuZ3RoICl7XG4gICAgICAgICAgICAgICAgICAgIGNvdW50KytcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sZXR0ZXJzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIC01IGJlY2F1c2UgbGV0dGVycyBzdHJldGNoZWQgdG8gZmFyLCBuZWVkIHRvIGZpeCBudW1iZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdXIDwgOTcwID8gdGhpcy5wdXNoTGV0dGVycyg1LCAxNSkgOiB0aGlzLnB1c2hMZXR0ZXJzKDUsIDMwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTGV0dGVycyhtaXhlZE51bSwgd1cgPCA5NzAgPyAxNSA6IDMwIClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiggY291bnQgPT0gMSAmJiBpICE9PSBqICkge1xuICAgICAgICAgICAgICAgIGxldHRlci54ID0gbGV0dGVyLnhcbiAgICAgICAgICAgICAgICBsZXR0ZXIuZGlzdCA9IGxldHRlci5kaXN0XG4gICAgICAgICAgICAgICAgc3RyZXRjaChsZXR0ZXIpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vRklSU1QsIExFVFRFUiBDTElNQkVcbiAgICAgICAgICAgIGlmKCBpID09PSBqICYmIGNvdW50ID09PSAwICl7XG5cbiAgICAgICAgICAgICAgICBpZighbGV0dGVyLnN0YXJ0KSBsZXR0ZXIuc3RhcnQgPSB0aW1lc3RhbXAgXG4gICAgICAgICAgICAgICAgdmFyIHJ1bnRpbWUgPSB0aW1lc3RhbXAgLSBsZXR0ZXIuc3RhcnRcbiAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBNYXRoLm1pbihydW50aW1lIC8gNjAwLCAxKVxuICAgICAgICAgICAgICAgIHZhciBkaXN0ID0gbGV0dGVyLmRpc3RhbmNlICogcHJvZ3Jlc3M7XG4gICAgXG4gICAgICAgICAgICAgICAgbGV0dGVyLnNjYWxlID0gMCB8fCAobGV0dGVyLmJlZ2luIC0gKCBsZXR0ZXIuc2NhbGVUb3RhbCAqIHByb2dyZXNzKSApLnRvRml4ZWQoMilcbiAgICAgICAgICAgICAgICBsZXR0ZXIudGV4dFkgPSAgKGxldHRlci5iZWdpblkgKyAoIGxldHRlci5kaXN0WSAqIHByb2dyZXNzKSApLnRvRml4ZWQoMilcbiAgIFxuICAgICAgICAgICAgICAgIGRyYXdVcChsZXR0ZXIsIGRpc3QpXG4gIFxuICAgICAgICAgICAgICAgIC8vQWRkcyBzZWNvbmQgZmxpcCB0byBtYWtlIHVwcmlnaHQgdGV4dCBoYWxmIHdheSB1cCBjYW52YXNcbiAgICAgICAgICAgICAgICBpZihsZXR0ZXIuc2NhbGUgPT0gLTEgfHwgbGV0dGVyLnNjYWxlIDwgLTEpe1xuICAgICAgICAgICAgICAgICAgICAvL1doZW4gdGhlIG5leHQgcm90YXRpb24gc3RhcnRzIGZvciBiZWdpblkgYW5kIGRpc3RZXG4gICAgICAgICAgICAgICAgICAgIGxldHRlci5iZWdpblkgPSB3VyA8IDk3MCA/IDUgOiAxMFxuICAgICAgICAgICAgICAgICAgICBsZXR0ZXIuZGlzdFkgPSB3VyA8IDk3MCA/IC01IDogLTEwXG4gICAgICAgICAgICAgICAgICAgIGxldHRlci5zY2FsZVRvdGFsID0gLTRcbiAgICAgICAgICAgICAgICAgICAgbGV0dGVyLmJlZ2luID0gLTNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoIHByb2dyZXNzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGorK1xuICAgICAgICAgICAgICAgIH0gICAgICBcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYoIGogPT09IHRoaXMubGV0dGVycy5sZW5ndGggKXtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxldHRlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wdXNoTGV0dGVycyh4LCAwKVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFkZExldHRlcnMuYmluZCh0aGlzKSlcbiAgICB9XG4gICAgdmFyIGxldHRlcnMgPSBuZXcgTGV0dGVycygpXG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZGV2ZWxvcGVyIC5zdGFydC1jYW52YXMnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGUpe1xuXG4gICAgICAgIFN0cmV0Y2gucHJvdG90eXBlLnRvZ2dsZSA9IHRydWVcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBsZXR0ZXJzLmFkZExldHRlcnMuYmluZChsZXR0ZXJzKSApXG4gXG4gICAgfSk7ICAgXG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuZGV2ZWxvcGVyIC5zdG9wLWNhbnZhcycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKXtcblxuICAgICAgIFN0cmV0Y2gucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG5cbiAgICB9KVxufTtcblxuZnVuY3Rpb24gSW1hZ2VTaGF0dGVyKCl7XG4gICAgdmFyIHNpemluZyA9IGZ1bmN0aW9uKGNvbnRlbnQpe1xuICAgICAgICBpZihjb250ZW50ID09PSAnZHVyJyl7XG4gICAgICAgICAgICBpZiAod2luZG93LmlubmVyV2lkdGggPCA2MDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIDIuNlxuICAgICAgICAgICAgZWxzZSBpZiAod2luZG93LmlubmVyV2lkdGggPiA2MDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIDMuNVxuICAgICAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIGlmKGNvbnRlbnQgPT09ICdpbWcnKXtcbiAgICAgICAgICAgIGlmKHdpbmRvdy5pbm5lcldpZHRoIDw9IDYwMCkgXG4gICAgICAgICAgICAgICAgcmV0dXJuIDQwMFxuICAgICAgICAgICAgZWxzZSBpZiAod2luZG93LmlubmVyV2lkdGggPiAxMjAwKVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIDU4MFxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiA1MDBcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gICAgdmFyIGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIHZhciBjdHgsIGNhbnZhcztcbiAgICB2YXIgcGFydGljbGVDYW52YXMsIHBhcnRpY2xlQ3R4O1xuICAgIHZhciBjYW52YXNQYXJlbnRXaWR0aDtcbiAgICB2YXIgY2FudmFzUGFyZW50SGVpZ2h0O1xuICAgIHZhciBlbmRpbmcgPSBbXVxuICAgIHZhciByZXRyYWN0U3RhcnQgPSAwO1xuICAgIHZhciBpbWdDYW52YXMgPSBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBpbWcsY2FsbGJhY2spe1xuICAgICAgICAvL1dhdGNoIHdoZXJlIHRoaXMgaXMgbG9hZGVkIGludG8gd2hlbiBwb3J0Zm9saW8gZG9uZVxuICAgICAgICAvLyBkb2N1bWVudC5ib2R5LmlubmVySFRNTCArPSAnPGNhbnZhcyBpZD1cImltZy1jYW52YXNcIj48L2NhbnZhcz4nO1xuICAgICAgICAvLyBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaW1nLWNhbnZhcycpXG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXJ0aWNsZScpXG4gICAgICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGhcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodFxuICAgICAgICBjYW52YXNQYXJlbnRXaWR0aCA9IF8oJ3N2Zy1wYWdlJykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGhcbiAgICAgICAgY2FudmFzUGFyZW50SGVpZ2h0ID0gXygnc3ZnLXBhZ2UnKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcblxuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCwgd2lkdGgsaGVpZ2h0KVxuXG4gICAgICAgIC8vQ2FsbHMgZnVuY3Rpb24gZm9yIGNsaWNrYWJsZSBldmVudCBsaXN0ZW5lciB0byBydW4gYW5kIGFwcGVuZHMgYmFja2dyb3VuZCBjYW52YXNcbiAgICAgICAgY2FsbGJhY2soY2FudmFzLGNyZWF0ZVBhcnRpY2xlQ2FudmFzKCkpXG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWNsZUNhbnZhcygpIHtcblxuICAgICAgICAvLyBDcmVhdGUgb3VyIGNhbnZhc1xuICAgICAgICBwYXJ0aWNsZUNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgICAgIHBhcnRpY2xlQ3R4ID0gcGFydGljbGVDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgIC8vIFNpemUgb3VyIGNhbnZhcyB3aXRoIGFkZGl0aW9uYWwgc2l6aW5nXG4gICAgICAgIHBhcnRpY2xlQ2FudmFzLndpZHRoID0gY2FudmFzUGFyZW50V2lkdGhcbiAgICAgICAgcGFydGljbGVDYW52YXMuaGVpZ2h0ID0gY2FudmFzUGFyZW50SGVpZ2h0XG4gICAgICBcbiAgICAgICAgLy8gUG9zaXRpb24gb3V0IGNhbnZhc1xuICAgICAgICBwYXJ0aWNsZUNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgcGFydGljbGVDYW52YXMuc3R5bGUudG9wID0gXCIwXCI7XG4gICAgICAgIHBhcnRpY2xlQ2FudmFzLnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgICAgIFxuICAgICAgICAvLyBNYWtlIHN1cmUgaXQncyBvbiB0b3Agb2Ygb3RoZXIgZWxlbWVudHNcbiAgICAgICAgcGFydGljbGVDYW52YXMuc3R5bGUuekluZGV4ID0gXCI1MDBcIjtcbiAgICAgICAgXG4gICAgICAgIC8vIE1ha2Ugc3VyZSBvdGhlciBlbGVtZW50cyB1bmRlciBpdCBhcmUgY2xpY2thYmxlXG4gICAgICAgIHBhcnRpY2xlQ2FudmFzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICAgICAgdmFyIGZvcmVpZ25PYmplY3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoIG5zLCBcImZvcmVpZ25PYmplY3RcIik7XG4gICAgICAgIGZvcmVpZ25PYmplY3Quc2V0QXR0cmlidXRlKCdjbGFzcycsIFwicGFydGljbGVPYmplY3RcIilcbiAgICAgICAgZm9yZWlnbk9iamVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgY2FudmFzUGFyZW50V2lkdGgpXG4gICAgICAgIGZvcmVpZ25PYmplY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBjYW52YXNQYXJlbnRIZWlnaHQpXG4gICAgICAgIGZvcmVpZ25PYmplY3QuYXBwZW5kQ2hpbGQocGFydGljbGVDYW52YXMpXG4gICAgICAgXG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2cuZGVzaWduJykuYXBwZW5kQ2hpbGQoZm9yZWlnbk9iamVjdClcblxuICAgIH1cblxuICAgIFxuICAgICAgICBcbiAgICAvL0ltYWdlIGNvbWVzIGFwcGFydFxuICAgIHZhciBFeHBsb2RpbmdQYXJ0aWNsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmJlZ2luID0gMFxuXG4gICAgICAgIC8vIFNldCBob3cgbG9uZyB3ZSB3YW50IG91ciBwYXJ0aWNsZSB0byBhbmltYXRlIGZvclxuICAgICAgICB0aGlzLmFuaW1hdGlvbkR1cmF0aW9uID0gMTAwMDsgLy8gaW4gbXNcblxuICAgICAgICAvLyBTZXQgdGhlIHNwZWVkIC8gZGlzdGFuY2UgZm9yIG91ciBwYXJ0aWNsZVxuICAgICAgICB0aGlzLnNwZWVkID0ge1xuICAgICAgICAgICAgeDogd2luZG93LmlubmVyV2lkdGggPCA3NjggPyAtNSArIE1hdGgucmFuZG9tKCkgKiAxMCA6IC0xMCArIE1hdGgucmFuZG9tKCkgKiAyMCxcbiAgICAgICAgICAgIHk6IHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4ID8gLTUgKyBNYXRoLnJhbmRvbSgpICogMTAgOiAtMTAgKyBNYXRoLnJhbmRvbSgpICogMjBcbiAgICAgICAgfTtcbiAgICAgIFxuICAgICAgICAvLyBTaXplIG91ciBwYXJ0aWNsZVxuICAgICAgICB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OCA/IHRoaXMucmFkaXVzID0gMyArIE1hdGgucmFuZG9tKCkgKiAzIDogdGhpcy5yYWRpdXMgPSA0ICsgTWF0aC5yYW5kb20oKSAqIDQ7XG4gICAgICBcbiAgICAgIFxuICAgICAgICAvLyBTZXQgYSBtYXggdGltZSB0byBsaXZlIGZvciBvdXIgcGFydGljbGVcbiAgICAgICAgdGhpcy5saWZlID0gMzAgKyBNYXRoLnJhbmRvbSgpICogMTA7XG4gICAgICAgIHRoaXMucmVtYWluaW5nTGlmZSA9IHRoaXMubGlmZVxuXG4gICAgICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYnkgb3VyIGFuaW1hdGlvbiBsb2dpYyBsYXRlciBvblxuICAgICAgICB0aGlzLmRyYXcgPSBjdHggPT4ge1xuXG4gICAgICAgICAgICBsZXQgcCA9IHRoaXNcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHRoaXMucmVtYWluaW5nTGlmZSA+IDAgJiYgdGhpcy5yYWRpdXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy8gRHJhdyBhIGNpcmNsZSBhdCB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGN0eC5hcmMocC5zdGFydFgsIHAuc3RhcnRZLCBwLnJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcInJnYmEoXCIgKyB0aGlzLnJnYkFycmF5WzBdICsgJywnICsgdGhpcy5yZ2JBcnJheVsxXSArICcsJyArIHRoaXMucmdiQXJyYXlbMl0gKyBcIiwgMSlcIlxuICAgICAgICAgICAgICAgIGN0eC5maWxsKClcbiAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBhcnRpY2xlJ3MgbG9jYXRpb24gYW5kIGxpZmVcbiAgICAgICAgICAgICAgICBwLnJlbWFpbmluZ0xpZmUtLVxuICAgICAgICAgICAgICAgIHAucmFkaXVzIC09IDAuMjVcbiAgICAgICAgICAgICAgICBwLnN0YXJ0WCArPSBwLnNwZWVkLnhcbiAgICAgICAgICAgICAgICBwLnN0YXJ0WSArPSBwLnNwZWVkLnlcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJldHJhY3QgPSAoYmVnaW4sIGZpbmFsZSwgdGltZXN0YW1wKSA9PiB7XG5cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCFyZXRyYWN0U3RhcnQpIHJldHJhY3RTdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgcnVudGltZSA9IHRpbWVzdGFtcCAtIHJldHJhY3RTdGFydFxuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzcyA9IE1hdGgubWluKHJ1bnRpbWUgLyAzMDAwLCAxKVxuICAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBjYW52YXMuc3R5bGUub3BhY2l0eSA9IDEgLSBwcm9ncmVzc1xuICAgICAgICAgICAgICAgIHBhcnRpY2xlQ3R4LmNsZWFyUmVjdCgwLCAwLCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcblxuICAgICAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGJlZ2luLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0ID0gYmVnaW5baV1cbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gZmluYWxlW2ldXG4gICAgICAgICAgICAgICAgXG4gICAgIFxuICAgICAgICAgICAgICAgIHZhciBkaXN0WCA9IE1hdGguYWJzKHN0YXJ0LnN0YXJ0WCAgLSBlbmQueClcbiAgICAgICAgICAgICAgICB2YXIgZGlzdFkgPSBNYXRoLmFicyhzdGFydC5zdGFydFkgLSBlbmQueSlcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL0lmIGVuZCB4IG9yIHkgaXMgZ3JlYXRlciB0aGFuIHggb3IgeSBzdWJ0cmFjdCBlbHNlIGFkZFxuICAgICAgICAgICAgICAgIHN0YXJ0LnggPSBzdGFydC5zdGFydFggPiBlbmQueCA/IHN0YXJ0LnN0YXJ0WCAtIChkaXN0WCAqIHByb2dyZXNzKSA6IHN0YXJ0LnN0YXJ0WCArIChkaXN0WCAqIHByb2dyZXNzKVxuICAgICAgICAgICAgICAgIHN0YXJ0LnkgPSBzdGFydC5zdGFydFkgPiBlbmQueSA/IHN0YXJ0LnN0YXJ0WSAtIChkaXN0WSAqIHByb2dyZXNzKSA6IHN0YXJ0LnN0YXJ0WSArIChkaXN0WSAqIHByb2dyZXNzKVxuICAgICAgICAgICAgICAgIHN0YXJ0LnJhZCA9IHN0YXJ0LmJlZ2luICsgKGVuZC5yYWQgKiBwcm9ncmVzcylcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZUN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHBhcnRpY2xlQ3R4LmFyYyhzdGFydC54LCBzdGFydC55LCBzdGFydC5yYWQsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZUN0eC5maWxsU3R5bGUgPSBcInJnYmEoXCIgKyBzdGFydC5yZ2JBcnJheVswXSArICcsJyArIHN0YXJ0LnJnYkFycmF5WzFdICsgJywnICsgc3RhcnQucmdiQXJyYXlbMl0gKyAnLCcrIHN0YXJ0LnJnYkFycmF5WzNdK1wiKVwiXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBwYXJ0aWNsZUN0eC5maWxsKClcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgIGlmKHByb2dyZXNzID09PSAxICl7XG4gICAgICAgICAgICAvL3JldHVybnMgdGhlIHBob3RvIGJhY2sgaWYgcmFuIGFnYWluXG4gICAgICAgICAgICByZXR1cm4gXG4gICAgICAgICAgfVxuICAgICAgICAgICBcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbih0aW1lc3RhbXApe1xuICAgICAgICAgICAgICAgIHRoaXMucmV0cmFjdChiZWdpbiwgZmluYWxlLCB0aW1lc3RhbXApXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgICAgIH1cbiAgICB9XG5cblxuXG4gICAgdmFyIHBhcnRpY2xlcyA9IFtdO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlUGFydGljbGVBdFBvaW50KHgsIHksIGNvbG9yRGF0YSkge1xuICAgICAgICBsZXQgcGFydGljbGUgPSBuZXcgRXhwbG9kaW5nUGFydGljbGUoKTtcbiAgICAgICAgXG4gICAgICAgIHBhcnRpY2xlLnJnYkFycmF5ID0gY29sb3JEYXRhO1xuICAgICAgICBwYXJ0aWNsZS5zdGFydFggPSB4O1xuICAgICAgICBwYXJ0aWNsZS5zdGFydFkgPSB5O1xuICAgICAgICBwYXJ0aWNsZS5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICBcbiAgICAgICAgcGFydGljbGVzLnB1c2gocGFydGljbGUpO1xuICAgICAgICBsZXQgZW5kID0ge31cbiAgICAgICAgZW5kLnN0YXJ0ID0gMDtcbiAgICAgICAgZW5kLnJhZCA9IHBhcnRpY2xlLnJhZGl1cztcbiAgICAgICAgZW5kLnggPSB4O1xuICAgICAgICBlbmQueSA9IHk7XG4gICAgICAgIGVuZGluZy5wdXNoKGVuZClcbiAgICAgIFxuICAgIH1cblxuICAgIHZhciBvcGFjID0gMTtcbiAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgIGlmKHR5cGVvZiBwYXJ0aWNsZUN0eCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcGFydGljbGVDdHguY2xlYXJSZWN0KDAsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vaW1hZ2UgZmFkZXMgYXMgaXQncyBicmVha2luZyBhcGFydFxuICAgICAgICBjYW52YXMuc3R5bGUub3BhY2l0eSA9IChvcGFjID0gb3BhYyAtIC4wOClcblxuICAgICAgICAvLyBEcmF3IGFsbCBvZiBvdXIgcGFydGljbGVzIGluIHRoZWlyIG5ldyBsb2NhdGlvblxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcGFydGljbGVzLmxlbmd0aDsgaSsrKSB7XG5cbiAgICAgICAgICAgIHBhcnRpY2xlc1tpXS5kcmF3KHBhcnRpY2xlQ3R4KTtcblxuICAgICAgICAgICAgLy8gV2hlbiBwYXJ0aWNsZXMgXG4gICAgICAgICAgICBpZihwYXJ0aWNsZXNbaV0ucmFkaXVzIDwgMCkge1xuICAgICAgICAgICAgICAgIGxldCBwZXJjZW50ID0gKERhdGUubm93KCkgLSBwYXJ0aWNsZXNbaV0uc3RhcnRUaW1lKSAvIHBhcnRpY2xlc1tpXS5hbmltYXRpb25EdXJhdGlvbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZXQgZHVyID0gc2l6aW5nKCdkdXInKVxuICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYocGVyY2VudCA+IGR1cikge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFydGljbGUgPSBuZXcgRXhwbG9kaW5nUGFydGljbGUoKTtcblxuICAgICAgICAgICAgICAgICAgICBwYXJ0aWNsZS5yZXRyYWN0KHBhcnRpY2xlcywgZW5kaW5nKVxuICAgIFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlKTtcbiAgICB9XG5cbiAgICB2YXIgY2xlYXJEYXRhID0gZnVuY3Rpb24oKXtcbiAgICAgICAgcmV0cmFjdFN0YXJ0ID0gbnVsbFxuICAgICAgICBjYW52YXMucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpXG4gICAgICAgIHBhcnRpY2xlQ3R4LmNsZWFyUmVjdCgwLCAwLCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgZW5kaW5nID0gW11cbiAgICAgICAgcGFydGljbGVzID0gW11cbiAgICB9XG5cbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgICAgICAgdmFyIHdpZHRoID0gc2l6aW5nKCdpbWcnKVxuICAgICAgICB2YXIgaGVpZ2h0ID0gd2lkdGg7XG4gICAgICAgIGltZ0NhbnZhcyh3aWR0aCxoZWlnaHQsdGhpcyxydW5FdmVudHMpXG4gICAgICAgIFxuICAgIH1cbiAgICBpbWcuc3JjID0gJ2ltYWdlcy9kZXNpZ24taW1nLnBuZydcblxuICAgIGZ1bmN0aW9uIHJ1bkV2ZW50cyhpbWdDYW52YXMpe1xuICAgICAgICB2YXIgZm9yZWlnbk9iamVjdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kZXNpZ24gLml0ZW0tY2FudmFzJylcbiAgICAgXG4gICAgICAgIGxldCBpbWFnZUxlZnQgPSBwYXJzZUludChmb3JlaWduT2JqZWN0LmdldEF0dHJpYnV0ZSgneCcpICk7XG4gICAgICAgIGxldCBpbWFnZVRvcCA9IHBhcnNlSW50KGZvcmVpZ25PYmplY3QuZ2V0QXR0cmlidXRlKCd5JykgKTtcbiAgICAgICAgLy8gbGV0IHJlZHVjdGlvbkZhY3RvciA9IHdpbmRvdy53aWR0aCA8PSA0MDAgPyAxNSA6IE1hdGgucm91bmQoaW1nQ2FudmFzLndpZHRoIC8gMTUpXG4gICAgICAgIGlmKHdpbmRvdy5pbm5lcldpZHRoIDwgNjAwKVxuICAgICAgICAgICAgdmFyIHJlZHVjdGlvbkZhY3RvciA9IDE1XG4gICAgICAgIGlmKHdpbmRvdy5pbm5lcldpZHRoID49NjAwKSBcbiAgICAgICAgICAgIHZhciByZWR1Y3Rpb25GYWN0b3IgPSAyMlxuICAgICAgICBpZih3aW5kb3cuaW5uZXJXaWR0aCA+PSAxMjAwKVxuICAgICAgICAgICAgdmFyIHJlZHVjdGlvbkZhY3RvciA9IDMzXG4gICAgICAgIFxuICAgICAgICAvL1JlbW92ZXMgY2FudmFzIHdpdGggcGFydGljbGVzIG1hZGUgZnJvbSB3aGVuIGNsb3Npbmcgc3ZnIHBhZ2VcbiAgICAgICAgXygnY2xvc2UtYnRuJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbGVhckRhdGEpXG5cbiAgICAgICAgaW1nQ2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICBpZihlLnRhcmdldC5zdHlsZS5vcGFjaXR5ICl7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckRhdGEoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIFxuICAgICAgICAgICAgLy93aWR0aCBmaXJzdCBvbmUgcGl4ZWwsIHRoZW4gYWxsIG9mIGhlaWdodCBwaXhlbHMsIHdpZHRoIGFub3RoZXIgcGl4ZWwgdGhlbiBhbGwgb2YgaGVpZ2h0IHBpeGVscyBcbiAgICAgICAgICAgIGxldCByZ2JhRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCkuZGF0YTtcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IobGV0IHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKXtcbiAgICAgICAgICAgICAgICBmb3IobGV0IHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7IHkrKyl7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKGNvdW50ICUgcmVkdWN0aW9uRmFjdG9yID09PSAwKSB7XG4gICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSAoeSAqIHRoaXMud2lkdGggKyB4KSAqIDQ7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZ2JhQ29sb3JBcnIgPSByZ2JhRGF0YS5zbGljZShpbmRleCwgaW5kZXggKyA0KTtcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbGV0IGdsb2JhbFggPSBpbWFnZUxlZnQgKyB4O1xuICAgICAgICAgICAgICAgICAgICBsZXQgZ2xvYmFsWSA9IGltYWdlVG9wICsgeTtcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUGFydGljbGVBdFBvaW50KGdsb2JhbFgsIGdsb2JhbFksIHJnYmFDb2xvckFycilcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvdW50KytcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGUoKVxuICAgICAgICB9KTtcbiAgICB9XG59XG5JbWFnZVNoYXR0ZXIoKTtcblxuXG5cbmZ1bmN0aW9uIFN0YXJyeU5pZ2h0KCl7XG4gICAgICAgXG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFycnlOaWdodCcpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgZGF0YSA9IFtdXG4gICAgdmFyIHRyYWlsRGF0YSA9IFtdXG4gICAgdmFyIHJnYiA9ICB0cmFpbERhdGEubGVuZ3RoID4gMSAmJiAxNTAgLyB0cmFpbERhdGEubGVuZ3RoXG4gICAgdmFyIGogPSAwO1xuICAgIHZhciBob3VzZVdpZHRoID0gd2luZG93LmlubmVyV2lkdGggPCA3NjggPyAzODAgOiA2MDA7XG4gICAgdmFyIGhvdXNlSGVpZ2h0ID0gbmV3U2l6ZSgnd2lkdGgnLCBob3VzZVdpZHRoKS5oZWlnaHQ7XG4gICAgdGhpcy53aWR0aCA9IGNhbnZhcy53aWR0aCA9IF8oJ3N2Zy1wYWdlJykuZ2V0QXR0cmlidXRlKCd3aWR0aCcpO1xuICAgIHRoaXMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCA9IF8oJ3N2Zy1wYWdlJykuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKTtcbiAgICB0aGlzLnRvZ2dsZSA9IHRydWU7XG5cbiAgICB0aGlzLmltYWdlcyA9IFtdXG5cbiAgICAvL01lbiBEYXRhXG4gICAgdmFyIG1lbkRhdGEgPSB7XG4gICAgICAgIGhlYWRBcmM6IHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4ID8gNCA6IDYsXG4gICAgICAgIHN0ZXBEb3duOiB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OCA/IDEyIDogMTcsXG4gICAgICAgIHJvdGF0ZWRQb3M6IDAsXG4gICAgICAgIHJvdGF0ZURlZ3JlZTogMTQsXG4gICAgICAgIGo6IDAsIC8vRWFjaCBwb2ludCBvZiBhbmltYXRpb24sIHdhbGssIHN0YW5kIHN0aWxsLCByb3RhdGUgLGZhbGxpbmdcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGJlZ2luOiAwLFxuICAgICAgICBsYXN0UG9zWDogOTAsXG4gICAgICAgIGxhc3RQb3NZOiB1bmRlZmluZWQsXG4gICAgICAgIGFyY1N0YXJ0WDogd2luZG93LmlubmVyV2lkdGggPCA3NjggPyA3IDogMTAsXG4gICAgICAgIGFyY1N0YXJ0WTogNVxuICAgIH1cblxuICAgIC8vSG91c2UgYW5pbWF0aW9uIERhdGFcbiAgICB0aGlzLmhvdXNlID0ge1xuICAgICAgICBob3VzZUltZzogdW5kZWZpbmVkLFxuICAgICAgICB0b2dnbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgY3VycmVudFk6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIHJpZ2h0OiB0aGlzLndpZHRoIC0gaG91c2VXaWR0aCxcbiAgICAgICAgYm90dG9tOiB0aGlzLmhlaWdodCAtIGhvdXNlSGVpZ2h0LFxuICAgICAgICBzdGFydFk6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ib3R0b20gKyBob3VzZVdpZHRoIC8gMi40XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0WDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0XG4gICAgICAgIH0sXG4gICAgICAgIGJlZ2luOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgbWVuRGF0YS5sYXN0UG9zWSA9IChob3VzZUhlaWdodCAvIDIuMjQpIC0gc3RhcnJ5TmlnaHQuaW1hZ2VzWzBdLmhlaWdodFxuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLmhvdXNlSW1nLCB0aGlzLnN0YXJ0WCgpLCB0aGlzLnN0YXJ0WSgpLCBob3VzZVdpZHRoLCBob3VzZUhlaWdodCApXG4gICAgICAgIH0sXG4gICAgICAgIHJpc2U6IHRoaXMuaGVpZ2h0IC8gMixcbiAgICAgICAgbW92ZUxlZnQ6IHdpbmRvdy5pbm5lcldpZHRoIDwgNTAwID8gdGhpcy53aWR0aCAvIDIwIDogdGhpcy53aWR0aCAvIDhcbiAgICB9XG5cbiAgICAvL1N0YXIgVHJhaWwgRGF0YVxuICAgIHZhciBsYXN0UG9zaXRpb24gPSBmdW5jdGlvbih4UG9zLCB5UG9zLCByYWRpdXMsIGFscGhhKXtcbiAgICAgICAgdHJhaWxEYXRhLnB1c2goe1xuICAgICAgICAgICAgeDogeFBvcyxcbiAgICAgICAgICAgIHk6IHlQb3MsXG4gICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICAgIGFscGhhOiBhbHBoYVxuICAgICAgICB9KVxuICAgICAgICBpZih0cmFpbERhdGEubGVuZ3RoID4gMjUpIHRyYWlsRGF0YS5zaGlmdCgpXG4gICAgfVxuXG4gICAgdGhpcy5yYW5kb21NYXggPSBmdW5jdGlvbihtaW4sIG1heCl7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKCBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbikgKyBtaW4gKVxuICAgIH1cblxuICAgIC8vQWRkcyBkYXRhIGZvciBTaG9vdGluZyBzdGFyXG4gICAgdGhpcy5hZGREYXRhID0gZnVuY3Rpb24oKXtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IDg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgbWVhc3VyZW1lbnRzID0ge1xuICAgICAgICAgICAgICAgIC8vIFN0YXJ0cyByYW5kb21seSBvbiB0aGUgeCBheGlzXG4gICAgICAgICAgICAgICAgZGVsYXk6IGkgPT09IDAgPyAwIDogdGhpcy5yYW5kb21NYXgoMSwgMiksXG4gICAgICAgICAgICAgICAgeDogdGhpcy5yYW5kb21NYXgoMCwgdGhpcy53aWR0aC8yKSxcbiAgICAgICAgICAgICAgICB5OiB0aGlzLnJhbmRvbU1heCgyMDAsIHRoaXMuaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICByYWRpdXM6IHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4ID8gdGhpcy5yYW5kb21NYXgoNSwgMTMpIDogdGhpcy5yYW5kb21NYXgoOCwgMTYpLFxuICAgICAgICAgICAgICAgIGRpc3RhbmNlOiB0aGlzLndpZHRoICsgMTAwLFxuICAgICAgICAgICAgICAgIGdsb2JBbHBoYTogMSxcbiAgICAgICAgICAgICAgICBvcGFjOiAxLFxuICAgICAgICAgICAgICAgIGVuZFBvczogdGhpcy5yYW5kb21NYXgoMTAwLCB0aGlzLndpZHRoKSxcbiAgICAgICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgICAgICB0aW1lOiAwLFxuICAgICAgICAgICAgICAgIGV4cGxvZGVTdGFydDogMCxcbiAgICAgICAgICAgICAgICBleHBsb2RlU2l6ZTogd2luZG93LmlubmVyV2lkdGggPCA3NjggPyAyMCA6IDM1XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhLnB1c2gobWVhc3VyZW1lbnRzKVxuICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH0uYmluZCh0aGlzKVxuXG4gICAgLy9XaGVuIHByb3RvdHlwZS50b2dnbGUgPSBmYWxzZSB0aGlzIGF1dG9tYXRpY2FsbHkgZ2V0cyByYW4gdG8gYmUgYWJsZSB0byBydW4gYW5pbWF0aW9uIGFnYWluXG4gICAgdGhpcy5yZXN0b3JlRGF0YSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIGRhdGEgPSBbXVxuICAgICAgICB0cmFpbERhdGEgPSBbXVxuICAgICAgICBqID0gMFxuICAgICAgICB0aGlzLmFkZERhdGEoKVxuICAgICAgICBtZW5EYXRhLmJlZ2luID0gbnVsbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdIb3VzZShpbWFnZSx0aW1lc3RhbXApe1xuICAgICAgICBpZighaW1hZ2Uuc3RhcnQpIGltYWdlLnN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgIHZhciBydW50aW1lID0gdGltZXN0YW1wIC0gaW1hZ2Uuc3RhcnRcbiAgICAgICAgdmFyIHByb2dyZXNzID0gcnVudGltZSAvIDIwMDBcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBpbWFnZS5yaXNlICogcHJvZ3Jlc3NcbiAgICAgICAgXG4gICAgICAgIC8vRmxvYXRpbmcgaW4gcGxhY2VcbiAgICAgICAgaWYoaW1hZ2UuY3VycmVudFkpe1xuXG4gICAgICAgICAgICBpbWFnZS50b2dnbGUgPyBpbWFnZS54ID0gaW1hZ2UuY3VycmVudFggLSBkaXN0YW5jZSAgOiBpbWFnZS54ID0gaW1hZ2UuY3VycmVudFggKyBkaXN0YW5jZVxuICAgICAgICAgICAgaW1hZ2UudG9nZ2xlID8gaW1hZ2UueSA9IGltYWdlLmN1cnJlbnRZICsgZGlzdGFuY2UgIDogaW1hZ2UueSA9IGltYWdlLmN1cnJlbnRZIC0gZGlzdGFuY2VcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoZGlzdGFuY2UgPj0gaW1hZ2UucmlzZSl7XG4gICAgICAgICAgICAvL01ha2VzIGN1cnJlbnRZIHRydWUgYW5kIHVwZGF0ZXMgcG9zdGlvbiBvZiB0aGUgaW1hZ2VcbiAgICAgICAgICAgIGltYWdlLmN1cnJlbnRZID0gaW1hZ2UueVxuICAgICAgICAgICAgaW1hZ2UuY3VycmVudFggPSBpbWFnZS54XG4gICAgICAgICAgICBpbWFnZS50b2dnbGUgPyBpbWFnZS50b2dnbGUgPSBmYWxzZSA6IGltYWdlLnRvZ2dsZSA9IHRydWVcbiAgICAgICAgICAgIGltYWdlLnN0YXJ0ID0gMFxuICAgICAgICAgICAgaW1hZ2UucmlzZSA9IDUwXG5cbiAgICAgICAgfVxuICAgICAgICAvL0VuZHMgdGhlIGZpcnN0IHJpc2Ugb2YgdGhlIGltYWdlXG4gICAgICAgIGlmKCFpbWFnZS5jdXJyZW50WSkge1xuICAgICAgICAgICAgaW1hZ2UueCA9IGltYWdlLnN0YXJ0WCgpIC0gKGltYWdlLm1vdmVMZWZ0ICogcHJvZ3Jlc3MpXG4gICAgICAgICAgICBpbWFnZS55ID0gaW1hZ2Uuc3RhcnRZKCkgLSAoaW1hZ2UucmlzZSAqIHByb2dyZXNzKVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZS5ob3VzZUltZywgaW1hZ2UueCwgaW1hZ2UueSwgaG91c2VXaWR0aCwgaG91c2VIZWlnaHQgKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdTdGFycyhjaXIpe1xuICAgICAgICBjdHguc2F2ZSgpXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IGNpci5hbHBoYVxuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyhjaXIueFBvcywgY2lyLnlQb3MsIGNpci5yYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDI1NSwgMjU1LCA3MywgJyArIGNpci5vcGFjaXR5ICsgJyknXG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKClcbiAgICAgICAgbGFzdFBvc2l0aW9uKGNpci54UG9zLCBjaXIueVBvcywgY2lyLnJhZGl1cywgY2lyLmFscGhhKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRyYXdUcmFpbCh0cmFpbCl7XG4gICAgICAgIGN0eC5zYXZlKClcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gMC4yXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LmFyYyh0cmFpbC54LCB0cmFpbC55LCB0cmFpbC5yYWQsIDAsIDIgKiBNYXRoLlBJLCB0cnVlKTtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDIzOCwnK3RyYWlsLmNvbG9yKycsIDYsICcgKyB0cmFpbC5mYWRlICsgJyknXG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKClcbiAgICB9XG4gICAgZnVuY3Rpb24gZHJhd0V4cGxvc2lvbihjaXJjbGUsIHRpbWVzdGFtcCl7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgIGlmKCFjaXJjbGUuZXhwbG9kZVN0YXJ0KSBjaXJjbGUuZXhwbG9kZVN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgIHZhciBydW50aW1lID0gdGltZXN0YW1wIC0gY2lyY2xlLmV4cGxvZGVTdGFydFxuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBydW50aW1lIC8gNDAwXG4gICAgICAgIHZhciBlYXNlID0gZWFzZU91dChwcm9ncmVzcylcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpXG4gICAgICAgIGN0eC5hcmMoY2lyY2xlLnhQb3MsIGNpcmNsZS55UG9zLCAwICsgKGNpcmNsZS5leHBsb2RlU2l6ZSAqIGVhc2UpLCAwLCAyICogTWF0aC5QSSwgdHJ1ZSlcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDI0OSwgMjU1LCAwLCAnICsgKDEgLSAoLjkgKiBwcm9ncmVzcykgKSArICcpJ1xuICAgICAgICBjdHguZmlsbCgpXG4gICAgICAgICAgICBcbiAgICB9XG4gICAgZnVuY3Rpb24gZHJhd01lbihtZW4pe1xuXG4gICAgICAgIGlmKG1lbkRhdGEuaiA+PSA0ICYmIG1lbkRhdGEuaiA8PSA1KXtcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUobWVuLnRyYW5zbGF0ZVgsIG1lbi50cmFuc2xhdGVZKTtcbiAgICAgICAgICAgIGN0eC5yb3RhdGUobWVuLnJvdGF0ZSAqIE1hdGguUEkgLyAxODApO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShtZW4uaW1nLCAtbWVuLndpZHRoLzIsIC1tZW4uaGVpZ2h0LCBtZW4ud2lkdGgsIG1lbi5oZWlnaHQpXG4gICAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKVxuICAgICAgICB9ZWxzZXsgXG4gICAgICAgICAgICBjdHguc2F2ZSgpXG4gICAgICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBtZW4ub3BhY1xuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgY3R4LmFyYyhtZW4uYXJjWCwgbWVuLmFyY1ksIG1lbi5hcmNSYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBcIiMwMDBcIlxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UobWVuLmltZywgbWVuLngsIG1lbi55LCBtZW4ud2lkdGgsIG1lbi5oZWlnaHQpXG4gICAgICAgICAgICBjdHgucmVzdG9yZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZHJhdyA9IGZ1bmN0aW9uKHRpbWVzdGFtcCl7XG4gICAgICAgIGlmKCFTdGFycnlOaWdodC5wcm90b3R5cGUudG9nZ2xlKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc3RvcmVEYXRhKClcbiAgICAgICAgfSBcblxuICAgICAgICAvL0hvdXNlXG4gICAgICAgIHZhciBpbWFnZSA9IHRoaXMuaG91c2VcblxuICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KVxuICAgICAgICBcbiAgICAgICAgLy9NZW4gcnVubmluZyBzdGFydCAsIFN0YXJzIHN0YXJ0IGFmdGVyIGhvdXNlIGdldHMgdG8gdG9wLiBcbiAgICAgICAgaWYoaW1hZ2UuY3VycmVudFkpe1xuXG4gICAgICAgICAgICAvLyoqICBTVEFSVCBPRiBTVEFSUyAgKiovXG5cbiAgICAgICAgICAgIC8vIERyYXdzIHRoZSB0cmFpbCBvcGFjaXR5ICBcbiAgICAgICAgICAgIGlmKG1lbkRhdGEuaiA+PSAxKXtcbiAgICAgICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgdHJhaWxEYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWlsID0gdHJhaWxEYXRhW2ldXG4gICAgICAgICAgICAgICAgICAgIHZhciBmYWRlU2l6ZSA9ICBpIC8gdHJhaWxEYXRhLmxlbmd0aFxuXG4gICAgICAgICAgICAgICAgICAgIC8vVHJhaWwgdGFwZXJzIGFzIGl0IGdvZXMuXG4gICAgICAgICAgICAgICAgICAgIHZhciByYWRpdXNUYXBlciA9ICAgKHRyYWlsLnJhZGl1cy0yKSAvIHRyYWlsRGF0YS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgdHJhaWwuY29sb3IgPSAyNDAgLSAoaStqKVxuICAgICAgICAgICAgICAgICAgICB0cmFpbC5mYWRlID0gaSAvIHRyYWlsRGF0YS5sZW5ndGhcblxuICAgICAgICAgICAgICAgICAgICAvL1RhcGVycyBkb3duIHRoZSByYWlkdXMgb2YgdGhlIHRyYWlsXG4gICAgICAgICAgICAgICAgICAgIHRyYWlsLnJhZCA9ICh0cmFpbC5yYWRpdXMgPSB0cmFpbC5yYWRpdXMgLSByYWRpdXNUYXBlciApXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYWlsLnJhZCA9IHRyYWlsLnJhZGl1c1xuICAgICAgICAgICAgICAgICAgICBkcmF3VHJhaWwodHJhaWwpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy9EcmF3cyBzdGFyc1xuICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNpcmNsZSA9IGRhdGFbaV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiggaiA+PSBpICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFjaXJjbGUuc3RhcnQpIGNpcmNsZS5zdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bnRpbWUgPSB0aW1lc3RhbXAgLSBjaXJjbGUuc3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBwcm9ncmVzcyA9IHJ1bnRpbWUgLyAyMDAwXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWFzZSA9IGVhc2VPdXQocHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUudGltZSA9IChjaXJjbGUuZGVsYXkgLSBlYXNlKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0lmIHRoZSBjdXJyZW50IGNpcmNsZSBkZWxheSA9IHByb2dyZXNzIGRyYXdzIG5leHQgY2lyY2xlLCAocmFuZG9tIGRyYXdpbmcgbG9vaylcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGNpcmNsZS50aW1lIDw9IDApe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jdXJyZW50IGNpcmNsZSBzZXQgdG8gdW5kZWZpbmVkIGtlZXAgZnJvbSBydW5uaW5nIGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lyY2xlLmRlbGF5ID0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaisrXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUuYWxwaGEgPSBjaXJjbGUuZ2xvYkFscGhhIC0gKDEqcHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUub3BhY2l0eSA9IGNpcmNsZS5vcGFjIC0gICguOSpwcm9ncmVzcykgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaXJjbGUuZHVyYXRpb24gPSBlYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKGolMyAhPT0wICYmIG1lbkRhdGEuaiA+PSAxKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaXJjbGUueFBvcyA9IGNpcmNsZS54ICsgKGNpcmNsZS5lbmRQb3MgKiBlYXNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS55UG9zID0gMCArIChjaXJjbGUueSAqIGVhc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZS54UG9zID0gY2lyY2xlLnggKyAoY2lyY2xlLmVuZFBvcyAqIGVhc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2lyY2xlLnlQb3MgPSAwICsgKGNpcmNsZS55ICogcHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3ZlcidcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmF3U3RhcnMoY2lyY2xlKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvL0V4cGxvc2lvbiBzdGFydFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoY2lyY2xlLnhQb3MgPiBpbWFnZS54ICYmIGNpcmNsZS55UG9zID4gaW1hZ2UueSl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmF3RXhwbG9zaW9uKGNpcmNsZSwgdGltZXN0YW1wKVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaiA9PT0gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWlsRGF0YSA9IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGREYXRhKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vKiogIFNUQVJUIE9GIE1FTiAgKiovXG4gICAgICAgICAgICB2YXIgbWVuTGVuZ3RoID0gc3RhcnJ5TmlnaHQuaW1hZ2VzLmxlbmd0aC0xXG5cbiAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBtZW5MZW5ndGg7IGkrKyl7IFxuICAgICAgICAgICAgICAgIHZhciBtZW4gPSBzdGFycnlOaWdodC5pbWFnZXNbaV1cbiAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKCFtZW5EYXRhLmJlZ2luKSBtZW5EYXRhLmJlZ2luID0gdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgdmFyIHJ1bnRpbWUgPSB0aW1lc3RhbXAgLSBtZW5EYXRhLmJlZ2luXG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gTWF0aC5taW4ocnVudGltZSAvIDIwMDAsIDEpXG5cbiAgICAgICAgICAgICAgICAvL0ZpcnN0IHdhbGsgb3V0XG4gICAgICAgICAgICAgICAgaWYobWVuRGF0YS5qID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuc3RhcnQgPSBwYXJzZUludCggKCBwcm9ncmVzcyAqIDE1KS50b0ZpeGVkKDApICk7XG4gICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuZGlzdGFuY2VYID0gd2luZG93LmlubmVyV2lkdGggPCA3NjggPyA5NSA6IDIwNVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy9TZWNvbmQgV2FsayBzdGFuZHMgc3RpbGxcbiAgICAgICAgICAgICAgICBpZihtZW5EYXRhLmogPT09IDEpe1xuICAgICAgICAgICAgICAgICAgICAvL1N0YXJ0cyBhbmQgZW5kcyB3aXRoIGxhc3QgZHVkZVxuICAgICAgICAgICAgICAgICAgICBtZW5EYXRhLnN0YXJ0ID0gMTVcbiAgICAgICAgICAgICAgICAgICAgLy8gS2VlcGluZyBjb3VudCBhdCBsYXN0IG1hbiBpbnN0ZWFkIG9mIGNvdW50aW5nIHRocm91Z2ggdGhlbSB0byBhbmltYXRlXG4gICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuZGlzdGFuY2VYID0gMFxuICAgICAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgICAgICAvL1RoaXJkIHdhbGsgZG93biBhbmQgdG8gdGhlIGVuZFxuICAgICAgICAgICAgICAgIGlmKG1lbkRhdGEuaiA9PT0gMil7XG4gICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuc3RhcnQgPSBwYXJzZUludCggKCBwcm9ncmVzcyAqIDE1KS50b0ZpeGVkKDApICk7XG4gICAgICAgICAgICAgICAgICAgIG1lbi53YWxrRG93biA9IE1hdGgubWluKCAoIHByb2dyZXNzICogNiksIDEgKSAqIG1lbkRhdGEuc3RlcERvd25cbiAgICAgICAgICAgICAgICAgICAgLy8gbWVuRGF0YS5kaXN0YW5jZVggPSAyNTBcbiAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5kaXN0YW5jZVggPSB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OCA/IDE1OSA6IDI1MFxuICAgICAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgICAgICAvL0xvb2tzIGRvd25cbiAgICAgICAgICAgICAgICBpZihtZW5EYXRhLmogPT09IDMpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgaGVhZEl0ZXJhdGUgPSBNYXRoLm1pbihydW50aW1lIC8gMTAwMCwgMSlcblxuICAgICAgICAgICAgICAgICAgICAvL3VwZGF0ZXMgbWVuLndhbGtkb3duIHRoYXQgZ2V0cyByYW4gYmVmb3JlIGJhY2sgdG8gMFxuICAgICAgICAgICAgICAgICAgICBtZW4ud2Fsa0Rvd24gPSAwXG4gICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuc3RhcnQgPSAxNlxuICAgICAgICAgICAgICAgICAgICBtZW5EYXRhLmRpc3RhbmNlWCA9IDBcbiAgICAgICAgICAgICAgICAgICAgbWVuLmFyY1ggPSAoaW1hZ2UueCArICggbWVuRGF0YS5sYXN0UG9zWCArIChtZW4ud2lkdGgvMisyKSApKSArICggbWVuRGF0YS5hcmNTdGFydFggKiBoZWFkSXRlcmF0ZSApXG4gICAgICAgICAgICAgICAgICAgIG1lbi5hcmNZID0gaW1hZ2UueSArICggbWVuRGF0YS5sYXN0UG9zWSsgNCkgKyAoIG1lbkRhdGEuYXJjU3RhcnRZICogaGVhZEl0ZXJhdGUgKVxuICAgICAgICAgICAgICAgICAgICBtZW4uYXJjUmFkaXVzID0gbWVuRGF0YS5oZWFkQXJjIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL1JvdGF0ZXMgYmFjayBhbmQgZm9ydGhcbiAgICAgICAgICAgICAgICBpZihtZW5EYXRhLmogPT09IDQpe1xuICAgICAgICAgICAgICAgICAgICAvLzJuZCByb3RhdGVkIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdSb3RhdGVkUG9zID0gbWVuRGF0YS5yb3RhdGVkUG9zIC0gKCAobWVuRGF0YS5yb3RhdGVEZWdyZWUgKiBpdGVyYXRlICkgLSBtZW5EYXRhLnJvdGF0ZWRQb3MpXG4gICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuc3RhcnQgPSAxNFxuXG4gICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuZGlzdGFuY2VYID0gMFxuXG4gICAgICAgICAgICAgICAgICAgIG1lbi50cmFuc2xhdGVYID0gaW1hZ2UueCArIChtZW5EYXRhLmxhc3RQb3NYICsgbWVuLndpZHRoLzEuOClcbiAgICAgICAgICAgICAgICAgICAgbWVuLnRyYW5zbGF0ZVkgPSBpbWFnZS55ICsgKG1lbkRhdGEubGFzdFBvc1kgKyBtZW4uaGVpZ2h0KVxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlcmF0ZSA9IE1hdGgubWluKCAoIHByb2dyZXNzICogMyksIDMgKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYobWVuRGF0YS5yb3RhdGVkUG9zIDw9IG1lbkRhdGEucm90YXRlRGVncmVlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbkRhdGEucm90YXRlZFBvcyA9IChtZW5EYXRhLnJvdGF0ZURlZ3JlZSAqIGl0ZXJhdGUpIFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVuLnJvdGF0ZSAgPSAgbWVuRGF0YS5yb3RhdGVkUG9zXG5cbiAgICAgICAgICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9Sb3RhdGUgYmFjayBhbmQgZm9ydGhcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5ld1JvdGF0ZWRQb3MgPj0gMCkgbWVuLnJvdGF0ZSA9IG5ld1JvdGF0ZWRQb3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5ld1JvdGF0ZWRQb3MgPD0gMCkgbWVuLnJvdGF0ZSA9IC1uZXdSb3RhdGVkUG9zO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlcyByb2F0ZWRQb3MgZm9yIG1lbmRhdGEuanMgPSA1IHRvIGJlIHVzZWQgYmVsb3dcbiAgICAgICAgICAgICAgICAgICAgaWYocHJvZ3Jlc3MgPT09IDEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVuLmFyY1JhZGl1cyA9IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbkRhdGEucm9hdGVkUG9zID0gbWVuLnJvdGF0ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vRmFsbHMgRG93blxuICAgICAgICAgICAgICAgIGlmKG1lbkRhdGEuaiA9PT0gNSl7XG4gICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuc3RhcnQgPSBwYXJzZUludCggKCBwcm9ncmVzcyAqIDEwKS50b0ZpeGVkKDApICk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWVuLnRyYW5zbGF0ZVggPSBpbWFnZS54ICsgKG1lbkRhdGEubGFzdFBvc1ggKyBtZW4ud2lkdGggLyAyKSArICggKHRoaXMud2lkdGggLyA2ICkgKiBwcm9ncmVzcyApXG4gICAgICAgICAgICAgICAgICAgIG1lbi50cmFuc2xhdGVZID0gaW1hZ2UueSArIChtZW5EYXRhLmxhc3RQb3NZICsgbWVuLmhlaWdodCkgICsgKCAodGhpcy5oZWlnaHQgLyAyKSAqIHByb2dyZXNzIClcbiAgICAgICAgICAgICAgICAgICAgbWVuLnJvdGF0ZSA9IG1lbkRhdGEucm9hdGVkUG9zICsgKDE4MCAqIHByb2dyZXNzKVxuICAgICAgICAgICAgICAgICAgICBtZW5EYXRhLmRpc3RhbmNlWCA9IDBcbiAgICAgICAgICAgICAgICAgICAgaWYocHJvZ3Jlc3MgPT09IDEpIG1lbi5vcGFjaXR5ID0gMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZihtZW5EYXRhLmogPT09IDYpe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbWVuLm9wYWMgPSBtZW4ub3BhY2l0eSArICgxICogcHJvZ3Jlc3MpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKG1lbi5zdGFydFBvcyA9PT0gbWVuRGF0YS5zdGFydCl7IFxuXG4gICAgICAgICAgICAgICAgICAgIC8vQ29uc3RhbmF0bHkgdXBkYXRlcyBtZW4gbG9jYXRpb24gb24gdGhlIEhvdXNlXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0WCA9IG1lbkRhdGEubGFzdFBvc1ggKyAoIG1lbkRhdGEuZGlzdGFuY2VYICogcHJvZ3Jlc3MgKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RZID0gbWVuRGF0YS5sYXN0UG9zWSArICggbWVuLndhbGtEb3duIHx8IDAgKVxuXG4gICAgICAgICAgICAgICAgICAgIG1lbi54ID0gaW1hZ2UueCArIChtZW5EYXRhLmxhc3RQb3NYICsgKCBtZW5EYXRhLmRpc3RhbmNlWCAqIHByb2dyZXNzKSApXG4gICAgICAgICAgICAgICAgICAgIG1lbi55ID0gaW1hZ2UueSAgKyAobWVuRGF0YS5sYXN0UG9zWSArIChtZW4ud2Fsa0Rvd24gfHwgMCkgKVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBkcmF3TWVuKG1lbilcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZihwcm9ncmVzcyA8IDEpe1xuXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL1Jlc2V0cyBvciB1cGRhdGVzIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5sYXN0UG9zWCA9IGxhc3RYXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW5EYXRhLmxhc3RQb3NZID0gbGFzdFlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lbkRhdGEuaisrXG4gICAgICAgICAgICAgICAgICAgICAgICBtZW5EYXRhLmJlZ2luID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVuRGF0YS5zdGFydD0wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRyYXdIb3VzZShpbWFnZSx0aW1lc3RhbXApXG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXcpXG5cbiAgICB9LmJpbmQodGhpcyk7XG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuYW5pbWF0aW9ucyAuc3RhcnQtY2FudmFzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuXG4gICAgICAgIFN0YXJyeU5pZ2h0LnByb3RvdHlwZS50b2dnbGUgPSB0cnVlXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3KVxuXG4gICAgfS5iaW5kKHRoaXMpKVxuXG4gICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5hbmltYXRpb25zIC5zdG9wLWNhbnZhcycpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKXtcblxuICAgICAgICBTdGFycnlOaWdodC5wcm90b3R5cGUudG9nZ2xlID0gZmFsc2VcbiAgICB9KVxufVxuXG5TdGFycnlOaWdodC5wcm90b3R5cGUubG9hZEltYWdlcyA9IGZ1bmN0aW9uKCl7XG4gICAgdmFyIGhlaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4ID8gNjAgOiA4MFxuICAgIHZhciB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIDwgNzY4ID8gNDggOiA2NFxuICAgIHZhciAkdGhpcyA9IHRoaXNcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBpbWFnZXMgPSBbXVxuICAgIHZhciBleHQgPSBpc0ZpcmVmb3ggPyBcInBuZ1wiIDogXCJzdmdcIjtcbiBcbiAgICB2YXIgbWVuID0gWyAgICAgICAgIFxuICAgICAgICB7c3JjOiBcImltYWdlcy9tZW4vemVyby5cIitleHQsIGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGh9LFxuICAgICAgICB7c3JjOiBcImltYWdlcy9tZW4vb25lLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi90d28uXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL3RocmVlLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi9mb3VyLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi9maXZlLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi9zaXguXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL3NldmVuLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi9laWdodC5cIitleHQsIGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGh9LFxuICAgICAgICB7c3JjOiBcImltYWdlcy9tZW4vbmluZS5cIitleHQsIGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGh9LFxuICAgICAgICB7c3JjOiBcImltYWdlcy9tZW4vdGVuLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi9lbGV2ZW4uXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL3R3ZWx2ZS5cIitleHQsIGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGh9LFxuICAgICAgICB7c3JjOiBcImltYWdlcy9tZW4vdGhpcnRlZW4uXCIrZXh0LCBoZWlnaHQ6IGhlaWdodCwgd2lkdGg6IHdpZHRofSxcbiAgICAgICAge3NyYzogXCJpbWFnZXMvbWVuL2ZvdXJ0ZWVuLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi9maWZ0ZWVuLlwiK2V4dCwgaGVpZ2h0OiBoZWlnaHQsIHdpZHRoOiB3aWR0aH0sXG4gICAgICAgIHtzcmM6IFwiaW1hZ2VzL21lbi9oZWFkbGVzcy5cIitleHQsIGhlaWdodDogaGVpZ2h0LCB3aWR0aDogd2lkdGh9LFxuICAgICAgICB7c3JjOiBcImltYWdlcy9tZW4vaG91c2UtZmxvYXRpbmcuXCIrZXh0fVxuICAgIF07XG5cbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgbWVuLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgXG4gICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgXG4gICAgICAgIHRyeXtcbiAgICAgICAgICAgIHRocm93IGlcbiAgICAgICAgfWNhdGNoKGkpe1xuICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICBcbiAgICAgICAgICAgICAgICBpbWFnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGltZzogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBtZW5baV0uaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogbWVuW2ldLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBzdGFydDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3M6IGlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZigrK2NvdW50ID09PSBtZW4ubGVuZ3RoKXtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vU29ydHMgdGhlIG1lbiBhcnJheSBpbiBvcmRlciBkdWUgdG8gbG9hZGluZyBpbWFnZXMgZGlmZmVyZW50bHlcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VzLnNvcnQoZnVuY3Rpb24oYSxiKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnN0YXJ0UG9zIC0gYi5zdGFydFBvcztcbiAgICAgICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgICAgICBzdGFycnlOaWdodC5pbWFnZXMgPSBpbWFnZXM7XG4gICAgICAgICAgICAgICAgICAgIC8vdXBkYXRlcyB0aGUgdW5kZWZpbmVkIGhvdXNlIHByb3BlcnR5IHdpdGggdGhpcyBpbWdcbiAgICAgICAgICAgICAgICAgICAgJHRoaXMuaG91c2UuaG91c2VJbWcgPSBpbWc7XG4gICAgICAgICAgICAgICAgICAgICR0aGlzLmFkZERhdGEoKVxuICAgICAgICAgICAgICAgICAgICAkdGhpcy5ob3VzZS5iZWdpbigpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaW1nLnNyYyA9IG1lbltpXS5zcmNcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxudmFyIFRlY2hub2xvZ2llcyA9IGZ1bmN0aW9uKCkgeyBcbiAgICB2YXIgc3ZnUGFnZVdpZHRoID0gIF8oJ3N2Zy1wYWdlJykuZ2V0QXR0cmlidXRlKCd3aWR0aCcpXG4gICAgdmFyIHN2Z1BhZ2VIZWlnaHQgPSBfKCdzdmctcGFnZScpLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JylcbiAgICB2YXIgd2lkdGggPSBzdmdQYWdlV2lkdGggPCA5NzAgIHx8IHN2Z1BhZ2VIZWlnaHQgPCA4MDA7XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGVjaEljb25zJyk7XG4gICAgXG4gICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmNhbnZhcy53aWR0aCA9IHN2Z1BhZ2VXaWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IHRoaXMuY2FudmFzLmhlaWdodCA9IHN2Z1BhZ2VIZWlnaHQ7XG4gICAgdGhpcy5zdGFydCA9IDA7XG4gICAgdGhpcy5zdGFydDtcbiAgICB0aGlzLmJvZHlEYXRhID0gW11cbiAgICB0aGlzLmljb25zO1xuICAgIHRoaXMuaiA9IDBcbiAgICB2YXIgbmV3VGVjaG5vbG9naWVzID0gdGhpc1xuICAgIHRoaXMuZGF0YSA9IHtcbiAgICAgICAgYWRkQm9keURhdGE6ICBmdW5jdGlvbigpe1xuICAgIFxuICAgICAgICAgICAgaWYod2lkdGgpe1xuICAgICAgICAgICAgICAgIC8vQm9keSBsb2NhdGlvbiBYIGFuZCBZXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeCA6IG5ld1RlY2hub2xvZ2llcy53aWR0aC8yICAtIChuZXdUZWNobm9sb2dpZXMuYm9keURhdGFbMV0ud2lkdGggLyAyLjIpLFxuICAgICAgICAgICAgICAgICAgICB5IDogKG5ld1RlY2hub2xvZ2llcy5oZWlnaHQgLSBuZXdUZWNobm9sb2dpZXMuYm9keURhdGFbMV0uaGVpZ2h0KSAsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZVg6IG5ld1RlY2hub2xvZ2llcy53aWR0aC8yIC0gKG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVszXS53aWR0aC8yKSs2MCxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogKG5ld1RlY2hub2xvZ2llcy5oZWlnaHQgLSBuZXdUZWNobm9sb2dpZXMuYm9keURhdGFbMV0uaGVpZ2h0KSArNzAsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRYOiBuZXdUZWNobm9sb2dpZXMud2lkdGgvMiAgLSAobmV3VGVjaG5vbG9naWVzLmJvZHlEYXRhWzFdLndpZHRoIC8gMi4yKSArIDQxLFxuICAgICAgICAgICAgICAgICAgICBoZWFkWTogKG5ld1RlY2hub2xvZ2llcy5oZWlnaHQgLSBuZXdUZWNobm9sb2dpZXMuYm9keURhdGFbMV0uaGVpZ2h0KSAtIDYxXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeCA6IG5ld1RlY2hub2xvZ2llcy53aWR0aC8yICAtIChuZXdUZWNobm9sb2dpZXMuYm9keURhdGFbMV0ud2lkdGggLyAyLjIpLFxuICAgICAgICAgICAgICAgICAgICB5IDogKG5ld1RlY2hub2xvZ2llcy5oZWlnaHQgLSBuZXdUZWNobm9sb2dpZXMuYm9keURhdGFbMV0uaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgLy9UcmFuc2xhdGUgaGVhZCByb3RhdGlvblxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVYOiBuZXdUZWNobm9sb2dpZXMud2lkdGgvMiAtIChuZXdUZWNobm9sb2dpZXMuYm9keURhdGFbM10ud2lkdGgvMikrODUsXG4gICAgICAgICAgICAgICAgICAgIC8vVHJhbnNsYXRlIGhlYWQgcm90YXRpb25cbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlWTogKG5ld1RlY2hub2xvZ2llcy5oZWlnaHQgLSBuZXdUZWNobm9sb2dpZXMuYm9keURhdGFbMV0uaGVpZ2h0KSArIDEwMCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZFg6IG5ld1RlY2hub2xvZ2llcy53aWR0aC8yICAtIChuZXdUZWNobm9sb2dpZXMuYm9keURhdGFbMV0ud2lkdGggLyAyLjIpICsgNTcsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRZOiAobmV3VGVjaG5vbG9naWVzLmhlaWdodCAtIG5ld1RlY2hub2xvZ2llcy5ib2R5RGF0YVsxXS5oZWlnaHQpIC0gODdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJvdGF0ZTogLTE0MCxcbiAgICAgICAgajogMCxcbiAgICAgICAgYm9va0hlaWdodDogMjAwXG4gICAgfVxuICAgIFxuICAgIHRoaXMuc3ByaXRlcyA9IFtdXG4gICAgICAgXG4gICAgICAgIHZhciBleHQgPSBpc0ZpcmVmb3ggPyBcInBuZ1wiIDogXCJzdmdcIjtcblxuICAgICAgICB2YXIgYm9keVdpZHRoID0gd2lkdGggPyAxLjMgOiAxLjg7XG4gICAgICAgIHZhciBib2R5SGVpZ2h0ID0gd2lkdGggPyAxLjMgOiAxLjg7XG4gICAgICAgIHZhciBzcmMgPSBbXCJpbWFnZXMvdG9wLWhlYWQuXCIrZXh0LCBcImltYWdlcy9mYWNlLWJvZHkuXCIrZXh0LCBcImltYWdlcy9ib29rLlwiK2V4dCwgXCJpbWFnZXMvZnVsbC1ib2R5LlwiK2V4dF1cblxuICAgICAgICBpZih3aWR0aCl7XG5cbiAgICAgICAgICAgIHZhciBpbWdXaWR0aCA9IFsyODQuNSAsNDAwLCAzMjAuOTYsIDQwMF1cbiAgICAgICAgICAgIHZhciBpbWdIZWlnaHQgPSBbMTcwLjksIDQ4My43LCAyMjYuOCwgNTY0LjY2XVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHZhciBpbWdXaWR0aCA9IFs1NTMuNSwgNzc4LjIsIDYyOS45LCA3NzhdXG4gICAgICAgICAgICB2YXIgaW1nSGVpZ2h0ID0gWzMzMi40OSwgOTQxLCA0NDMuMjcsIDEwOTguOV1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICB0aGlzLmltZ0ljb25zID0gW1xuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL2Fkb2JlLTUwLTUwLlwiK2V4dCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQwfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9hZnRlci1lZmZlY3RzLTUyLTUyLlwiK2V4dCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQwfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9hcnRpc3RpYy01Mi01NC5cIitleHQsIHdpZHRoOiA0MCwgaGVpZ2h0OiA0Mn0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvYm9vdHN0cmFwLTUwLTUwLlwiK2V4dCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQwfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9jYW1lcmEtNTItNTIuXCIrZXh0LCB3aWR0aDogNDAsIGhlaWdodDogNDB9LFxuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL2Nsb3VkLTY0LTQ5LjUuXCIrZXh0LCB3aWR0aDogNDIsIGhlaWdodDogMzIuNX0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvY29kZS02MC01My5cIitleHQsIHdpZHRoOiA0MywgaGVpZ2h0OiAzOH0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvY3NzLTU1LTUyLlwiK2V4dCwgd2lkdGg6IDQyLCBoZWlnaHQ6IDM5Ljh9LFxuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL2Rlc2lnbi01Mi01Mi5cIitleHQsIHdpZHRoOiA0MCwgaGVpZ2h0OiA0MH0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvZ2l0LWh1Yi01NS01NS5cIitleHQsIHdpZHRoOiA0MywgaGVpZ2h0OiA0M30sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvZ29vZ2xlLWRyaXZlLTcyLTY0LlwiK2V4dCwgd2lkdGg6IDQ2LCBoZWlnaHQ6IDQwLjh9LFxuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL2lsbHVzdHJhdG9yLTUyLTUyLlwiK2V4dCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQwfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9qcy01NS01Ni5cIitleHQsIHdpZHRoOiA0MSwgaGVpZ2h0OiA0Mn0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvbm9kZS01MC01MC5cIitleHQsIHdpZHRoOiA0MCwgaGVpZ2h0OiA0MH0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvbm9kZWpzLTYwLjUtMzcuXCIrZXh0LCB3aWR0aDogNTUsIGhlaWdodDogMzMuNn0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvbnBtLTcwLTI3LjIuXCIrZXh0LCB3aWR0aDogNjUsIGhlaWdodDogMjUuMn0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvcGhvdG9zaG9wLTUyLTUyLlwiK2V4dCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQwfSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9waHAtNjUtMzUuXCIrZXh0LCB3aWR0aDogNDUsIGhlaWdodDogMjQuMn0sXG4gICAgICAgICAgICAgICAge3NyYzogXCJpbWFnZXMvaWNvbnMvcHl0aG9uLTU3LTU4LlwiK2V4dCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDQwLjd9LFxuICAgICAgICAgICAgICAgIHtzcmM6IFwiaW1hZ2VzL2ljb25zL3JlYWN0LTU5LTUyLlwiK2V4dCwgd2lkdGg6IDQyLCBoZWlnaHQ6IDM3fSxcbiAgICAgICAgICAgICAgICB7c3JjOiBcImltYWdlcy9pY29ucy9zZXJ2ZXItNTUtNTguXCIrZXh0LCB3aWR0aDogNDAsIGhlaWdodDogNDB9XG4gICAgICAgIF1cblxuICAgIHRoaXMubG9vcEltZ3MgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgbG9hZCA9IFtdXG5cbiAgICAgICAgZm9yKHZhciBqID0gMDsgaiA8IDQ7IGorKyl7XG4gICAgICAgICAgICBsb2FkLnB1c2goe1xuICAgICAgICAgICAgICAgIHNyYzogc3JjW2pdLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBpbWdXaWR0aFtqXSAvIGJvZHlXaWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGltZ0hlaWdodFtqXSAvIGJvZHlIZWlnaHRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGljb25zID0gdGhpcy5pbWdJY29uc1xuXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBpY29ucy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB2YXIgdyA9ICF3aWR0aCA/IGljb25zW2ldLnNyYy5yZXBsYWNlKC9eKFthLXpcXC9dKylcXC8oW2Etei0/XSspLShcXGRcXGQpKC4rKS9pZyxcIiQzXCIpIDogaWNvbnNbaV0ud2lkdGhcbiAgICAgICAgICAgIHZhciBoID0gIXdpZHRoID8gaWNvbnNbaV0uc3JjLnJlcGxhY2UoL14oLispKFxcZHsyfSkoLispL2lnLFwiJDJcIikgOiBpY29uc1tpXS5oZWlnaHRcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHcsaCwgaSk7XG4gICAgICAgICAgICBsb2FkLnB1c2goe1xuICAgICAgICAgICAgICAgIHNyYzogaWNvbnNbaV0uc3JjLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBwYXJzZUludCh3KSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KGgpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2FkXG4gICAgfTtcbiAgICBmdW5jdGlvbiByYW5kb20obWluLCBtYXgpe1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogIChtYXggLSBtaW4gKSArIG1pbilcbiAgICB9O1xuICAgIHRoaXMuYWRkRGF0YSA9IGZ1bmN0aW9uKG4pe1xuICAgICAgICB2YXIgaWNvbnMgPSB0aGlzLmljb25zXG4gICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBuOyBpKysgKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5zcHJpdGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIC8vRWFjaCBpY29uIGRyYXdzIGZvciBldmVyIDMwIG1pbCBzZWNcbiAgICAgICAgICAgICAgICB0aW1pbmc6ICAzMCxcbiAgICAgICAgICAgICAgICBlbmRYOiByYW5kb20oMCwgdGhpcy53aWR0aC8yICksXG4gICAgICAgICAgICAgICAgZW5kWTogcmFuZG9tKDAsIHRoaXMuaGVpZ2h0IC0gKHRoaXMuYm9keURhdGFbMV0uaGVpZ2h0ICsgNTApICksXG4gICAgICAgICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgICAgICAgc3BlZWQ6IHJhbmRvbSg0MDAwLCA5MDAwKSxcbiAgICAgICAgICAgICAgICB4OiB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgICAgICAgICB5OiB0aGlzLmRhdGEuYWRkQm9keURhdGEoKS55ICsgMTUsIC8vIHBsdXMgMTAwIHRoZSBzcHJpdGUgc2l6ZVxuICAgICAgICAgICAgICAgIGltZzogdGhpcy5pY29uc1tpJWljb25zLmxlbmd0aF0uaW1nLFxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLmljb25zW2klaWNvbnMubGVuZ3RoXS53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuaWNvbnNbaSVpY29ucy5sZW5ndGhdLmhlaWdodCxcbiAgICAgICAgICAgICAgICBYOiAwLFxuICAgICAgICAgICAgICAgIFk6IDAsXG4gICAgICAgICAgICAgICAgc3RhdGljU3BlZWQ6IDAsXG4gICAgICAgICAgICAgICAgcm90YXRlOiByYW5kb20oMTgwLCAxNDQwKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuVGVjaG5vbG9naWVzLnByb3RvdHlwZS5yb3RhdGVIZWFkID0gZnVuY3Rpb24ocm90YXRlLCBwb3Mpe1xuXG4gICAgdmFyIGltZyA9IHRoaXMuYm9keURhdGFcbiAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwwLHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpXG4gICAgdGhpcy5jdHguZHJhd0ltYWdlKGltZ1sxXS5pbWcsICBwb3MueCwgcG9zLnksIGltZ1sxXS53aWR0aCwgaW1nWzFdLmhlaWdodCkgLy9GYWNlIGJvZHlcbiAgICB0aGlzLmN0eC50cmFuc2xhdGUoICBwb3MudHJhbnNsYXRlWCwgcG9zLnRyYW5zbGF0ZVkpOyAvLyBUcmFuc2xhdGUgXG4gICAgdGhpcy5jdHgucm90YXRlKHJvdGF0ZSAqIE1hdGguUEkvMTgwKVxuICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSggLXBvcy50cmFuc2xhdGVYLC1wb3MudHJhbnNsYXRlWSApOyAvLyBUcmFuc2xhdGUgYmFja1xuICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWdbMF0uaW1nLCAgcG9zLmhlYWRYICwgIHBvcy5oZWFkWSwgaW1nWzBdLndpZHRoLCBpbWdbMF0uaGVpZ2h0KSAgLy9IZWFkIGRyYXcgaW4gdHJhbnNsYXRlZCBjYW52ZXNcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG59O1xuXG5UZWNobm9sb2dpZXMucHJvdG90eXBlLmRyYXdCb29rID0gZnVuY3Rpb24oZGF0YSwgcG9zKXtcbiAgICB2YXIgaW1nID0gdGhpcy5ib2R5RGF0YVxuICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLDAsdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodClcbiAgICB0aGlzLmN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGVzdGluYXRpb24tb3ZlcidcbiAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1nWzFdLmltZywgIHBvcy54LCBwb3MueSwgaW1nWzFdLndpZHRoLCBpbWdbMV0uaGVpZ2h0KSAvL0ZhY2UgYm9keVxuICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSggIHBvcy50cmFuc2xhdGVYLCBwb3MudHJhbnNsYXRlWSk7IC8vIFRyYW5zbGF0ZSBcbiAgICB0aGlzLmN0eC5yb3RhdGUoLTE0MCAqIE1hdGguUEkvMTgwKVxuICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSggLXBvcy50cmFuc2xhdGVYLC1wb3MudHJhbnNsYXRlWSApOyAvLyBUcmFuc2xhdGUgYmFja1xuICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWdbMF0uaW1nLCAgcG9zLmhlYWRYICwgIHBvcy5oZWFkWSwgaW1nWzBdLndpZHRoLCBpbWdbMF0uaGVpZ2h0KSAgLy9IZWFkIGRyYXcgaW4gdHJhbnNsYXRlZCBjYW52ZXNcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApO1xuXG4gICAgdGhpcy5jdHgudHJhbnNsYXRlKCAgcG9zLnRyYW5zbGF0ZVggKyBpbWdbMl0ud2lkdGggLyAyLCBwb3MudHJhbnNsYXRlWSk7IC8vIFRyYW5zbGF0ZSAgXG4gICAgdGhpcy5jdHguc2NhbGUoZGF0YS5zY2FsZSwgZGF0YS5zY2FsZSk7IC8vU2NhbGVzIGJvb2tcbiAgICB0aGlzLmN0eC50cmFuc2xhdGUoIC1wb3MudHJhbnNsYXRlWCAtIGltZ1syXS53aWR0aCAvIDIgLC1wb3MudHJhbnNsYXRlWSApOyAvLyBUcmFuc2xhdGUgYmFjayBmb3JcbiAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1nWzJdLmltZywgZGF0YS5ib29rWCwgZGF0YS5ib29rWSwgaW1nWzJdLndpZHRoLCBpbWdbMl0uaGVpZ2h0KSAvL2Jvb2sgaW1hZ2VcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApO1xufTtcblxuVGVjaG5vbG9naWVzLnByb3RvdHlwZS5kcmF3Qm9keSA9IGZ1bmN0aW9uKGRhdGEsIHBvcyApe1xuICAgIHZhciBpbWcgPSB0aGlzLmJvZHlEYXRhXG5cbiAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoaW1nWzFdLmltZywgIHBvcy54LCBwb3MueSwgaW1nWzFdLndpZHRoLCBpbWdbMV0uaGVpZ2h0KSAvL0ZhY2UgYm9keVxuICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSggIHBvcy50cmFuc2xhdGVYLCBwb3MudHJhbnNsYXRlWSk7IC8vIFRyYW5zbGF0ZSBcbiAgICB0aGlzLmN0eC5yb3RhdGUoLTE0MCAqIE1hdGguUEkvMTgwKVxuICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSggLXBvcy50cmFuc2xhdGVYLC1wb3MudHJhbnNsYXRlWSApOyAvLyBUcmFuc2xhdGUgYmFja1xuICAgIHRoaXMuY3R4LmRyYXdJbWFnZShpbWdbMF0uaW1nLCAgcG9zLmhlYWRYICwgIHBvcy5oZWFkWSwgaW1nWzBdLndpZHRoLCBpbWdbMF0uaGVpZ2h0KSAgLy9IZWFkIGRyYXcgaW4gdHJhbnNsYXRlZCBjYW52ZXNcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwwLDApO1xuICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSggIHBvcy50cmFuc2xhdGVYICsgaW1nWzJdLndpZHRoIC8gMiwgcG9zLnRyYW5zbGF0ZVkpOyAvLyBUcmFuc2xhdGUgIFxuICAgIHRoaXMuY3R4LnNjYWxlKDEuMDUsIDEuMDUpO1xuICAgIHRoaXMuY3R4LnRyYW5zbGF0ZSggLXBvcy50cmFuc2xhdGVYIC0gaW1nWzJdLndpZHRoIC8gMiAsLXBvcy50cmFuc2xhdGVZICk7IC8vIFRyYW5zbGF0ZSBiYWNrXG4gICAgdGhpcy5jdHguZHJhd0ltYWdlKGltZ1syXS5pbWcsIGRhdGEuYm9va1gsIGRhdGEuYm9va1ksIGltZ1syXS53aWR0aCwgaW1nWzJdLmhlaWdodCkgLy9ib29rIGltYWdlXG4gICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKTtcbn07XG5cblRlY2hub2xvZ2llcy5wcm90b3R5cGUuZHJhd0ljb25zID0gZnVuY3Rpb24oc3ByKXtcbiAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwwLDAsMSwgc3ByLlgsIHNwci5ZKTtcbiAgICB0aGlzLmN0eC5yb3RhdGUoc3ByLnR1cm4gKiBNYXRoLlBJLzE4MClcbiAgICB0aGlzLmN0eC5kcmF3SW1hZ2Uoc3ByLmltZywtc3ByLndpZHRoLzIsIC1zcHIuaGVpZ2h0LzIsIHNwci53aWR0aCwgc3ByLmhlaWdodCApO1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSgxLDAsMCwxLDAsMClcbn07XG5cblRlY2hub2xvZ2llcy5wcm90b3R5cGUuZHJhdyA9IGZ1bmN0aW9uKHRpbWVzdGFtcCl7XG4gICAgaWYoIXRoaXMudG9nZ2xlKSByZXR1cm5cbiAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoIDwgOTcwICB8fCB0aGlzLmhlaWdodCA8IDgwMFxuICAgIHZhciBpbWcgPSB0aGlzLmJvZHlEYXRhXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgdmFyIHBvcyA9IGRhdGEuYWRkQm9keURhdGEoKTtcbiAgICBcbiAgXG4gICAgaWYoIXRoaXMuc3RhcnQpXG4gICAgICAgIHRoaXMuc3RhcnQgPSB0aW1lc3RhbXBcbiAgICAgICAgdmFyIHJ1bnRpbWUgPSB0aW1lc3RhbXAgLSB0aGlzLnN0YXJ0XG4gICAgICAgIHZhciBwcm9ncmVzcyA9IE1hdGgubWluKHJ1bnRpbWUgLyAxMDAwLCAxKVxuXG4gICAgICAgIGlmKHByb2dyZXNzIDwgMSAmJiBkYXRhLmogPD0gMSl7XG4gICAgICBcbiAgICAgICAgICAgIGlmKHdpZHRoKXtcbiAgICAgICAgICAgICAgICAvL1VwZGF0ZXMgeCBsb2FjdGlvbnMgYW5kIHkgbG9jYXRpb24gb2YgYm9va1xuICAgICAgICAgICAgICAgIGRhdGEuYm9va1ggPSAoKHBvcy50cmFuc2xhdGVYKS00MCkgLSAoMClcbiAgICAgICAgICAgICAgICBkYXRhLmJvb2tZID0gKChwb3MudHJhbnNsYXRlWSktMTEwKSAtICg2MCpwcm9ncmVzcyk7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAvL1VwZGF0ZXMgeCBsb2FjdGlvbnMgYW5kIHkgbG9jYXRpb24gb2YgYm9va1xuICAgICAgICAgICAgICAgIGRhdGEuYm9va1ggPSAoKHBvcy50cmFuc2xhdGVYKS02MCkgLSAoMCk7XG4gICAgICAgICAgICAgICAgZGF0YS5ib29rWSA9ICgocG9zLnRyYW5zbGF0ZVkpLTE4MCkgLSAoNjAqcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9Sb3RhdGUgaGVhZFxuICAgICAgICAgICAgaWYoZGF0YS5qID09PSAwKXtcblxuICAgICAgICAgICAgICAgIHZhciByb3RhdGUgPSBkYXRhLnJvdGF0ZSpwcm9ncmVzcztcbiAgICAgICAgICAgICAgICB0aGlzLnJvdGF0ZUhlYWQocm90YXRlLHBvcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vUFVzaCB1cCBib29rXG4gICAgICAgICAgICBpZihkYXRhLmogPT09IDEpe1xuXG4gICAgICAgICAgICAgICAgZGF0YS5zY2FsZSA9IC41ICsgKC41NSAqIHByb2dyZXNzKVxuICAgICAgICAgICAgICAgIHRoaXMuZHJhd0Jvb2soZGF0YSxwb3MpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1lbHNle1xuXG4gICAgICAgICAgICAvL0RyYXcgSWNvbnNcbiAgICAgICAgICAgIGlmKGRhdGEuaiA9PT0gMil7XG4gICAgICAgICAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsMCwwLDEsMCwwKTtcbiAgICAgICAgICAgICAgICB0aGlzLmN0eC5jbGVhclJlY3QoMCwwLHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3Qm9keShkYXRhLCBwb3MpXG5cbiAgICAgICAgICAgICAgICB2YXIgc3ByaXRlcyA9IHRoaXMuc3ByaXRlcy5sZW5ndGhcbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBzcHJpdGVzOyBpKysgKXtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcHIgPSB0aGlzLnNwcml0ZXNbaV1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKGkgPD0gdGhpcy5qKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwci5zdGF0aWNTcGVlZCsrXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXNwci5zdGFydCkgc3ByLnN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcnVuID0gdGltZXN0YW1wIC0gc3ByLnN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvZyA9IHJ1biAvIHNwci5zcGVlZFxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoaSUyKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2xlZnQgdXBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHIuWCA9IHNwci54IC0gKHNwci5lbmRYICogcHJvZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHIuWSA9IHNwci55IC0gKHNwci5lbmRZICogcHJvZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcHIudHVybiA9IC1zcHIucm90YXRlICogcHJvZ1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL3JpZ2h0IHVwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwci5YID0gc3ByLnggKyAoc3ByLmVuZFggKiBwcm9nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwci5ZID0gc3ByLnkgLSAoc3ByLmVuZFkgKiBwcm9nKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwci50dXJuID0gc3ByLnJvdGF0ZSAqIHByb2dcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHNwci50b3RhbFggPSBzcHIuWFxuICAgICAgICAgICAgICAgICAgICAgICAgc3ByLnRvdGFsWSA9IHNwci5ZXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCAoc3ByLnRvdGFsWCtzcHIud2lkdGgpIDw9IDAgfHwgKHNwci50b3RhbFkrc3ByLmhlaWdodCkgPD0gMCB8fCBzcHIudG90YWxYID4gdGhpcy53aWR0aCtzcHIud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL1Jlc2V0cyB2YWx1ZXMsIGZvciBzYW1lIGljb24gdG8gcnVuIGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLnN0YXJ0ID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kcmF3SWNvbnMoc3ByKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYoc3ByLnN0YXRpY1NwZWVkID09PSBzcHIudGltaW5nKSB0aGlzLmorK1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydCA9IDBcbiAgICAgICAgICAgICAgICBkYXRhLmorK1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmRyYXcuYmluZCh0aGlzKSlcbn07XG5cblxuVGVjaG5vbG9naWVzLnByb3RvdHlwZS5sb2FkSW1hZ2VzID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgJHRoaXMgPSB0aGlzO1xuICAgIHZhciBjb3VudGVyID0gMDtcbiAgICB2YXIgbG9hZGVkSW1hZ2VzID0gMDtcbiAgICB2YXIgaW1ncyA9IFtdO1xuICAgIFxuICAgIHRoaXMubG9vcEltZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uKGltYWdlLCBpKXtcbiAgICAgICAgY291bnRlcisrO1xuICAgICAgICB2YXIgaW1nID0gbmV3IEltYWdlKClcblxuICAgICAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKXtcblxuICAgICAgICAgICAgLy9XaWR0aCBvciBoZWlnaHQgZG9lc24ndCBleGlzdCB1cGRhdGVzIDAgZm9yIGl0XG4gICAgICAgICAgICBpbWdzLnB1c2goe2ltZzogdGhpcywgaSwgd2lkdGg6IGltYWdlLndpZHRoICwgaGVpZ2h0OiBpbWFnZS5oZWlnaHQgfSlcblxuICAgICAgICAgICAgaWYoKytsb2FkZWRJbWFnZXMgPj0gY291bnRlcil7ICAgICBcbiAgICAgICAgICAgICAgICBpbWdzLnNvcnQoZnVuY3Rpb24oYSxiKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuaSAtIGIuaVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLy9XaGVuIEljb25zIGxvYWQgZnVsbCBib2R5IGltYWdlIGdldHMgYWRkZWRcbiAgICAgICAgICAgICAgICAkdGhpcy5jdHguZHJhd0ltYWdlKGltZ3NbM10uaW1nLCAoJHRoaXMud2lkdGgvMikgLSBpbWdzWzFdLndpZHRoIC8gMi4yLCAoJHRoaXMuaGVpZ2h0KSAtIGltZ3NbM10uaGVpZ2h0LCBpbWdzWzNdLndpZHRoLCBpbWdzWzNdLmhlaWdodCkgLy9GdWxsLWJvZHkgaW1hZ2VcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGJvZHlJbWdzID0gaW1ncy5zcGxpY2UoMCw0KVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICR0aGlzLmJvZHlEYXRhID0gYm9keUltZ3NcbiAgICAgICAgICAgICAgICAkdGhpcy5pY29ucyA9IGltZ3NcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vSWNvbiBkYXRhXG4gICAgICAgICAgICAgICAgJHRoaXMuYWRkRGF0YShpbWdzLmxlbmd0aClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpbWcuc3JjID0gaW1hZ2Uuc3JjO1xuICAgIH0pXG59O1xuXG5cbmZ1bmN0aW9uIFN2Z1BhZ2UoKXtcbiAgICB2YXIgc3ZnQ2xvc2VCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdjbG9zZS1idG4gc3ZnLWJ1dHRvbicpWzBdXG4gICAgdmFyIHN2Z0NpcmNsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3N2Zy1jaXJjbGUnKVswXVxuICAgIHZhciB0b2dnbGUsIGJ0bk9wZW4sIGV2ZW50O1xuICAgIHZhciBob3Zlcm1hcCA9IGhvdmVyTWFwKClcbiAgICBcbiAgICB2YXIgcmVtb3ZlR29vZXkgPSBmdW5jdGlvbihlKXtcbiAgICAgICAgc2V0VGltZW91dCggKCkgPT4ge1xuICAgICAgICAgICAgaG92ZXJtYXBbMV0oZSlcbiAgICAgICAgfSwxNDAwKVxuICAgICAgICBcbiAgICAgICAgLy8gICAgY29uc29sZS5sb2coIGhvdmVybWFwWzFdKVxuICAgICAgICAvLyAgICAgdmFyIGRpc3QgPSBob3Zlcm1hcFsxXShlKVswXTsgLy8gUG9zaXRpb24gZGlzdGFuY2Ugb2Ygc2hvdy1pY29uIGdvb2V5XG4gICAgICAgIC8vICAgICBob3Zlcm1hcFswXSggZGlzdCwgdHJ1ZSApICAvLyBoYW5kbGVyKGUpIGZ1bmN0aW9uXG5cbiAgICB9XG4gICAgdGhpcy5zdGFydDtcbiAgICAvL1BhZ2UgYW5pbWF0ZWQgZG93biByZW1vdmVzIGNpcmNsZSB0byBiZSBhbmltYXRlZCBhZ2FpblxuICAgIHRoaXMuYW5pbWF0ZUVuZCA9IGZ1bmN0aW9uKGUpe1xuICAgICAgICBjb25zb2xlLmxvZygnaGV5IHlvdScpXG4gICAgICAgICBfKCdpbnRlcmFjdGl2ZS1jb250YWluZXInKS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ2F1dG8nIFxuXG4gICAgICAgIGlmKHRvZ2dsZSl7XG4gICAgICAgICAgICAvL1NhZmFyaSBvbmx5XG4gICAgICAgICAgICBfKCdzdmctcGFnZScpLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJ1xuICAgICAgICAgICAgc3ZnQ2lyY2xlLmNsYXNzTGlzdC5yZW1vdmUoJ2NpcmNsZS1hbmltYXRlJyk7XG5cbiAgICAgICAgICAgIF8oYnRuT3BlbilbMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZy4nK2J0bk9wZW4rJyAuaXRlbXMnKS5jbGFzc0xpc3QucmVtb3ZlKCdpdGVtcy1hY3RpdmUnKVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0b2dnbGUgPSBmYWxzZVxuICAgICAgICB9ICAgXG4gICAgfVxuXG4gICAgdGhpcy5hbmltYXRlQ2lyY2xlID0gZnVuY3Rpb24odGltZXN0YW1wLCBlbGVtKXtcbiAgICAgICAgXG4gICAgICAgIGlmKCF0aGlzLnN0YXJ0KSB0aGlzLnN0YXJ0ID0gdGltZXN0YW1wO1xuXG4gICAgICAgICAgICB2YXIgcnVudGltZSA9IHRpbWVzdGFtcCAtIHRoaXMuc3RhcnQ7XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBNYXRoLm1pbihydW50aW1lIC8gdGhpcy5zcGVlZCwgMSlcbiAgICAgICAgICAgIGlzRmlyZWZveCA/IHN2Z0NpcmNsZS5zZXRBdHRyaWJ1dGUoJ3InLCAxNTAwICogcHJvZ3Jlc3MpIDogc3ZnQ2lyY2xlLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgnKyAoMCArICgxKnByb2dyZXNzKSApKyAnKSdcbiAgICAgICBcbiAgICAgICAgaWYocHJvZ3Jlc3MgPCAxKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24odGltZXN0YW1wKXtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGVDaXJjbGUodGltZXN0YW1wLCBlbGVtKVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKVxuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAvL0NhbnZhcyBmYWRlcyBpbiBhZnRlciBwYWdlIGlzIGFuaW1hdGVkIG9wZW5cbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2cuJytlbGVtKycgLml0ZW1zJykuY2xhc3NMaXN0LmFkZCgnaXRlbXMtYWN0aXZlJylcbiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoZWxlbSlbMV0ucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuYWRkKCdzaG93Q2FudmFzJylcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSBudWxsO1xuICAgICAgICB9IFxuICAgIH1cbiAgICB2YXIgY2xvc2VCdXR0b25TaG93ID0gZnVuY3Rpb24obnVtKXtcbiAgICAgICAgdmFyIG9wcG9zaXRlID0gIW51bSA/IC01NiA6IDBcbiAgICAgICAgIF8oJ3gtY2lyY2xlJykuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVgoJysgbnVtICsncHgpJ1xuICAgICAgICAgXygnbGluZScpWzBdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKCcrIG9wcG9zaXRlICsncHgpIHJvdGF0ZSgtNDVkZWcpJ1xuICAgICAgICAgXygnbGluZScpWzFdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVYKCcrIG9wcG9zaXRlICsncHgpIHJvdGF0ZSg0NWRlZyknXG4gICAgfVxuXG4gICAgLy8gT3BlbiBwYWdlIGZ1bmN0aW9uXG4gICAgdGhpcy5vcGVuTW9kYWxzID0gZnVuY3Rpb24oZSl7XG5cbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgYnRuT3BlbiA9IGUudGFyZ2V0LmlkXG4gICAgICAgIH1jYXRjaChlcnIpe1xuICAgICAgICAgICAgYnRuT3BlbiA9IGVcbiAgICAgICAgfVxuICBcbiAgICAgICAgXygnaW50ZXJhY3RpdmUtY29udGFpbmVyJykuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJyBcbiAgICAgICAgZXZlbnQgPSBlXG4gICAgICAgIF8oYnRuT3BlbilbMF0uc3R5bGUuZGlzcGxheSA9ICdibG9jaydcbiAgICAgICAgY2xvc2VCdXR0b25TaG93KC01NilcbiAgICAgICAgLy9Hb29nbGUgJ0RvIEh5ZW9uJyBmb250IGJ1ZywgZnVuY3Rpb24gaGFzIHRvIGJlIHJhbiBhZ2FpbiBpbiB2aWV3XG4gICAgICAgIGlmKGJ0bk9wZW4gPT09ICdwaG90bycpIHNsb3RNYWNoaW5lKClcbiAgICAgICAgLy9UaHJvYmJpbmcgRmluZ2VyIGltYWdlIGljb25cbiAgICAgICAgaWYoYnRuT3BlbiA9PT0gJ2Rlc2lnbicpIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaW5nZXInKS5jbGFzc0xpc3QuYWRkKCdmaW5nZXItc2NhbGUnKVxuXG4gICAgICAgIGlmKGlzU2FmYXJpKXtcblxuICAgICAgICAgICAgdG9nZ2xlID0gdHJ1ZTtcbiAgICAgICAgICAgICBfKCdzdmctcGFnZScpLnN0eWxlLnZpc2liaWxpdHkgPSBcInZpc2libGVcIlxuICAgICAgICAgICAgc3ZnQ2lyY2xlLmNsYXNzTGlzdC5hZGQoJ2NpcmNsZS1hbmltYXRlJylcblxuICAgICAgICAgICAgc3ZnQ2lyY2xlLm9uYW5pbWF0aW9uZW5kID0gZnVuY3Rpb24oKXtcbiAgICAgIFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2cuJytidG5PcGVuKycgLml0ZW1zJykuY2xhc3NMaXN0LmFkZCgnaXRlbXMtYWN0aXZlJylcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGJ0bk9wZW4pWzFdLnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnc2hvd0NhbnZhcycpXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy9DbG9zZXMgdGhlIHBhZ2UgYW5pbWF0ZWQgZG93blxuICAgICAgICAgICAgc3ZnQ2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHRvZ2dsZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAvL0F1dG9tYXRpY2FsbHkgc3RvcHMgY2FudmFzIFxuICAgICAgICAgICAgICAgIFN0cmV0Y2gucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgc2xvdE1hY2hpbmUucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgU3RhcnJ5TmlnaHQucHJvdG90eXBlLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgVGVjaG5vbG9naWVzLnByb3RvdHlwZS50b2dnbGUgPSBmYWxzZVxuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvL0NhbnZhcyAvIEl0ZW1zIGZhZGVzIG91dFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYnRuT3BlbilbMV0ucGFyZW50RWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Q2FudmFzJylcbiAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgICAgdG9nZ2xlID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbih0aW1lc3RhbXApe1xuICAgICAgICAgICAgICAgIHRoaXMuc3BlZWQgPSA2MDA7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRlQ2lyY2xlKHRpbWVzdGFtcCwgYnRuT3BlbilcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSlcblxuICAgICAgICAgICAgc3ZnQ2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICBjbG9zZUJ1dHRvblNob3coMClcbiAgICAgICAgICAgICAgICBTdHJldGNoLnByb3RvdHlwZS50b2dnbGUgPSBmYWxzZVxuICAgICAgICAgICAgICAgIHNsb3RNYWNoaW5lLnByb3RvdHlwZS50b2dnbGUgPSBmYWxzZVxuICAgICAgICAgICAgICAgIFN0YXJyeU5pZ2h0LnByb3RvdHlwZS50b2dnbGUgPSBmYWxzZVxuICAgICAgICAgICAgICAgIFRlY2hub2xvZ2llcy5wcm90b3R5cGUudG9nZ2xlID0gZmFsc2VcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGJ0bk9wZW4pWzFdLnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnc2hvd0NhbnZhcycpXG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIGlzRmlyZWZveCA/IF8oJ3N2Zy1jaXJjbGUnKS5zZXRBdHRyaWJ1dGUoJ3InLCAwKSA6IF8oJ3N2Zy1jaXJjbGUnKS5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUoMCknXG4gICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vQ3VycmVudCBTVkcgZWxlbWVudCBoaWRlc1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGJ0bk9wZW4pWzBdLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignZy4nK2J0bk9wZW4rJyAuaXRlbXMnKS5jbGFzc0xpc3QucmVtb3ZlKCdzaG93Q2FudmFzJylcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShidG5PcGVuKVsxXS5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ3Nob3dDYW52YXMnKVxuICAgICAgICAgICAgICAgIH0sMTkwMClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpO1xuXG4gICAgdmFyIHBvcFVwQ2FyZHMgPSBmdW5jdGlvbigpe1xuICAgICAgICBsZXQgb3Blbl9tb2RhbHMgPSB0aGlzLm9wZW5Nb2RhbHNcblxuICAgICAgICBsZXQgcG9wVXBjYXJkcyA9IF8oJ2NhcmQtcG9wdXBzJylcbiAgICAgICAgZm9yKGxldCBjYXJkcyBvZiBwb3BVcGNhcmRzKXtcbiAgICAgICAgICAgIGNhcmRzLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSl7XG4gICAgICAgICAgICAgICAgcmVtb3ZlR29vZXkoZSlcbiAgICAgICAgICAgICAgICBvcGVuX21vZGFscyh0aGlzLmF0dHJpYnV0ZXNbM10udmFsdWUpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpXG4gICAgaWYod1cgPCA3NjgpIHBvcFVwQ2FyZHMoKVxuICAgIFxuICAgIF8oJ2NpcmNsZS10aHVtYm5haWxzJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICAgICAgaWYod1cgPCA3Njgpe1xuICAgICAgICAgICAgaG92ZXJtYXBbMV0oZSlcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICByZW1vdmVHb29leShlKVxuICAgICAgICAgICAgdGhpcy5vcGVuTW9kYWxzKGUpXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICBcbiAgICB9LmJpbmQodGhpcykpO1xufTtcbi8vQWRkIHRvIHdpbmRvdyBvYmplY3QgdG8gYmUgdXNlZCBmb3IgaHRtbCBwYWdlIG9uZW5kIGZ1bmN0aW9uXG53aW5kb3cuc3ZnUGFnZSA9IG5ldyBTdmdQYWdlKCk7XG5cbiBcblxuZnVuY3Rpb24gZ2V0UG9zKGVsZSl7XG4gICAgICAgIFxuICAgIHZhciBlbGVtUmVjdCA9IGVsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgbWFpblN2ZyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3N2Zy1wYWdlJylbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGVsZW1MZWZ0ID0gKG1haW5Tdmcud2lkdGggLSAoIHBhcnNlSW50KGVsZS5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgKSB8fCBlbGVtUmVjdC53aWR0aCkgKSAvIDJcblxuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBlbGVtUmVjdC53aWR0aCxcbiAgICAgICAgbWFpblN2ZzogbWFpblN2ZyxcbiAgICAgICAgbGVmdDogZWxlbVJlY3QubGVmdCxcbiAgICAgICAgdG9wOiBlbGVtUmVjdC50b3AsXG4gICAgICAgIGhlaWdodDogZWxlbVJlY3QuaGVpZ2h0LFxuICAgICAgICAvL1BsYWNlcyBpbWFnZSdzIHByb3BlcnR5IGxlZnQgdG8gdGhlIGNlbnRlciBvZiBpdCdzIGNvbnRhaW5lciAoY2VudGVyIG9mIHBhZ2UpXG4gICAgICAgIGNlbnRlcmVkTGVmdDogZWxlbUxlZnRcbiAgICB9XG59O1xuXG5cbi8vRGlmZmVyZW50IHNjcmVlbiBzaXppbmcgLCBlbGVtZW50cyBhZGp1c3QgdG8gaXRcbmZ1bmN0aW9uIGFkanVzdEVsZW1lbnRzKCl7XG4gICAgdmFyIHBhdGhENzY4ID0gXCJNNTY1LjEsMHY5MDBIMGMwLDAsMC03NS4zLDAtMTkyLjRjMC0yMTEuNywwLTMwMy43LDAtNTMzLjFDMCw1MC41LDAsMCwwLDBINTY1LjF6XCI7XG4gICAgdmFyIHBhdGhENDAwID0gXCJNMzkwLDgwMEgwYzAsMCwwLTg3LjMsMC0xNjEuM1MwLDg0LDAsNDcuM1MwLDAsMCwwaDM5MFY4MDB6XCI7XG4gICAgdmFyIHNtYWxsU3BsaW5lcyA9IFwiLjQyIDAgMSAxOy40MiAwIDEgMTsuNDIgMCAxIDE7LjQyIDAgMSAxO1wiXG4gICAgdmFyIHNtYWxsS2V5VGltZXMgPSBcIjA7IDAuMjA7IDAuNDU7IDFcIlxuICAgIHZhciBzdmcgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzdmctcGFnZScpWzBdXG4gICAgXG4gICAgLy9TZXRzIHNpemluZyBmb3Igb3BlbmluZyBjbG9zaW5nIHN2Zy1wYWdlIHdhdmVcbiAgICBpZih3SCA8IDg0MCAmJiB3Vyl7XG4gICAgICAgIHZhciBzdmdXaWR0aCA9IHdXIDwgNTAwID8gd1cgLSAyMCA6IHdXIC0gNTA7XG4gICAgICAgIHZhciBzdmdIZWlnaHQgPSB3SCA8IDY4MCA/IHdIIC0gMTUgOiB3SCAtIDUwO1xuICAgIH1lbHNle1xuICAgICAgICB2YXIgc3ZnV2lkdGggPSB3VyA8IDUwMCA/IHdXIC0gMjAgOiB3VyAtIDUwO1xuICAgICAgICB2YXIgc3ZnSGVpZ2h0ID0gODQwXG4gICAgfVxuXG4gICAgaWYod1cgPD0gNjE1KXtcbiAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwYXRoJykuc2V0QXR0cmlidXRlKCdkJywgcGF0aEQ3NjgpXG4gICAgICAgIF8oJ3BhdGgnKS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsIGFuaW1hdGU3NjgpXG4gICAgICAgIF8oJ3BhdGgnKS5zZXRBdHRyaWJ1dGUoJ2tleVRpbWVzJywgc21hbGxLZXlUaW1lcylcbiAgICAgICAgXygncGF0aCcpLnNldEF0dHJpYnV0ZSgna2V5U3BsaW5lcycsIHNtYWxsU3BsaW5lcylcbiAgICB9XG5cbiAgICBpZih3VyA8PSA0MDApe1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGF0aCcpLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGhENDAwKVxuICAgICAgICBfKCdwYXRoJykuc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCBhbmltYXRlNDAwKVxuICAgIH1cblxuICAgIGlmKHdXID49IDk3MCAmJiB3SCl7XG5cbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBzdmdIZWlnaHQpXG4gICAgICAgICAgICBcbiAgICB9ZWxzZSB7XG4gICAgICAgIGlmKHdIID4gODQwKXtcbiAgICAgIFxuICAgICAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgXCIwIDAgXCIrIFwiIFwiK3N2Z1dpZHRoICsgXCIgXCIgKyBzdmdIZWlnaHQpOyBcbiAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBzdmdXaWR0aClcbiAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgc3ZnSGVpZ2h0KVxuXG4gICAgICAgIH1cbiAgICAgICAgaWYod0ggPCA4NDApeyBcbiAgICAgICAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIFwiMCAwIFwiKyBcIiBcIitzdmdXaWR0aCArIFwiIFwiICsgc3ZnSGVpZ2h0KTsgXG4gICAgICAgICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgc3ZnV2lkdGgpXG4gICAgICAgICAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHN2Z0hlaWdodClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmKHdXICYmIHdIKXtcbiAgICAgICBcbiAgICAgICAgLy9BZGQgdG8gZWxlbWVudCB3aGVuIG1vcmUgY2FudmFzZXMgYXJlIGFkZGVkIHRvIEhUTUxcbiAgICAgICAgdmFyIGVsZW1lbnRHID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnZy5waG90bywgZy5kZXZlbG9wZXIsIGcuZGVzaWduLCBnLmFuaW1hdGlvbnMsIGcudGVjaG5vbG9naWVzJylcblxuICAgICAgICBlbGVtZW50Ry5mb3JFYWNoKGZ1bmN0aW9uKGVsLCBpKXtcbiAgICAgICAgICAgIHZhciBncm91cE5hbWUgPSBlbC5jbGFzc0xpc3RbMF07XG4gICAgICBcbiAgICAgICAgICAgIGlmKGdyb3VwTmFtZSA9PT0gJ3Bob3RvJyl7XG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzbG90LW1hY2hpbmUnKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzLWFyZWEnKS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgxNTcsIDApJyk7XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoZWwuY2hpbGRyZW4sZnVuY3Rpb24oZWxlbSwgaSl7XG4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIC8vQ2FtZXJhIFNWR1xuICAgICAgICAgICAgICAgICAgICBpZihpID09PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld0hlaWdodCA9IG5ld1NpemUoJ3dpZHRoJywgNzAwLCBlbGVtKS5oZWlnaHRcbiAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCA3MDApXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgbmV3SGVpZ2h0KVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcG9zID0gZ2V0UG9zKCBlbGVtICk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2V0QXR0cmlidXRlWSA9IHBvcy5tYWluU3ZnLmhlaWdodCAtIG5ld0hlaWdodCAtIDVcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd4JywgcG9zLmNlbnRlcmVkTGVmdClcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd5Jywgc2V0QXR0cmlidXRlWSlcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYod1cgPD0gNTAwIHx8IHdIIDw9IDgwMCl7XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbidcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy9Gb3JlaWduT2JqZWN0IGhvbGRzIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICBpZihpID09PSAyKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYod1cgPCA5NzApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYW52YXNBcmVhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcy1hcmVhJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHBvcyA9IGdldFBvcyggY2FudmFzQXJlYSApXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZih3SCA8IDY0MCAmJiB3VyA8IDgwMCl7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCAyNDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vZmlyZWZveFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhaXNGaXJlZm94ID8gZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCBzdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSAtIHBvcy5oZWlnaHQgLSAxNikgOiAoc3ZnLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSAvIDIpIC0gMzk3LjYgLyAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgneScsIHN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIC0gMzk3LjYgLSAxNilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW0uc2V0QXR0cmlidXRlKCd5JywgMjUwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMzYwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAzNjApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIWlzRmlyZWZveCA/IGVsZW0uc2V0QXR0cmlidXRlKCd4JywgcG9zLmxlZnQgLTYpIDogZWxlbS5zZXRBdHRyaWJ1dGUoJ3gnLCAoc3ZnLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSAvIDIpIC0gMzk3LjYgLyAyICsgMjAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsZW0uc2V0QXR0cmlidXRlKCd5Jywgc3ZnLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgLSBwb3MuaGVpZ2h0IC0gMTYpXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvc0hlaWdodCA9IGdldFBvcyggZWxlbSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHdpZHRoID0gcGFyc2VJbnQoIGVsZW0uZ2V0QXR0cmlidXRlKCd3aWR0aCcpIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbUxlZnQgPSAocG9zSGVpZ2h0Lm1haW5Tdmcud2lkdGggLSB3aWR0aCkgLSAxNTtcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgneScsIDYwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd4JywgZWxlbUxlZnQpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdXIDw9IDUwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0aGlzUG9zID0gZ2V0UG9zKCBlbGVtIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgneCcsIHRoaXNQb3MuY2VudGVyZWRMZWZ0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdIIDwgNjIwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCAyMDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL0l0ZW1zXG4gICAgICAgICAgICAgICAgICAgIGlmKGkgPT09IDEpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcyA9IGdldFBvcyggZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NhbnZhcy1hcmVhJykgKVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgNDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jaGlsZE5vZGVzWzFdLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMjM1KSAgXG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKCd4JywgMjApXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih3VyA8IDk3MCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jaGlsZE5vZGVzWzFdLnNldEF0dHJpYnV0ZSgneScsIDApXG4gICAgICAgICAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKCd5JywgMTAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYod2luZG93LmlubmVyV2lkdGggPD0gNTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jaGlsZE5vZGVzWzFdLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAzMzUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5jaGlsZE5vZGVzWzFdLnNldEF0dHJpYnV0ZSgneCcsIDEwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGlzUG9zID0gZ2V0UG9zKCBlbGVtLmNoaWxkTm9kZXNbMV0gKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZihncm91cE5hbWUgPT09ICdkZXZlbG9wZXInKXtcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKGVsLmNoaWxkcmVuLCBmdW5jdGlvbihlbGVtLCBpKXtcbiAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9mb3JlaWduT2JqZWN0IGhvbGRzIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICBpZihpID09PSAxKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdXIDwgOTcwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgnd2lkdGgnLDQwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDM3NSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gZ2V0UG9zKGVsLmNoaWxkcmVuWzBdKVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCAyMDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZih3aW5kb3cuaW5uZXJXaWR0aCA8PSA4NTApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdIIDwgNjkwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCAyNSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd4JywgNSApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd4JywgNTApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd5JywgNzUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYod2luZG93LmlubmVyV2lkdGggPCA1MDUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdIIDwgNjkwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbS5zZXRBdHRyaWJ1dGUoJ3knLCA1MCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCd4JywgMCApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywzNjApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAzNzUpO1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0aGlzUG9zID0gZ2V0UG9zKGVsZW0uY2hpbGROb2Rlc1sxXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgneScsIDUwIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLnNldEF0dHJpYnV0ZSgneCcsIDUgKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2l0ZW1zXG4gICAgICAgICAgICAgICAgICAgIGlmKGkgPT09IDApe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYod2luZG93LmlubmVyV2lkdGggPCA1MDUpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoJ3gnLCAxMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKCd5JywgNDI0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW0uY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMzcwKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdXID4gNTA1ICYmIHdXIDwgODUwICl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYod0ggPCA2OTApe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKCd5JywgNDI1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNoaWxkTm9kZXNbMV0uc2V0QXR0cmlidXRlKCd3aWR0aCcsIDM3MClcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1lbHNlIGVsZW0uY2hpbGROb2Rlc1sxXS5zZXRBdHRyaWJ1dGUoJ3knLCA0NjApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGdyb3VwTmFtZSA9PT0gJ2Rlc2lnbicpe1xuICAgICAgICAgICAgICAgIHZhciBpdGVtcyA9IGVsLmNoaWxkcmVuWzBdLmNoaWxkcmVuWzBdXG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhc0FyZWEgPSBlbC5jaGlsZHJlblsxXVxuICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHdIICYmIHdXID4gOTcwKXtcblxuICAgICAgICAgICAgICAgICAgICBpZiggY2FudmFzQXJlYSApe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYod1cgPiAxMjAwKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNBcmVhLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCA1ODApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDU4MClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc0FyZWEuc2V0QXR0cmlidXRlKCd5JywgODApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYoIGl0ZW1zICl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtcy5zZXRBdHRyaWJ1dGUoJ3knLCAyMDApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKCB3VyA+IDc1MCAmJiB3VyA8IDk3MCl7XG4gICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKCBjYW52YXNBcmVhICl7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL0ZvciBTYWZhcmkgb3ZlcmZsb3cgbm90IHdvcmtpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIHdXIDwgODEwID8gY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ3gnLCAyMTApIDogY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ3gnLCAyNTUpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNBcmVhLnNldEF0dHJpYnV0ZSgneScsIDE2MClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHdIIDwgNzAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9Gb3IgU2FmYXJpIG92ZXJmbG93IG5vdCB3b3JraW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDQ1MClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiggaXRlbXMgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgneScsIDApXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgneScsIDApXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgneCcsIDEwKVxuICAgICAgICAgICAgICAgICAgICB3SCA8IDcwMCA/IGl0ZW1zLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMjUwKSAgOiAgaXRlbXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAyNjApXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAzNDApXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhlaWdodCA9IGl0ZW1zLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JylcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ3knLCBoZWlnaHQpXG5cbiAgICAgICAgICAgICAgICAgICAgd1cgPCA2MDAgPyBjYW52YXNBcmVhLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCA0MDApIDogY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgNTAwKVxuICAgICAgICAgICAgICAgICAgICB3VyA8IDYwMCA/IGNhbnZhc0FyZWEuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCA0MDApIDogY2FudmFzQXJlYS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIDUwMClcblxuICAgICAgICAgICAgICAgICAgICB2YXIgY2FudmFzUG9zID0gZ2V0UG9zKGNhbnZhc0FyZWEpXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0FyZWEuc2V0QXR0cmlidXRlKCd4JywgY2FudmFzUG9zLmNlbnRlcmVkTGVmdClcbiAgICAgICAgICAgICAgICAgICAgLy9Gb3Igc2FmYXJpLCBzbyBwaG90byBkb2Vzbid0IHNob3cgdGhlIG92ZXJmbG93XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0FyZWEuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzdmcuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSAtIGl0ZW1zLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpXG4gICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGdyb3VwTmFtZSA9PT0gJ2FuaW1hdGlvbnMnKXtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBlbC5jaGlsZHJlblswXS5jaGlsZHJlblswXVxuICAgICAgICAgICAgICAgIHZhciBjYW52YXNBcmVhID0gZWwuY2hpbGRyZW5bMV1cbiAgICAgICAgICAgICAgICB2YXIgc3ZnUGFnZUhlaWdodCA9IHN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpXG5cbiAgICAgICAgICAgICAgICBpZih3SCAmJiB3VyA+IDk3MCl7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0FyZWEuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBzdmdQYWdlSGVpZ2h0KVxuICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZih3VyA8IDc2OCl7XG4gICAgICAgICAgICAgICAgICAgIGxldCBib3R0b20gPSAoIHN2Zy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIC0gMzEwICkgLyAyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgneCcsIDE1KVxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5zZXRBdHRyaWJ1dGUoJ3knLCBib3R0b20pXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMzIwKVxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgMzcwKVxuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNBcmVhLnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc3ZnUGFnZUhlaWdodClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihncm91cE5hbWUgPT09ICd0ZWNobm9sb2dpZXMnKXtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbXMgPSBlbC5jaGlsZHJlblswXS5jaGlsZHJlblswXVxuICAgICAgICAgICAgICAgIHZhciBjYW52YXNBcmVhID0gZWwuY2hpbGRyZW5bMV1cblxuICAgICAgICAgICAgICAgIGlmKHdXIDwgNjUwICYmIHdIIDwgNjU1KXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbSA9ICggc3ZnLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykgLSAzNzAgKSAvIDJcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMuc2V0QXR0cmlidXRlKCd5JywgYm90dG9tKVxuICAgICAgICAgICAgICAgICAgICBpdGVtcy5zZXRBdHRyaWJ1dGUoJ3gnLCA1KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9ICBcbn07XG5cblxuaWYod1cgPCA5NzAgfHwgd0ggPCA4MDApe1xuICAgIGFkanVzdEVsZW1lbnRzKCk7XG59ZWxzZSB7XG4gICAgLy9BZGRzIG1hcmdpbiBiZXR3ZWVuIGZ1bGwgaGVpZ2h0IHRocmVzaGhvbGQgZm9yIHN2Zy1wYWdlXG4gICAgaWYod0ggPCA4NDApe1xuICAgICAgIF8oJ3N2Zy1wYWdlJykuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB3SCAtIDQwKSBcbiAgICB9XG4gICAgaWYod1cgPCAxMDAwKXtcbiAgICAgICAgXygnc3ZnLXBhZ2UnKS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd1cgLSA0MCkgXG4gICAgfVxuICAgdmFyIGRlc2lnbkNhbnZhcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5kZXNpZ24gLml0ZW0tY2FudmFzJylcbiAgIGRlc2lnbkNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgNTgwKVxuICAgZGVzaWduQ2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgNTgwKVxufVxuXG4vL01vdmVzIGNsb3NlIGJ1dHRvbiB0byByaWdodCBvZiBzdmctcGFnZVxuZnVuY3Rpb24gcGxhY2VDbG9zZUJ1dHRvbigpe1xuICAgIFxuICAgIHZhciBidG5Qb3MgPSBnZXRQb3MoIF8oJ2Nsb3NlLWJ0bicpIClcbiAgICBfKCdjbG9zZS1idG4nKS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWCgnKyAoYnRuUG9zLm1haW5Tdmcud2lkdGggLSA1NiApKydweCknXG59XG5wbGFjZUNsb3NlQnV0dG9uKCk7XG5cblxuZnVuY3Rpb24gaG92ZXJNYXAoKXtcbiAgICB2YXIgYnRuV3JhcCA9IF8oJ2J1dHRvbi13cmFwJylcbiAgICB2YXIgZGlzdDtcbiAgICB2YXIgbGFzdERpc3Q7XG4gICAgdmFyIGN1cnJlbnRQYXRoOyAvL1BhdGggdG8gYmUgcmVtb3ZlZCB3aGVuIG1vdXNlb3V0XG4gIFxuICAgIHZhciBtb3VzZU91dCA9IGZ1bmN0aW9uKGRpc3Qpe1xuICAgICAgICAvLyBkaXN0IGZyb20gb3BlbmluZyBwb3B1cHMgdG8gcmVtb3ZlIHBvaW50ZXJcbiAgICAgICAgdmFyIHBvaW50ZXJEaXN0ID0gdHlwZW9mIGRpc3QgPT09ICdudW1iZXInID8gZGlzdCA6IGxhc3REaXN0XG4gIFxuICAgICAgICBfKCdvdmFsLXBvaW50ZXInKS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKC04MHB4LCAwcHggKSdcbiAgICAgICAgXG4gICAgICAgIGlmKGlzRmlyZWZveCl7XG4gICAgICAgICAgXG4gICAgICAgICAgICBfKCdzaG93LWljb24nKS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKC0yNHB4LCcgKyBwb2ludGVyRGlzdCArICdweCApJyBcbiAgICAgICAgIFxuICAgICAgICB9ZWxzZSBpZihpc1NhZmFyaSl7XG5cbiAgICAgICAgICAgICBfKCdzaG93LWljb24nKS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKC0yNHB4LCcgKyBwb2ludGVyRGlzdCArICdweCApJ1xuXG4gICAgICAgIH1lbHNle1xuXG4gICAgICAgICAgICAgXygnc2hvdy1pY29uJykuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgtMjJweCwnICsgcG9pbnRlckRpc3QgKyAncHggKSdcblxuICAgICAgICB9ICBcbiAgICB9O1xuXG4gICAgaWYod1cgPiA3NjgpIGJ0bldyYXAub25tb3VzZW92ZXIgPSBoYW5kbGVyO1xuICAgICAgICBcbiAgICBmdW5jdGlvbiBoYW5kbGVyKGUpe1xuICAgICAgICBkaXN0ID0gZ2V0RGlzdGFuY2UoZS50YXJnZXQuY2xhc3NOYW1lLCBlLnRhcmdldC5pZCkgXG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0RGlzdGFuY2UoZWwsaWQpIHtcbiAgICAgICAgICAgIHZhciB0b3RhbERpc3QgPSBmdW5jdGlvbihuKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gbiAqIDM3XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbm9kZWxpc3QgPSBfKGVsKVxuICAgICAgICAgICAgdmFyIGVsQXJyYXkgPSBbXS5zbGljZS5jYWxsKG5vZGVsaXN0KVxuICAgICAgICAgXG4gICAgICAgICAgIGZvcih2YXIgaSA9IDA7IGkgPCBlbEFycmF5Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgICBpZihlbEFycmF5W2ldLmlkID09IGlkKSByZXR1cm4gdG90YWxEaXN0KGkpO1xuICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICBcblxuICAgICAgICBmdW5jdGlvbiBnZXRQYXRoRWxlbWVudChlbCwgbWFwX3BhdGhzKXtcbiAgICAgICAgICAgIHZhciBuZXdQYXRoQXJyYXkgPSBbXVxuICAgICAgICAgICAgdmFyIHBhdGhBcnJheSA9IFtdLnNsaWNlLmNhbGwoIG1hcF9wYXRocyApXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vUHV0cyBlbGVtZW50cyBpbiBjb3JyZWN0IG9yZGVyXG4gICAgICAgICAgICBmb3IodmFyIGkgPSBwYXRoQXJyYXkubGVuZ3RoIC0xOyBpID49IDA7IGktLSl7XG4gICAgICAgICAgICAgICAgbmV3UGF0aEFycmF5LnB1c2gocGF0aEFycmF5W2ldKVxuICAgICAgICAgICAgfVxuIFxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsKVxuICAgICAgICAgICAgdmFyIHRhcmdldEFycmF5ID0gW10uc2xpY2UuY2FsbCggXyh0YXJnZXQuY2xhc3NOYW1lKSApICBcblxuICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRhcmdldEFycmF5Lmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgICAgIGlmKHRhcmdldEFycmF5W2ldID09PSB0YXJnZXQpIHJldHVybiBuZXdQYXRoQXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGFuaW1hdGVHb29leSA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiggIV8oJ3Nob3ctaWNvbicpLmNsYXNzTGlzdC5jb250YWlucygnaWNvbi10cmFuc2l0aW9uJykgKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1zIG9ubHkgdXAgYW5kIGRvd24gYmVmb3JlIG91dC5cbiAgICAgICAgICAgICAgICBfKCdzaG93LWljb24nKS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKC0yMnB4LCcgKyBkaXN0ICsgJ3B4ICknXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgXygnc2hvdy1pY29uJykuY2xhc3NMaXN0LmFkZCgnaWNvbi10cmFuc2l0aW9uJylcbiAgICAgICAgICAgICAgICAgICAgXygnc2hvdy1pY29uJykuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgtMTVweCwnICsgZGlzdCArICdweCApJ1xuICAgICAgICAgICAgICAgICAgICBfKCdvdmFsLXBvaW50ZXInKS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDBweCwgMHB4ICknXG4gICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0sMTAwKVxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgXygnc2hvdy1pY29uJykuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgtMTVweCwnICsgZGlzdCArICdweCApJ1xuICAgICAgICAgICAgICAgIF8oJ292YWwtcG9pbnRlcicpLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMHB4LCAwcHggKSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhbmltYXRlUGF0aExpbmVzID0gZnVuY3Rpb24ocGF0aCwgbWFwX3BhdGhzKXtcbiAgICAgICAgICAgIHZhciBjbGFzc0lkID0gcGF0aC5pZC5yZXBsYWNlKC8tc20kL2lnLCBcIlwiKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXBfcGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgLy9SZW1vdmVzIGFsbCBjbGFzc2VzIGJlZm9yZSB0YXJnZXQgZWxlbWVudCBjbGFzcyBnZXRzIGFkZGVkXG4gICAgICAgICAgICAgICAgaWYobWFwX3BhdGhzW2ldLmNsYXNzTGlzdC5sZW5ndGggPT09IDIpe1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSBtYXBfcGF0aHNbaV0uY2xhc3NMaXN0WzFdXG4gICAgICAgICAgICAgICAgICAgIG1hcF9wYXRoc1tpXS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRoLmNsYXNzTGlzdC5hZGQoY2xhc3NJZClcbiAgICAgICAgICAgIHJldHVybiBjbGFzc0lkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbW92ZUNhcmRzQ2xhc3MgPSBmdW5jdGlvbih0YXJnZXQpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBjYXJkID0gXygnY2FyZC1pY29uJylcbiAgICAgICAgICAgIGxldCBsZW5ndGggPSBjYXJkLmxlbmd0aFxuXG4gICAgICAgICAgICB3aGlsZShsZW5ndGgtLSl7XG4gICAgICAgICAgICAgICAgbGV0IHN0eWxlVHJhbnNmb3JtID0gK2NhcmRbbGVuZ3RoXS5zdHlsZS50cmFuc2Zvcm0ucmVwbGFjZSgvKFteLVxcZF0pL2lnLCAnJylcbiAgICAgICAgICAgICAgICBpZihzdHlsZVRyYW5zZm9ybSAhPT0gMCkgY2FyZFtsZW5ndGhdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVZKDBweCknXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5pbWF0ZUNhcmRzVXAgPSBmdW5jdGlvbihwYXRoKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY29uc3QgY2FyZCA9IF8oJ2NhcmQtaWNvbicpXG4gICAgICAgICAgICBsZXQgcmVnRXggPSAvLS4rJC9pZ1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHBhdGguaWQucmVwbGFjZShyZWdFeCwgJycpXG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gY2FyZC5sZW5ndGhcblxuICAgICAgICAgICAgLy9JZiB0YXJnZXQgYWxzbyBoYXMgMiBjbGFzc0xpc3QsIHJlbW92ZSB0aGF0IGNsYXNzIGFuZCBhZGQgcDBvcHVwY2FyZFxuICAgICAgICAgICAgd2hpbGUobGVuZ3RoLS0pe1xuICAgICAgICAgICAgICAgIGxldCBjYXJkUGFyZW50ID0gY2FyZFtsZW5ndGhdLnBhcmVudE5vZGVcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGVUcmFuc2Zvcm0gPSArY2FyZFtsZW5ndGhdLnN0eWxlLnRyYW5zZm9ybS5yZXBsYWNlKC8oW14tXFxkXSkvaWcsICcnKVxuXG4gICAgICAgICAgICAgICAgaWYodGFyZ2V0ID09PSBjYXJkUGFyZW50LmlkLnJlcGxhY2UocmVnRXgsICcnKSApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FyZFtsZW5ndGhdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVZKC0xNDBweCknXG4gICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhcmRbbGVuZ3RoXS5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlWSgtMTQwcHgpJ1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1lbHNlIGlmKHN0eWxlVHJhbnNmb3JtICE9PSAwKXtcbiAgICAgICAgICAgICAgICAgICAgY2FyZFtsZW5ndGhdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGVZKDBweCknXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gQW5pbWF0ZUNpcmNsZXMocGF0aCwgbWFwX3BhdGhzKXtcbiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNpcmNsZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjcHVsc2UtY2lyY2xlcyBjaXJjbGUnKVxuICAgICAgICAgICAgdmFyIHBhdGhzID0gW11cbiAgICAgICAgICAgIC8vUmVtb3ZlcyBhbGwgY2xhc3NlcyBiZWZvcmUgdGFyZ2V0IGVsZW1lbnRzIGNsYXNzZXMgZ2V0cyBhZGRlZFxuICAgICAgICAgICAgZm9yKGxldCBjaXIgb2YgY2lyY2xlcyl7XG4gICAgICAgICAgICAgICAgaWYoY2lyLmNsYXNzTGlzdC5sZW5ndGggPiAxKXtcbiAgICAgICAgICAgICAgICAgICAgY2lyLmNsYXNzTGlzdC5yZW1vdmUoY2lyLmNsYXNzTGlzdFsxXSlcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9TdG9wcyBiZWZvcmUgZXJyb3Igd2hlbiBub3QgcGFzc2luZyBhcmd1bWVudHMgZnJvbSBjbGljayBoYW5kbGVyXG4gICAgICAgICAgICBpZighYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAvL1BhaXJzIGNpcmNsZXMgYW5kIHJldHVybnMgdGhlIHBhaXJzIHNvIGNsYXNzZXMgY2FuIGJlIGFkZGVkXG4gICAgICAgICAgICB2YXIgcGFpckNpcmNsZXMgPSBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHZhciBjaXIgPSBbXVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2lyY2xlcy5sZW5ndGg7IGorPTIpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNpci5wdXNoKCBbY2lyY2xlc1tqXSwgY2lyY2xlc1tqKzFdXSApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcF9wYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHBhdGhzLnVuc2hpZnQoIG1hcF9wYXRoc1tpXS5pZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGluZGV4ID0gcGF0aHMuaW5kZXhPZihwYXRoLmlkKVxuICAgICAgICAgICAgdmFyIGNpclBhaXJzID0gcGFpckNpcmNsZXMoKVtpbmRleF1cblxuICAgICAgICAgICAgY2lyUGFpcnNbMF0uY2xhc3NMaXN0LmFkZCgnbWlkZGxlLXB1bHNlJylcbiAgICAgICAgICAgIGNpclBhaXJzWzFdLmNsYXNzTGlzdC5hZGQoJ3JpbmctcHVsc2UnKSBcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgcmVtb3ZlQ2lyY2xlcyA9IGZ1bmN0aW9uKHN0cmluZyl7XG4gICAgICAgICAgICB2YXIgYWN0aXZlQ2lyY2xlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5taWRkbGUtcHVsc2UsIC5yaW5nLXB1bHNlJylcblxuICAgICAgICAgICAgZm9yKGxldCBjaXIgb2YgYWN0aXZlQ2lyY2xlcyl7XG4gICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2lyLmFkZEV2ZW50TGlzdGVuZXIoJ2FuaW1hdGlvbmVuZCcsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoZS50YXJnZXQuY2xhc3NMaXN0WzFdKVxuICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUFsbChzdHJpbmcpe1xuICAgICAgICAgICAgcmVtb3ZlQ2lyY2xlcyhzdHJpbmcpXG4gICAgICAgICAgICBtb3VzZU91dChkaXN0KVxuICAgICAgICAgICAgcmVtb3ZlQ2FyZHNDbGFzcygpXG4gICAgICAgICAgICB0cnl7XG4gICAgICAgICAgICAgICAgLy9QYXRoIHRvIGJlIHJlbW92ZWQgd2hlbiBtb3VzZW91dFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGN1cnJlbnRQYXRoKS5jbGFzc0xpc3QucmVtb3ZlKGN1cnJlbnRQYXRoKVxuICAgICAgICAgICAgfWNhdGNoKGVycil7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVNYXAoZSl7XG4gICAgICAgICAgIGxldCB0YXJnZXQgPSBlLnRhcmdldC5jbGFzc0xpc3QudmFsdWVcbiAgICAgXG4gICAgICAgICAgIC8vSWYgY2xpY2sgY29tZXMgZnJvbSBvcGVuaW5nIHN2ZyBtb2RhbHNcbiAgICAgICAgICAgIGlmKHRhcmdldCA9PT0gJ2NhcmQtY29sb3Itc3QzOScgfHwgd1cgPiA3NjggJiYgZS50eXBlID09PSAnY2xpY2snKXtcblxuICAgICAgICAgICAgICAgIHJldHVybiAgcmVtb3ZlQWxsKHBhdGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1vdXNlIG92ZXJcbiAgICAgICAgICAgIGlmKGUudGFyZ2V0LmlkKXtcbiAgICAgICAgICAgICAgICAvL1N0YXJ0IHRoZSBwYXRoIGFuaW1hdGVkIGxpbmVzXG4gICAgICAgICAgICAgICAgdmFyIG1hcF9wYXRocyA9IHdXID4gNzY4ID8gXygnbWFwLXBhdGhzJykgOiBfKCdtYXAtcGF0aHMtc20nKVxuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gZ2V0UGF0aEVsZW1lbnQoZS50YXJnZXQuaWQsIG1hcF9wYXRocylcblxuICAgICAgICAgICAgICAgIC8vVXNlZCB0byB1cGRhdGUgdHJhbnNsYXRlIGZvciBidXR0b24gbG9jYXRpb25cbiAgICAgICAgICAgICAgICBsYXN0RGlzdCA9IGRpc3RcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGFuaW1hdGVHb29leSgpXG4gICAgICAgICAgICAgICAgY3VycmVudFBhdGggPSBhbmltYXRlUGF0aExpbmVzKHBhdGgsIG1hcF9wYXRocylcbiAgICAgICAgICAgICAgICBBbmltYXRlQ2lyY2xlcyhwYXRoLCBtYXBfcGF0aHMpXG4gICAgICAgICAgICAgICAgYW5pbWF0ZUNhcmRzVXAocGF0aClcbiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vT25seSBydW5zIGFmdGVyIG1vdXNlb3ZlciBlbGVtZW50cyBydW4gZmlyc3QsIHRoZW4gaW5pdGlhdGVkLiBcbiAgICAgICAgICAgICAgICBfKCdpbnRlcmFjdGl2ZS1jb250YWluZXInKS5vbm1vdXNlb3ZlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYoZS50YXJnZXQuY2xhc3NOYW1lICE9PSAnb3Blbi1jYW52YXMtcGFnZScgJiYgd1cgPiA3Njgpe1xuIFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQWxsKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXG4gICAgICAgIGlmIChlLnR5cGUgPT0gJ21vdXNlb3ZlcicgJiYgd1cgPiA3NjgpIHtcbiAgICAgICAgICAgIGhhbmRsZU1hcChlKVxuICAgICAgICB9ZWxzZSBpZihlLnR5cGUgPT09ICdjbGljaycpe1xuICAgIFxuICAgICAgICAgICAgaGFuZGxlTWFwKGUpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtkaXN0XVxuICAgIH1cbiAgICByZXR1cm4gW21vdXNlT3V0LCBoYW5kbGVyXSAvLyBUbyBiZSBhYmxlIHRvIHVzZSBtb3VzZU91dCBmdW5jdGlvbiBhbmQgaGFuZGxlciBmdW5jdGlvbiB0aGF0IHJldHVybnMgZGlzdCB0byB1c2UgZm9yIG1vdXNlT3V0IEZ1bmNcbn07XG5cbnZhciB0b2dnbGVTdGFycyA9IHtcbiAgICB0b2dnbGU6IGZhbHNlXG59XG5cbnZhciByb2JvdFNlY3Rpb24gPSBmdW5jdGlvbihlKXtcblxuICAgIGNvbnN0IHN0YXJzID0gW11cbiAgICB2YXIgYW5pbWF0ZVN0YXJzID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIFxuICAgICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N0YXItY2FudmFzJyk7XG4gICAgICAgIGxldCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgbGV0IHdpZHRoID0gY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGxldCBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuXG4gICAgICAgIGxldCByYW5kb21XaWR0aCA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vbWF4IGFuZCBtaW5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpICogKHdpZHRoLzIgLSB3aWR0aC85KSArIHdpZHRoLzlcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBOaWdodFN0YXJzID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IHJhbmRvbVN0YXJ0ID0gcmFuZG9tV2lkdGgoKVxuXG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uID0gMjAwMCAvL3VzZWQgdG8gZGVsYXkgc3RhcnNcbiAgICAgICAgICAgIHRoaXMucmFkaXVzID0gMTMgKyBNYXRoLnJhbmRvbSgpICogNSAvL3NpemUgb2Ygc3RhcnNcblxuICAgICAgICAgICAgdGhpcy5pID0gMCAvL3ggYW5kIHkgc3BlZWRcbiAgICAgICAgICAgIHRoaXMuayA9IDAgLy9vcGFjaXR5IHNwZWVkXG5cbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB7XG4gICAgICAgICAgICAgICAgeTogTWF0aC5yYW5kb20oKSAqIGhlaWdodFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLkZsaWNrZXIgPSAoaW5jcmVudG1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKE1hdGguY29zKGluY3JlbnRtZW50IC0gTWF0aC5QSS8xODApICogLjIgKSBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yYWRTaXplID0gKGluY3JlbnRtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChNYXRoLnNpbihpbmNyZW50bWVudCAtIE1hdGguUEkvMTgwKSAqIDcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMueCA9IChpbmNyZW50bWVudCwgc3RhclNpemUpID0+IHtcbiAgICAgICAgICAgICAgICAvL2Z1bGwgc2NyZWVuIGFuaW1hdGUgY2hhbmdlIHRoaXMucmFuZG9tV2lkdGggYmFjayB0byB3aWR0aCAvIDJcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5jb3MoaW5jcmVudG1lbnQgLSBNYXRoLlBJLzE4MCkgKiAocmFuZG9tU3RhcnQgKyBzdGFyU2l6ZSApXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMueSA9IChpbmNyZW50bWVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNpbigtaW5jcmVudG1lbnQgLSBNYXRoLlBJLzE4MCkgKiAxNjBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5kcmF3ID0gKGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBzID0gdGhpcztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZXQgb3BhY1NwZWVkID0gcy5rICs9IC4zXG4gICAgICAgICAgICAgICAgbGV0IHNwZWVkID0gcy5pICs9IHMucmFuZG9tU3BlZWRcblxuICAgICAgICAgICAgICAgIGxldCByYWRTaXplID0gcy5yYWRTaXplKHNwZWVkKVxuICAgICAgICAgICAgICAgIGxldCBmbGlja2VyID0gcy5GbGlja2VyKG9wYWNTcGVlZClcblxuICAgICAgICAgICAgICAgIGxldCB5ID0gcy55KHNwZWVkKVxuICAgICAgICAgICAgICAgIGxldCB4ID0gcy54KHNwZWVkLCBzLnJhZGl1cylcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSh3aWR0aC8yLCBzLnN0YXJ0LnkpXG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHggLHkgLC40LCB4ICx5ICwxNCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICdMaWdodFNreUJsdWUnKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoLjksICdEb2RnZXJCbHVlJyk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICdSb3lhbEJsdWUnKTtcblxuICAgICAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKVxuICAgICAgICAgICAgICAgIGN0eC5hcmMoeCwgIHksIChzLnJhZGl1cyAtIHJhZFNpemUpIC0gZmxpY2tlciwgMCwgTWF0aC5QSSoyKVxuICAgICAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBncmFkaWVudFxuICAgICAgICAgICAgICAgIGN0eC5maWxsKClcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtd2lkdGgvMiwgLSBzLnN0YXJ0LnkpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVTdGFycyhzdGFyQ291bnQsdXBkYXRlKXtcbiAgICAgICAgICAgIGxldCBkZWxheSA9IDBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFyQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGRlbGF5ICs9IE1hdGgucmFuZG9tKCkgKiB3aWR0aFxuXG4gICAgICAgICAgICAgICAgbGV0IG5pZ2h0U3RhcnMgPSBuZXcgTmlnaHRTdGFycygpXG4gICAgICAgICAgICAgICAgbmlnaHRTdGFycy5yYW5kb21TcGVlZCA9IC4wMDEgKyBNYXRoLnJhbmRvbSgpICogLjAwNlxuICAgICAgICAgICAgICAgIG5pZ2h0U3RhcnMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKVxuICAgICAgICAgICAgICAgIG5pZ2h0U3RhcnMuZHVyYXRpb24gKz0gZGVsYXkgICAvL3NldHMgYSByYW5kb20gZGVsYXkgZm9yIHN0YXJzIHRvIHN0YXJ0XG4gICAgICAgICAgICAgICAgc3RhcnMucHVzaChuaWdodFN0YXJzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlKClcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlKCl7XG4gICAgICAgICAgICAvL1N0b3BwaW5nIHN0YXJzXG4gICAgICAgICAgICBpZih0b2dnbGVTdGFycy50b2dnbGUpe1xuICAgICAgICAgICAgICAgIHN0YXJzLmxlbmd0aCA9IDBcbiAgICAgICAgICAgICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpbmRvdy5pbm5lcldpZHRoLCB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3aW5kb3cuaW5uZXJXaWR0aCwgd2luZG93LmlubmVySGVpZ2h0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IGFsbCA9IHN0YXJzLmxlbmd0aFxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGw7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIGxldCBwZXJjZW50ID0gTWF0aC5taW4oICggRGF0ZS5ub3coKSAtIHN0YXJzW2ldLnN0YXJ0VGltZSApIC8gc3RhcnNbaV0uZHVyYXRpb24sIDEgKSAgLy9EZWxheSB0byBzdGFydCBzdGFyc1xuICAgICAgICAgICAgICAgIGxldCBwZXJjZW50ID0gTWF0aC5taW4oICggRGF0ZS5ub3coKSAtIHN0YXJzW2ldLnN0YXJ0VGltZSApLCAxICkgIC8vIE5vIGRlbGF5XG5cbiAgICAgICAgICAgICAgICBpZihwZXJjZW50ID09PSAxKXtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnNbaV0uZHJhdyhjdHgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHVwZGF0ZSlcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjcmVhdGVTdGFycyxcbiAgICAgICAgICAgIHVwZGF0ZVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcblxuICAgIHZhciB1cGRhdGVUZXh0ID0gKGZ1bmN0aW9uKCl7XG4gXG4gICAgICAgIHZhciB0b2dnbGUgPSB0cnVlXG4gICAgICAgIHZhciB0ZXh0RmllbGQgPSBfKCd0ZXh0LWZpZWxkJylcblxuICAgICAgICBmdW5jdGlvbiBjaGFuZ2VUb2dnbGUoYm9vbGVhbil7XG4gICAgICAgICAgICB0b2dnbGUgPSBib29sZWFuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvZ2dsZUZhbHNlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGNoYW5nZVRvZ2dsZShmYWxzZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVJbWdUZXh0OiBmdW5jdGlvbihpbWcpe1xuXG4gICAgICAgICAgICAgICAgY2hhbmdlVG9nZ2xlKHRydWUpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGltZ1RleHQgPSBpbWcuZ2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldCcpXG4gICAgICAgICAgICAgICAgdmFyIHRleHRMZW5ndGggPSBpbWdUZXh0Lmxlbmd0aFxuXG4gICAgICAgICAgICAgICAgZm9yKHZhciBpID0gMDsgaSA8IHRleHRMZW5ndGg7IGkrKyl7XG5cbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKGkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoIXRvZ2dsZSkgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0RmllbGQudGV4dENvbnRlbnQgKz0gaW1nVGV4dFtpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sMTAwICogaSlcbiAgICAgICAgICAgICAgICAgICAgfSkoaSk7ICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSgpO1xuICAgIFxuXG4gICAgZnVuY3Rpb24gZWxlY3RyaWNCb3goKXtcbiAgICAgICAgdmFyIHJhbmRvbUNpciA9IFswLDEsMiwzLDQsNV1cblxuICAgICAgICBmdW5jdGlvbiBnZXRSYW5kb20obnVtKXtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBNYXRoLmZsb29yKG51bSkpO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGZpbmROdW0oaXRlbSl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBuZXdOdW0gPSByYW5kb21DaXIuc3BsaWNlKGl0ZW0sMSlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXygncm9ib3Qtc3QzNCcpW25ld051bV0uY2xhc3NMaXN0LmFkZCgnYmxpbmsnKVxuICAgICAgICAgICAgaWYocmFuZG9tQ2lyLmxlbmd0aCl7XG4gICAgICAgICAgICAgICByZWxheShyYW5kb21DaXIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmVsYXkoZWwpe1xuICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IGdldFJhbmRvbShlbC5sZW5ndGgtMSlcbiAgICAgICAgICAgICAgICBmaW5kTnVtKGl0ZW0pXG4gICAgICAgICAgICB9LDgwKVxuICAgICAgICB9XG4gICAgICAgIHJlbGF5KHJhbmRvbUNpcilcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2hlY2tGb3JDbGFzc2VzKCl7XG4gICAgICAgIHZhciBjaXJjbGVzID0gXygncm9ib3Qtc3QzNCcpLmxlbmd0aFxuICAgICAgIFxuICAgICAgICAvLyBBZGQgYmxpbmtpbmcgbGlnaHQgY2xhc3Nlc1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNpcmNsZXM7IGkrKykge1xuICAgICAgICAgICAgaWYoIF8oJ3JvYm90LXN0MzQnKVtpXS5jbGFzc0xpc3QuY29udGFpbnMoJ2JsaW5rJykgKXtcblxuICAgICAgICAgICAgICAgIF8oJ3JvYm90LXN0MzQnKVtpXS5jbGFzc0xpc3QucmVtb3ZlKCdibGluaycpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxlY3RyaWNCb3goKVxuICAgIH07XG5cbiAgICAvLyBBZGQgZWxlY3RyaWNpdHkgZm9yIHJvYm90IGJveCBzdG9tYWNoXG4gICAgZnVuY3Rpb24gYWRkRWxlY3RyaWNpdHkoKXtcbiAgICAgICAgdmFyIHBhdGhMZW5ndGggPSBfKCdlbGVjdHJpYy1wYXRoJykubGVuZ3RoXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBfKCdlbGVjdHJpYy1wYXRoJylbaV0uc3R5bGUuc3Ryb2tlRGFzaGFycmF5ID0gMjBcbiAgICAgICAgICAgIF8oJ2VsZWN0cmljLXBhdGgnKVtpXS5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gMjgwXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gMDtcblxuICAgICAgICBmdW5jdGlvbiBkcmF3KHRpbWVzdGFtcCl7XG4gICAgICAgICAgICBpZighc3RhcnQpIHN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgICAgICB2YXIgcnVudGltZSA9IHRpbWVzdGFtcCAtIHN0YXJ0XG4gICAgICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBNYXRoLm1pbihydW50aW1lIC8gMTIwMCwgMSlcbiAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgXygnZWxlY3RyaWMtcGF0aCcpW2ldLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSAyODAgKyAoMjgwICogcHJvZ3Jlc3MpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKHByb2dyZXNzIDwgMSl7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXcpXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBfKCdlbGVjdHJpYy1wYXRoJylbaV0uc2V0QXR0cmlidXRlKCdzdHlsZScsICcnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXcpXG4gICAgfTtcbiAgICBcblxuICAgIC8qKiBPdXR0ZXIgZnVuY3Rpb24gc2NvcGUgdmFyaWFibGVzICoqL1xuICAgIHZhciBkZXNpZ25JbWFnZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdkZXNpZ25JbWFnZXMnKTtcbiAgICB2YXIgaW1nX2NvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2ltYWdlLWNvbnRhaW5lcicpWzBdO1xuXG4gICAgdmFyIGFuaW1hdGVTbGlkZXIgPSB7XG4gICAgICAgIHRhcmdldDogbnVsbCxcbiAgICAgICAgcGFydGlhbERpc3Q6IDAsXG4gICAgICAgIGo6IDAsXG4gICAgICAgIGRpc3Q6IDAsXG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICBpbWFnZXM6IFtdLFxuICAgICAgICBpbWdTdGFydDogMCxcbiAgICAgICAgbmV3U3RhcnQ6IGZ1bmN0aW9uKG51bSl7XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJzZUludCggdGhpcy5pbWFnZXNbbnVtXS5zdHlsZS50cmFuc2Zvcm0ucmVwbGFjZSgvXihbXFx3XSopXFwofChweC4qKSQvaWcsICcnKSApXG5cbiAgICAgICAgfSxcbiAgICAgICAgY29udGFpbmVyV2lkdGg6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQoIGltZ19jb250YWluZXIuc3R5bGUud2lkdGgucmVwbGFjZSgvcHgvaWcsICcnKSApXG4gICAgICAgIH0sXG4gICAgICAgIGNsb25lSW1hZ2U6IGZ1bmN0aW9uKGltZyl7XG4gICAgICAgICAgICBjb25zdCBjbG9uZWRJbWcgPSBpbWcuY2xvbmVOb2RlKHRydWUpXG4gICAgICAgICAgICBjbG9uZWRJbWcuY2xhc3NOYW1lID0gJydcbiAgICAgICAgICAgIGNsb25lZEltZy5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJylcbiAgICAgICAgICAgIGltZ0lubGFyZ2UuY2hlY2tGb3JEdXBsaWNhdGVzKCdkZXNpZ25WaXNpYmxlJylcbiAgICAgICAgICAgIGltZ0lubGFyZ2UubW92ZUVsZW1lbnQoY2xvbmVkSW1nLCAnZGVzaWduVmlzaWJsZScpXG4gICAgICAgIH0sXG4gICAgICAgIGRyYXc6IGZ1bmN0aW9uKHRpbWVzdGFtcCl7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmKCF0aGlzLnN0YXJ0KSB0aGlzLnN0YXJ0ID0gdGltZXN0YW1wXG5cbiAgICAgICAgICAgIHZhciBydW50aW1lID0gdGltZXN0YW1wIC0gdGhpcy5zdGFydFxuICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gTWF0aC5taW4ocnVudGltZSAvIDcwMCwgMSlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5pbWFnZXNbMF0uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnKyAodGhpcy5pbWdTdGFydCAtICh0aGlzLmRpc3QqcHJvZ3Jlc3MpICkrJ3B4LCAtNTAlKSdcbiAgICAgICAgICAgXG4gICAgICAgICAgICBpZihwcm9ncmVzcyA9PT0gMSl7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLy9TZWNvbmQgcGhvdG8gZm9sbG93aW5nIHRoZSBmaXJzdCB0byBiZSBhbmltYXRlZCBhdXRvbWF0aWNhbGx5XG4gICAgICAgICAgICAgICAgaWYodGhpcy5qID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrcyBpZiBsZWZ0IG9yIHJpZ2h0IGJ1dHRvbiBjbGljayB3aXRoIGEgbmVnYXRpdmUgbGVmdCBvciBwb3NpdGl2ZSByaWdodCBhbmQgdXBkYXRlcyBpbWdTdGFydFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmltZ1N0YXJ0ID0gdGhpcy5kaXN0IDwgMCA/IC10aGlzLmNvbnRhaW5lcldpZHRoKCkgOiB0aGlzLmNvbnRhaW5lcldpZHRoKClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0ID0gdGhpcy5kaXN0IDwgMCA/IC10aGlzLmNvbnRhaW5lcldpZHRoKCkgOiB0aGlzLmNvbnRhaW5lcldpZHRoKClcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydCA9IDBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLmltYWdlcy5zaGlmdCgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzLnB1c2goaXRlbSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5qID0gMFxuICAgICAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgLy9Vc2VyIGRvdWJsZSBjbGlja3Mgc2FtZSBidXR0b24gd2hlbiAybmQgaW1hZ2UgaXNuJ3QgZmluaXNoZWQgaXQgZHJhd3MgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgaWYodGhpcy5pbWdTdGFydCAhPT0gdGhpcy5kaXN0ICl7XG4gICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXcoKVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9TdG9wcyB0eXBlZCB0ZXh0IGZyb20gcnVubmluZyBvbmx5IHdoZW4gcGhvdG8gc3RvcHMgaW50byBwbGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgXygndGV4dC1maWVsZCcpLnRleHRDb250ZW50ID0gJydcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRleHQudXBkYXRlSW1nVGV4dCh0aGlzLmltYWdlc1swXSkgLy9TdGFydHMgdGhlIHR5cGVkIHRleHQgZnVuY3Rpb25cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9uZUltYWdlKHRoaXMuaW1hZ2VzWzBdKSBcbiAgICAgICAgICAgICAgICAgICAgfSBcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaisrXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGVTbGlkZXIuZHJhdy5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgYW5pbWF0ZURhdGE6IGZ1bmN0aW9uKGUpeyAgIFxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IHRoaXMudGFyZ2V0LmlubmVyVGV4dFxuICAgICAgICAgICAgdmFyIG5ld1N0YXJ0ID0gdGhpcy5uZXdTdGFydCgwKVxuICAgICAgICAgICAgdGhpcy5wYXJ0aWFsRGlzdCA9IG5ld1N0YXJ0XG5cbiAgICAgICAgICAgIC8vSWYgdXNlciBjbGlja3MgYmVmb3JlIGltYWdlIGRvbmUgYW5pbWF0aW5nLCB1cGRhdGVzIGN1cnJlbnQgbG9jYXRpb24gYW5kIHN0YXJ0cyBhZ2FpblxuICAgICAgICAgICAgaWYobmV3U3RhcnQgIT09IDAgJiYgIWlzTmFOKG5ld1N0YXJ0KSl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYodGFyZ2V0ID09PSAnPCcpe1xuICAgICAgICAgICAgICAgICAgICAvL0lmIHVzZXIgZG91YmxlIGNsaWNrcyBzYW1lIGJ1dHRvbiByaWdodCBhd2F5XG4gICAgICAgICAgICAgICAgICAgIGlmKG5ld1N0YXJ0IDwgMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltZ1N0YXJ0ID0gbmV3U3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdCA9IHRoaXMuY29udGFpbmVyV2lkdGgoKSArIG5ld1N0YXJ0XG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5qID0gMCAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0ID0gbmV3U3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW1nU3RhcnQgPSBuZXdTdGFydFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmKHRhcmdldCA9PT0gJz4nKXtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmKG5ld1N0YXJ0IDwgMCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmogPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltZ1N0YXJ0ID0gbmV3U3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdCA9IG5ld1N0YXJ0XG4gICAgICAgICAgICAgICAgICAgIC8vSWYgdXNlciBkb3VibGUgY2xpY2tzIHNhbWUgYnV0dG9uIHJpZ2h0IGF3YXlcbiAgICAgICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmltZ1N0YXJ0ID0gbmV3U3RhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdCA9IC10aGlzLmNvbnRhaW5lcldpZHRoKCkgKyBuZXdTdGFydFxuICAgICAgICAgICAgICAgICAgICB9ICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQgPSAwXG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0ID0gMFxuXG4gICAgICAgICAgICAgICAgaWYodGFyZ2V0ID09PSAnPCcpe1xuICAgICAgICAgICAgICAgICAgICAvL2ZpcnN0IGNsaWNrIHN0YXJ0cyBpbWFnZSBvdXRzaWRlIHRoZSBoZWFkXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaiA+PSAxID8gdGhpcy5pbWdTdGFydCA9IDAgOiB0aGlzLmltZ1N0YXJ0ID0gdGhpcy5jb250YWluZXJXaWR0aCgpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdCA9IHRoaXMuY29udGFpbmVyV2lkdGgoKVxuICAgICAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy9maXJzdCBjbGljayBzdGFydHMgaW1hZ2Ugb3V0c2lkZSB0aGUgaGVhZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmogPj0gMSA/IHRoaXMuaW1nU3RhcnQgPSAwIDogdGhpcy5pbWdTdGFydCA9IC10aGlzLmNvbnRhaW5lcldpZHRoKClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0ID0gLXRoaXMuY29udGFpbmVyV2lkdGgoKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuZHJhdygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGxvYWQgaW1hZ2VzIGludG8gYXJyYXkgdG8gYmUgdXNlZCBmb3Igc2xpZGVyXG4gICAgICAgIGxvYWRJbWFnZXM6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlc2lnbkltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gZGVzaWduSW1hZ2VzW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuaW1hZ2VzLnB1c2goZWxlbWVudClcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBLZWVwcyBmcm9tIHJlc2l6ZSBldmVudCBsb2FkaW5nIGNsaWNrIGhhbmRsZXJcbiAgICBpZihlLnR5cGUgIT09ICdyZXNpemUnICYmIGUudHlwZSAhPT0gJ3Njcm9sbCcpe1xuICAgICAgICBcbiAgICAgICAgXygnYnRuQ29udGFpbmVyJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgICAgICAgIGFuaW1hdGVTbGlkZXIudGFyZ2V0ID0gZS50YXJnZXRcbiAgICAgICAgICAgIGFuaW1hdGVTbGlkZXIuYW5pbWF0ZURhdGEoZSlcblxuICAgICAgICAgICAgY2hlY2tGb3JDbGFzc2VzKClcbiAgICAgICAgICAgIGFkZEVsZWN0cmljaXR5KClcbiAgICAgICAgICAgIHVwZGF0ZVRleHQudG9nZ2xlRmFsc2UoKVxuICAgICAgICAgICAgXygndGV4dC1maWVsZCcpLnRleHRDb250ZW50ID0gJydcbiAgICAgICAgICAgIFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIFthbmltYXRlU2xpZGVyLCBhbmltYXRlU3RhcnNdIC8vIFRvIGJlIHVzZWQgaW4gdGhlIHdpbmRvdy5vbmxvYWQgc2VjdGlvblxufTtcblxuXG5mdW5jdGlvbiBEZXNpZ25TbGlkZXIoKSB7XG4gICAgdmFyIGltZ19jb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdpbWFnZS1jb250YWluZXInKVswXVxuICAgIHZhciBpbWdfY29udGFpbmVyX3JlY3QgPSBpbWdfY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgdGhpcy5lbGxpcHNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnY2xpcC1lbGxpcHNlJylbMF1cbiAgICB0aGlzLnJlYyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3NjcmVlbi1wYXRoJylbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICB0aGlzLnNlY3Rpb25Db250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzZWN0aW9uLXRocmVlLXJvYm90JylbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICAgIHZhciBhY3R1YWxUb3AgPSB0aGlzLnJlYy50b3AgLSB0aGlzLnNlY3Rpb25Db250YWluZXIudG9wIC8vd2hlbiBwYWdlIG5vdCBmdWxseSBzY3JvbGxlZCBpbnRvIHZpZXcgaXQncyB0aGUgYWN0dWFsIHRvcFxuICAgXG4gICAgdGhpcy5zZXRFbGxpcHNlQXR0cmlidXRlcyA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuZWxsaXBzZS5zZXRBdHRyaWJ1dGUoJ3J4JywgdGhpcy5yZWMud2lkdGgvMilcbiAgICAgICAgdGhpcy5lbGxpcHNlLnNldEF0dHJpYnV0ZSgncnknLCB0aGlzLnJlYy5oZWlnaHQvMilcbiAgICAgICAgdGhpcy5lbGxpcHNlLnNldEF0dHJpYnV0ZSgnY3gnLCB0aGlzLnJlYy5sZWZ0ICsgdGhpcy5yZWMud2lkdGgvMiAtIDUpXG4gICAgICAgIHRoaXMuZWxsaXBzZS5zZXRBdHRyaWJ1dGUoJ2N5JywgYWN0dWFsVG9wICsgdGhpcy5yZWMuaGVpZ2h0LzIgKVxuICAgIH1cbiAgICB0aGlzLnNldEltZ0NvbnRhaW5lciA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciBjb250YWluZXJfV2lkdGggPSB0aGlzLnJlYy53aWR0aCAvIDkgKyB0aGlzLnJlYy53aWR0aFxuICAgICAgICB2YXIgaW1nX2NvbnRhaW5lclkgPSBhY3R1YWxUb3AgLSAoaW1nX2NvbnRhaW5lcl9yZWN0LmhlaWdodCAtIHRoaXMucmVjLmhlaWdodCkgLyAyXG4gICAgICAgIGltZ19jb250YWluZXIuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgtNTAlLCcgKyBpbWdfY29udGFpbmVyWSArICdweCknICAvLy00OCUgdG8gbWFrZSB1cCBmb3IgNTMlIHJvYm90LXN2ZyBvZmZzZXRcbiAgICAgICAgaW1nX2NvbnRhaW5lci5zdHlsZS53aWR0aCA9IGNvbnRhaW5lcl9XaWR0aCArICdweCdcbiAgICB9XG4gICAgdGhpcy5zZXRCdXR0b25Mb2NhdGlvbiA9IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgdmFyIGFkZGVkV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCA8IDc2OCA/IDcwIDogMjAwICAvL0Rpc3RhbmNlIGJpZ2dlciB0aGFuIHJvYm90IGhlYWRcblxuICAgICAgICB2YXIgeCA9ICAoIHdpbmRvdy5pbm5lcldpZHRoIC0gKHRoaXMucmVjLndpZHRoICsgYWRkZWRXaWR0aCkgKSAvIDJcbiAgICAgICAgdmFyIHkgPSB3aW5kb3cuaW5uZXJXaWR0aCA+IDc2OCA/IGFjdHVhbFRvcCArICggdGhpcy5yZWMuaGVpZ2h0IC8gMiApIC0gMjUgOiB0aGlzLnJlYy5ib3R0b20gLSB0aGlzLnNlY3Rpb25Db250YWluZXIudG9wIC8vIC0gMjUgZm9yIHRoZSBidG5Db250YWluZXIgaGVpZ2h0IC8gMlxuXG4gICAgICAgIF8oJ2J0bkNvbnRhaW5lcicpLnN0eWxlLndpZHRoID0gdGhpcy5yZWMud2lkdGggKyBhZGRlZFdpZHRoICsncHgnXG4gICAgICAgIF8oJ2J0bkNvbnRhaW5lcicpLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJysgeCArICdweCwnICsgeSArICdweCknXG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpe1xuXG4gICAgICAgIHJldHVybiBbdGhpcy5zZXRFbGxpcHNlQXR0cmlidXRlcygpLHRoaXMuc2V0SW1nQ29udGFpbmVyKCksdGhpcy5zZXRCdXR0b25Mb2NhdGlvbigpXVxuXG4gICAgfS5iaW5kKHRoaXMpXG59XG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLGZ1bmN0aW9uKGUpe1xuXG4gICAgdmFyIHVwZGF0ZVJvYm90ID0gcm9ib3RTZWN0aW9uKGUpXG5cbiAgICB2YXIgZGVzaWduU2xpZGVyID0gbmV3IERlc2lnblNsaWRlcigpXG4gICAgZGVzaWduU2xpZGVyKCkgIC8vdXBkYXRlcyBjYW52YXMgc2l6ZVxuICAgIHVwZGF0ZVJvYm90WzFdKCkgIC8vdXBkYXRlcyBidXR0b24sIGltYWdlIGxvY2F0aW9uICwgYXR0cmlidXRlcyBvZiByb2JvdFxufSk7XG5cbi8vICoqKiogQVNTRU1CTFkgTElORSBTRUNUSU9OICoqKipcblxuY2xhc3MgQXNzZW1ibHlMaW5lIHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLm1haW5TVkcgPSBfKCdhc3NlbWJseS1saW5lLXN2ZycpXG4gICAgICAgIHRoaXMuc2xpZGVycyA9IF8oJ3JvbGxlcl91bml0JylcbiAgICAgICAgdGhpcy5jb2RlQ29udGFpbmVycyA9IF8oJ2NvZGUtY29udGFpbmVyJylcbiAgICB9XG4gICAgXG4gICAgZ2V0UmVjdChlbCl7XG4gICAgICAgIGxldCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgICAgbGV0IGJCb3ggPSBlbC5nZXRCQm94KClcbiAgICAgICAgcmV0dXJuIHtyZWN0LCBiQm94fVxuICAgIH1cbiAgICBcbiAgICBnZXRFbGVtVmFsdWUocG9zKSB7XG4gICAgICAgIGNvbnN0IFtzaXplXSA9IC9bMS05XS4qLy5leGVjKCB0aGlzLm1haW5TVkcuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykgKVxuICAgICAgICBjb25zdCByZWdFeCA9IC9eKFxcZHs0fSlcXHMoXFxkezN9KSQvaWc7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdXG4gICAgICAgIHZhbHVlcy5sZW5ndGggPSAwICBcbiAgICAgICAgbGV0IGxlbmd0aCA9IHRoaXMuc2xpZGVycy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHJvbGxlclVuaXQgPSB0aGlzLnNsaWRlcnNcbiAgICAgICAgY29uc3QgY29kZUVsZW1lbnRzID0gdGhpcy5jb2RlQ29udGFpbmVyc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByb2xsZXJFbGVtID0gcm9sbGVyVW5pdFtpXVxuICAgICAgICAgICAgY29uc3QgY29kZUVsZW0gPSBjb2RlRWxlbWVudHNbaV1cbiAgICAgICAgXG4gICAgICAgICAgICBzd2l0Y2ggKHBvcykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbnRhaW5lcic6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzbGlkZXJzQ29udGFpbmVyXG4gICAgICAgICAgICAgICAgY2FzZSAndmlld0JveFdpZHRoJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpemUucmVwbGFjZShyZWdFeCwgJyQxJylcbiAgICAgICAgICAgICAgICBjYXNlICd2aWV3Qm94SGVpZ2h0JzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpemUucmVwbGFjZShyZWdFeCwgJyQyJylcbiAgICAgICAgICAgICAgICBjYXNlICdlbCc6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKHJvbGxlckVsZW0pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JlY3RYJzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goIHRoaXMuZ2V0UmVjdCggcm9sbGVyRWxlbSApLnJlY3QueCApIC8vIG5vdCBpbiB1c2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29kZUJveC54JzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goIHRoaXMuZ2V0UmVjdCggY29kZUVsZW0gKS5yZWN0LnggKSBcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29kZWJCb3gueCc6ICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKCB0aGlzLmdldFJlY3QoIGNvZGVFbGVtICkuYkJveC54ICkgXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JCb3hYJzogICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goIHRoaXMuZ2V0UmVjdCggcm9sbGVyRWxlbSApLmJCb3gueCApLy8gbm90IGluIHVzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd5JzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goIHRoaXMuZ2V0UmVjdCggcm9sbGVyRWxlbSApLmJCb3gueSApICAgXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2goIHRoaXMuZ2V0UmVjdCggcm9sbGVyRWxlbSApLmJCb3gud2lkdGggKSAgIFxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoZWlnaHQnOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXMucHVzaCggdGhpcy5nZXRSZWN0KCByb2xsZXJFbGVtICkuYkJveC5oZWlnaHQgKVxuICAgICAgICAgICAgICAgICAgICBicmVhazsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlc1xuICAgIH1cbn07XG5cbmNsYXNzIFJvbGxlclVuaXQgZXh0ZW5kcyBBc3NlbWJseUxpbmUge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5nZXRSZWN0ID0gdGhpcy5nZXRSZWN0XG4gICAgICAgIHRoaXMuZHJhdyA9IHRoaXMuZHJhdy5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMuYmVnaW5Qb3MgPSBbXVxuICAgICAgICB0aGlzLmRpc3QgPSBbXVxuICAgICAgICB0aGlzLmxlc3NUaGFuID0gJydcbiAgICAgICAgdGhpcy5zdGFydCA9IDBcbiAgICAgICAgdGhpcy50aW1lID0gMTAwMFxuICAgICAgICB0aGlzLmN1cnJlbnQgPSB7fVxuICAgICAgICB0aGlzLmNsaWNrID0gMFxuICAgICAgICB0aGlzLmJlbHRDbGljayA9IDBcbiAgICAgICAgdGhpcy5mb3JlaW5PYmpzID0gXygnYXNzZW1ibHktaW1nLWZvcmVpZ25PYmonKVxuICAgICAgICB0aGlzLmZvcmVpbkdyb3VwID0gXygnYXNzZW1ibHktaW1nLXdyYXAnKVxuICAgICAgICB0aGlzLmJlbHRzID0gXygnYmVsdCcpXG4gICAgfVxuXG4gICAgc3RhcnRQb3MoZWxlbSl7XG4gICAgICAgIGxldCBhcnIgPSBbXVxuICAgICAgICBsZXQgZWwgPSBlbGVtXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGVsLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCBlbFtpXS5oYXNBdHRyaWJ1dGUoJ3N0eWxlJykgKXtcbiAgICAgICAgICAgICAgICBhcnIucHVzaCggcGFyc2VJbnQgKCBlbFtpXS5zdHlsZS50cmFuc2Zvcm0ucmVwbGFjZSgvXihbXFx3XSopXFwoKFs/LVxcZF0uKilweFxcKS9pZywgXCIkMlwiKSApIClcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGFyci5wdXNoKDApIFxuICAgICAgICAgICAgfSAgXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFyclxuICAgIH1cblxuICAgIG1pbiggc3RhcnQsYWN0dWFsID0gW10pe1xuICAgICAgICBsZXQgcmVjdCA9IE1hdGgubWluKC4uLnN0YXJ0KVxuICAgICAgICBsZXQgZGlzdCA9IE1hdGgubWluKC4uLmFjdHVhbClcbiAgICAgICAgbGV0IGluZGV4ID0gc3RhcnQuaW5kZXhPZihyZWN0KVxuICAgICAgICByZXR1cm4ge2luZGV4LGRpc3R9ICAgICAgICAgXG4gICAgfVxuICAgIG1heCggc3RhcnQsYWN0dWFsICl7XG4gICAgICAgIGxldCByZWN0ID0gTWF0aC5tYXgoLi4uc3RhcnQpXG4gICAgICAgIGxldCBkaXN0ID0gTWF0aC5tYXgoLi4uYWN0dWFsKVxuICAgICAgICBsZXQgaW5kZXggPSBzdGFydC5pbmRleE9mKHJlY3QpXG4gICAgICAgIHJldHVybiB7aW5kZXgsZGlzdH1cbiAgICB9XG5cbiAgICBnZXREaXN0YW5jZSgpe1xuICAgICAgICBsZXQgd2lkdGggPSB0aGlzLmdldEVsZW1WYWx1ZSgnd2lkdGgnKVswXVxuICAgICAgICBsZXQgYXJyID0gW11cbiAgICAgICAgbGV0IHN0YXJ0aW5nUG9pbnQgPSB0aGlzLmdldEVsZW1WYWx1ZSgnY29kZUJveC54JylcbiAgICAgICAgbGV0IGFjdHVhbERpc3QgPSB0aGlzLmdldEVsZW1WYWx1ZSgnY29kZWJCb3gueCcpXG4gICAgXG4gICAgICAgIGNvbnN0IG1heEVsZW1lbnQgPSB0aGlzLm1heChzdGFydGluZ1BvaW50LGFjdHVhbERpc3QpXG4gICAgICAgIGNvbnN0IG1pbkVsZW1lbnQgPSB0aGlzLm1pbihzdGFydGluZ1BvaW50LGFjdHVhbERpc3QpXG5cbiAgICAgICAgY29uc3QgbW92ZUVuZCA9IChrKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGlzdCA9IHRoaXMubGVmdCA/IDQzMSA6IC00MzEgIC8vIG1vdmVCZWdpbm5pbmcgZGlzdCAqIDIgICAgXG4gICAgICAgICAgICBhcnIucHVzaCh7ZGlzdDogZGlzdCwgaW5kZXg6IGssIH0pXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBtb3ZlQmVnaW5uaW5nID0gKGspID0+IHtcbiAgICAgICAgICAgIGxldCBkaXN0ID0gdGhpcy5sZWZ0ID8gKG1pbkVsZW1lbnQuZGlzdCArIHdpZHRoKSA6IC0obWluRWxlbWVudC5kaXN0ICsgd2lkdGgpIFxuICAgICAgICAgICAgbGV0IHJpZ2h0UGFnZVN0YXJ0ID0gdGhpcy5sZWZ0ID8gYWN0dWFsRGlzdC5yZXZlcnNlKClba10gKyB3aWR0aCA6IC1hY3R1YWxEaXN0W2tdIC0gd2lkdGhcbiAgICAgICAgXG4gICAgICAgICAgICB0aGlzLmxlc3NUaGFuID0gayAgLy9VcGRhdGVzIHRoZSBzbWFsbGVzdCBkaXN0YW5jZVxuICAgICAgICAgICAgYXJyLnB1c2goe2Rpc3Q6IGRpc3QqMixpbmRleDogaywgcmlnaHRQYWdlU3RhcnQ6IHJpZ2h0UGFnZVN0YXJ0LCBwYWdlUmlnaHQ6IHRydWV9KVxuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGxldCBrID0gMDsgayA8IDM7IGsrKyApe1xuICAgIFxuICAgICAgICAgICAgaWYgKCBtaW5FbGVtZW50LmluZGV4ID09PSBrICkge1xuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQgPyBtb3ZlRW5kKGspIDogbW92ZUJlZ2lubmluZyhrKSAgICAgICBcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1lbHNlIGlmKCBtYXhFbGVtZW50LmluZGV4ID09PSBrICkge1xuICAgICAgICAgICAgICAgIHRoaXMucmlnaHQgPyBtb3ZlQmVnaW5uaW5nKGspIDogIG1vdmVFbmQoaylcblxuICAgICAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBkaXN0ID0gdGhpcy5sZWZ0ID8gNDMxIDogLTQzMSAgLy8gbW92ZUJlZ2lubmluZyBkaXN0ICogMlxuICAgICAgICAgICAgICAgIGFyci5wdXNoKHtkaXN0OiBkaXN0LCBpbmRleDoga30pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXJyLnNvcnQgPSAoYSxiKSA9PiBhLnBsYWNlIC0gYi5wbGFjZVxuICAgICAgICByZXR1cm4gYXJyXG4gICAgfVxuXG4gICAgLy8gQWRkIGFuZCByZW1vdmUgZm9yZWlnbk9iamVjdHMgaW50byBzbGlkZXJcbiAgICBmb3JlaW5PYmpBcnIoKXtcbiAgICAgICAgLy8gbGV0IGxlbmd0aCA9ICB0aGlzLmZvcmVpbk9ianMubGVuZ3RoXG4gICAgICAgIGxldCBsZW5ndGggPSAgdGhpcy5mb3JlaW5Hcm91cC5sZW5ndGhcbiAgICAgICAgbGV0IGFyciA9IG5ldyBBcnJheShsZW5ndGgpXG5cbiAgICAgICAgLy8gUHV0cyBpbWFnZSBmb3JlaWdub2JqZWN0cyBpbnRvIGFycmF5XG4gICAgICAgIHdoaWxlKGxlbmd0aCkge1xuICAgICAgICAgICAgbGVuZ3RoLS07XG4gICAgICAgICAgICBhcnJbbGVuZ3RoXSA9IHRoaXMuZm9yZWluR3JvdXBbbGVuZ3RoXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBzdGFydGluZ1BvaW50ID0gdGhpcy5nZXRFbGVtVmFsdWUoJ2NvZGVCb3gueCcpXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMubWluKHN0YXJ0aW5nUG9pbnQpLmluZGV4XG4gICAgICAgIFxuICAgICAgICBsZXQgYWRkID0gYXJyLnNwbGljZSgzLDEpXG4gICAgICAgIGxldCByZW1vdmVkID0gYXJyLnNwbGljZShpbmRleCwxKVxuXG4gICAgICAgIGxldCByZW1vdmVkQ2hpbGQgPSByZW1vdmVkWzBdLmNoaWxkTm9kZXNbMV1cbiAgICAgICAgbGV0IGFkZENoaWxkID0gYWRkWzBdLmNoaWxkTm9kZXNbMV1cbiAgICAgICAgYXJyLnNwbGljZShpbmRleCwwLGFkZFswXSlcbiAgICAgICAgYXJyLnB1c2gocmVtb3ZlZFswXSlcblxuICAgICAgICAvL0FkZCBhbmQgcmVtb3ZlIGp1c3QgdHJhbnNmb3JtcyBmaXJzdFxuICAgICAgICBsZXQgc3R5bGVUcmFuc2Zvcm0gPSAgcmVtb3ZlZFswXS5hdHRyaWJ1dGVzWzFdXG4gICAgICAgIHJlbW92ZWRbMF0ucmVtb3ZlQXR0cmlidXRlKCBzdHlsZVRyYW5zZm9ybS5uYW1lKSBcbiAgICAgICAgYWRkWzBdLnNldEF0dHJpYnV0ZShzdHlsZVRyYW5zZm9ybS5uYW1lLCBzdHlsZVRyYW5zZm9ybS52YWx1ZSkgICAgIFxuXG4gICAgICAgIC8vU3RyaXBzIGF0dHJpYnV0ZXMgb2YgcmVtb3ZlZCBhbmQgYWRkIHNhbWUgYXR0cmlidXRlcyB0byBhZGRlZCBmb3JlaWdub2JqZWN0XG4gICAgICAgIHdoaWxlKCByZW1vdmVkQ2hpbGQuYXR0cmlidXRlcy5sZW5ndGggPiAxKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGxldCBhdHRyTmFtZSA9ICByZW1vdmVkQ2hpbGQuYXR0cmlidXRlc1sxXS5uYW1lIFxuICAgICAgICAgICAgbGV0IGF0dHJWYWx1ZSA9ICByZW1vdmVkQ2hpbGQuYXR0cmlidXRlc1sxXS52YWx1ZSBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYWRkQ2hpbGQuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpXG4gICAgICAgICAgICByZW1vdmVkQ2hpbGQucmVtb3ZlQXR0cmlidXRlKCByZW1vdmVkQ2hpbGQuYXR0cmlidXRlc1sxXS5uYW1lKVxuICAgICAgICB9IFxuICAgICAgICBcbiAgICAgICAgdGhpcy5mb3JlaW5Hcm91cCA9IGFyclxuICAgIH1cbiAgICBcbiAgICAvLyBSYW4gb25jZSB3aGVuIHBhZ2UgcmVsb2Fkc1xuICAgIHBvc2l0aW9uRm9yaWVnbk9iamVjdChfdGhpcyl7XG4gICAgICAgIGxldCBzbGlkZXJzID0gdGhpcy5jb2RlQ29udGFpbmVyc1xuICAgICAgICBsZXQgZm9yZWlnbk9iamVjdHMgPSB0aGlzLmZvcmVpbk9ianNcbiAgICAgICAgbGV0IGxlbmd0aCA9IHNsaWRlcnMubGVuZ3RoXG4gICAgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGV0IHNsaWRlcl94ID0gdGhpcy5nZXRSZWN0KHRoaXMuY29kZUNvbnRhaW5lcnNbaV0pLmJCb3gueFxuICAgICAgICAgICAgbGV0IHNsaWRlcl95ID0gdGhpcy5nZXRSZWN0KHRoaXMuY29kZUNvbnRhaW5lcnNbaV0pLmJCb3gueVxuICAgICAgICAgICAgbGV0IHNsaWRlcl93aWR0aCA9IHRoaXMuZ2V0UmVjdCh0aGlzLmNvZGVDb250YWluZXJzW2ldKS5iQm94LndpZHRoXG4gICAgICAgICAgICBsZXQgc2xpZGVyX2hlaWdodCA9IHRoaXMuZ2V0UmVjdCh0aGlzLmNvZGVDb250YWluZXJzW2ldKS5iQm94LmhlaWdodFxuICAgIFxuICAgICAgICAgICAgZm9yZWlnbk9iamVjdHNbaV0uc2V0QXR0cmlidXRlKCd4Jywgc2xpZGVyX3gpXG4gICAgICAgICAgICBmb3JlaWduT2JqZWN0c1tpXS5zZXRBdHRyaWJ1dGUoJ3knLCBzbGlkZXJfeSlcbiAgICAgICAgICAgIGZvcmVpZ25PYmplY3RzW2ldLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBzbGlkZXJfd2lkdGgpXG4gICAgICAgICAgICBmb3JlaWduT2JqZWN0c1tpXS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHNsaWRlcl9oZWlnaHQpXG4gICAgICAgIH1cbiAgICAgICAgLy9JbnB1dHMgaW1hZ2UgaW50byBjb250YWluZXJcbiAgICAgICAgX3RoaXMudGFyZ2V0RWxlbSgpXG4gICAgfVxuICAgIFxuICAgIFxuICAgIG1vcmVUaGFuSGFsZiggZGlzdCwgcG9zaXRpdmVDdXJyZW50LCBzdGFydERpc3QgKXtcbiAgICAgICAgcmV0dXJuIGRpc3QgLSAoc3RhcnREaXN0IC0gcG9zaXRpdmVDdXJyZW50KVxuICAgIH1cbiAgICBcbiAgICBsZXNzVGhhbkhhbGYoY3VycmVudCwgZGlzdCwgc3RhcnREaXN0KXtcbiAgICAgICAgbGV0IGQgPSBkaXN0LmRpc3QgPCAwID8gZGlzdC5kaXN0ICogLTEgOiBkaXN0LmRpc3RcblxuICAgICAgICBpZihzdGFydERpc3QgPT09IDAgKXtcbiAgICAgICAgICAgIGlmKGRpc3QucmlnaHRQYWdlU3RhcnQpe1xuICAgICAgICAgICAgICAgIGxldCBkaWZmID0gY3VycmVudCAtIHN0YXJ0RGlzdCBcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxEaWZmID0gZCAtICAoY3VycmVudCAtIHN0YXJ0RGlzdClcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiArIHRvdGFsRGlmZlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGQgLSBjdXJyZW50XG4gICAgICAgICAgICBcbiAgICAgICAgfWVsc2Uge1xuICAgICAgICAgICAgaWYoZGlzdC5yaWdodFBhZ2VTdGFydCl7XG4gICAgICAgICAgICAgICAgbGV0IGRpZmYgPSBjdXJyZW50IC0gc3RhcnREaXN0IFxuICAgICAgICAgICAgICAgIGxldCB0b3RhbERpZmYgPSBkIC0gIE1hdGguYWJzKGN1cnJlbnQgLSBzdGFydERpc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgKyB0b3RhbERpZmZcbiAgICAgICAgICAgIH0gIFxuICAgICAgICAgICAgbGV0IGRpZmYgPSBkIC0gTWF0aC5hYnMoY3VycmVudCAtIHN0YXJ0RGlzdClcbiAgICAgICAgICAgIHJldHVybiBkaWZmXG4gICAgICAgIH1cbiAgICB9XG4gICAgb3BwaXNpdGVEaXIoY3VycmVudCwgc3RhcnREaXN0KXtcbiAgICAgICAgaWYoc3RhcnREaXN0ID09PSAwKXtcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50XG4gICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgIGlmKGN1cnJlbnQgPiBzdGFydERpc3QpeyAvLyBtb3JlIHRoYW4gaGFsZlxuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50IC0gc3RhcnREaXN0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhcnREaXN0IC0gY3VycmVudCAgIC8vbGVzcyB0aGFuIGhhbGYgICAgXG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlUmlnaHRQYWdlU3RhcnQoZCxyaWdodFBhZ2VTdGFydCwgcG9zQ3VycmVudCwgc3RhcnREaXN0KXtcbiAgICBcbiAgICAgICAgaWYoc3RhcnREaXN0IDwgMCl7XG4gICAgICAgICAgICAvL21vcmUgdGhhbiBoYWxmXG4gICAgICAgICAgICBpZihkID4gcG9zQ3VycmVudCl7ICBcbiAgICAgICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSBwb3NDdXJyZW50XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtkaXN0YW5jZSwgcGFnZVJpZ2h0OiBmYWxzZX0gXG4gICAgICAgICAgICAvL2xlc3MgdGhhbiBoYWxmXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGlmZmVyZW5jZSA9ICgxMTQxLjIgLSBwb3NDdXJyZW50KSBcbiAgICAgICAgICAgIGxldCB0b3RhbERpZiA9IGQgLSAoMTE0MS4yIC0gcG9zQ3VycmVudClcbiAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IGRpZmZlcmVuY2UgKyB0b3RhbERpZlxuICAgICAgICAgICAgcmV0dXJuIHtkaXN0YW5jZSwgcGFnZVJpZ2h0OiB0cnVlfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy9sZXNzIHRoYW4gaGFsZiBvbmx5IGVsZW1lbnQgd2l0aCBhIHJpZ2h0UGFnZVN0YXJ0IG9mIDExNDEuMlxuICAgICAgICAgICAgaWYocmlnaHRQYWdlU3RhcnQgPiAxMTYwKXsgLy8xMTYwXG4gICAgICAgICAgICAgICAgbGV0IGRpZmZlcmVuY2UgPSBkIC8gMiAtIHBvc0N1cnJlbnRcbiAgICAgICAgICAgICAgICBsZXQgdG90YWxEaWYgPSBkIC0gIGRpZmZlcmVuY2VcbiAgICAgICAgICAgICAgICBsZXQgZGlzdGFuY2UgPSB0b3RhbERpZiArIGRpZmZlcmVuY2VcbiAgICAgICAgICAgICAgICByZXR1cm4ge2Rpc3RhbmNlLCBwYWdlUmlnaHQ6IHRydWV9XG4gICAgICAgICAgICAvL21vcmUgdGhhbiBoYWxmXG4gICAgICAgICAgICB9ZWxzZSBpZihwb3NDdXJyZW50IDwgc3RhcnREaXN0ICl7IFxuICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IHN0YXJ0RGlzdCAtIHBvc0N1cnJlbnQgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtkaXN0YW5jZSwgcGFnZVJpZ2h0OiBmYWxzZSB9XG4gICAgICAgICAgICAvL2xlc3MgdGhhbiBoYWxmIFxuICAgICAgICAgICAgfWVsc2V7ICBcbiAgICAgICAgICAgICAgICBsZXQgZGlmZiA9IHBvc0N1cnJlbnQgLSBzdGFydERpc3QgXG4gICAgICAgICAgICAgICAgbGV0IHRvdGFsRGlmZiA9IGQgLSAgKHBvc0N1cnJlbnQgLSBzdGFydERpc3QpXG4gICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gZGlmZiArIHRvdGFsRGlmZlxuICAgICAgICAgICAgICAgIHJldHVybiB7ZGlzdGFuY2UsIHBhZ2VSaWdodDogdHJ1ZX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAqKiBSSUdIVCBCVVRUT04gSVMgTkVHQVRJVkUgRElTVCwgTEVGVCBCVVRUT04gSVMgUE9TSVRJVkUgRElTVCoqXG4gICAgaGFuZGxlRG91YmxlQ2xpY2soY3VycmVudCwgZGlzdCwgYmVnaW5Qb3Mpe1xuICAgICAgICAvL1VwZGF0ZXMgaG93IG1hbnkgdGltZXMgYmFjayBhbmQgZm9ydGggYmVmb3JlIGFuaW1hdGlvbiBmaW5pc2hlc1xuICAgICAgICB0aGlzLmNsaWNrICsrXG5cbiAgICAgICAgbGV0IGN1cnJlbnREaXJlY3Rpb24gPSBNYXRoLnNpZ24oIHRoaXMuY3VycmVudERpc3RbMV0uZGlzdCApXG4gICAgICAgIGxldCBkaXN0RGlyZWN0aW9uID0gTWF0aC5zaWduKCBkaXN0WzFdLmRpc3QgKVxuICAgICAgICBcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IDM7IGkrKyl7XG5cbiAgICAgICAgICAgIC8vTWlkZGxlIGRpc3Qgbm90IGVxdWFsIGJvdGggbmVnYXRpdmUgb3IgcG9zaXRpdmVzIHRoZW4gdXNlIGN1cnJlbnQgZGlzdFxuICAgICAgICAgICAgbGV0IGRpc3RfaSA9IGN1cnJlbnREaXJlY3Rpb24gIT09IGRpc3REaXJlY3Rpb24gPyB0aGlzLmN1cnJlbnREaXN0W2ldIDogZGlzdFtpXVxuICAgICAgICAgICAgbGV0IGQgPSBkaXN0X2kuZGlzdCA8IDAgPyBkaXN0X2kuZGlzdCAqIC0xIDogZGlzdF9pLmRpc3QgIC8vY2hhbmdlZCB0aGlzXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vU3RhcnRzIG9mZiB3aXRoIHBvc2l0aXZlIHZhcmlhYmxlc1xuICAgICAgICAgICAgbGV0IHJpZ2h0UGFnZVN0YXJ0ID0gZGlzdF9pLnJpZ2h0UGFnZVN0YXJ0IDwgMCA/IGRpc3RfaS5yaWdodFBhZ2VTdGFydCAqIC0xIDogZGlzdF9pLnJpZ2h0UGFnZVN0YXJ0XG4gICAgICAgICAgICBsZXQgc3RhcnREaXN0ID0gYmVnaW5Qb3NbaV0gPCAwID8gYmVnaW5Qb3NbaV0gKiAtMSA6IGJlZ2luUG9zW2ldXG4gICAgICAgICAgICBsZXQgcG9zQ3VycmVudCA9IGN1cnJlbnRbaV0gPCAwID8gY3VycmVudFtpXSAqIC0xIDogY3VycmVudFtpXVxuXG4gICAgICAgICAgICAvLyBXaGVuIGNsaWNrZWQgb3Bwb3NpdGUgZGlyZWN0aW9uXG4gICAgICAgICAgICBpZiggY3VycmVudERpcmVjdGlvbiAhPT0gZGlzdERpcmVjdGlvbil7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiggcmlnaHRQYWdlU3RhcnQgKXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJpZ2h0U3RhcnQgPSB0aGlzLnJpZ2h0ID8gLXJpZ2h0UGFnZVN0YXJ0IDogcmlnaHRQYWdlU3RhcnRcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLmhhbmRsZVJpZ2h0UGFnZVN0YXJ0KGQscmlnaHRQYWdlU3RhcnQsIHBvc0N1cnJlbnQsIHN0YXJ0RGlzdCwgdGhpcy5jdXJyZW50RGlzdFtpXS5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1ckRpc3QgPSB0aGlzLnJpZ2h0ID8gLWN1ci5kaXN0YW5jZSA6IGN1ci5kaXN0YW5jZVxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFnZVJpZ2h0ID0gY3VyLnBhZ2VSaWdodFxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzdC5wdXNoKHtkaXN0OiBjdXJEaXN0LCBpbmRleDogZGlzdF9pLmluZGV4LCByaWdodFBhZ2VTdGFydDogcmlnaHRTdGFydCwgcGFnZVJpZ2h0OiBwYWdlUmlnaHR9KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luUG9zLnB1c2goY3VycmVudFtpXSlcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gdGhpcy5vcHBpc2l0ZURpciggcG9zQ3VycmVudCwgc3RhcnREaXN0KVxuICAgICAgICAgICAgICAgICAgICBsZXQgZGlzdCA9IHRoaXMucmlnaHQgJiYgZGlzdGFuY2UgPiAwID8gLWRpc3RhbmNlIDogZGlzdGFuY2VcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc3QucHVzaCh7ZGlzdDogZGlzdCwgaW5kZXg6IGRpc3RfaS5pbmRleCwgcmlnaHRQYWdlU3RhcnQ6IGRpc3RfaS5yaWdodFBhZ2VTdGFydCwgcGFnZVJpZ2h0OiBmYWxzZX0pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmVnaW5Qb3MucHVzaChjdXJyZW50W2ldKVxuICAgICAgICAgICAgICAgIH0gICAgICBcbiAgICAgICAgICAgIC8vQ2xpY2tlZCBzYW1lIGRpcmVjdGlvblxuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgLy9BZnRlciBlbGVtZW50IHN0YXJ0cyBmcm9tIGhpZGRlbiBwYXJ0IG9mIHBhZ2VcbiAgICAgICAgICAgICAgICBpZigoIHRoaXMucmlnaHQgJiYgcmlnaHRQYWdlU3RhcnQgJiYgY3VycmVudFtpXSA8IDApIHx8IHRoaXMubGVmdCAmJiBjdXJyZW50W2ldID4gMCAmJiByaWdodFBhZ2VTdGFydCAgKXtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGVzc1RoYW4gPSBkaXN0X2kuaW5kZXggLy9oYXZlIHRvIHVwZGF0ZSByaWdodFBhZ2VTdGFydCBhZ2FpbiBkdWUgdG8gcnVubmluZyB0aGlzLmdldERpc3RhbmNlKCkgdHdpY2VcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3RhbmNlID0gZCAvIDIgLSAoIHJpZ2h0UGFnZVN0YXJ0IC0gcG9zQ3VycmVudCApICBcbiAgICAgICAgICAgICAgICAgICAgbGV0IFBvc09yTmVnRGlzdGFuY2UgPSB0aGlzLnJpZ2h0ICYmIGRpc3RhbmNlID4gMCA/IGRpc3RhbmNlICogLTE6IGRpc3RhbmNlXG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0LnB1c2goe2Rpc3Q6IFBvc09yTmVnRGlzdGFuY2UsIGluZGV4OiBkaXN0X2kuaW5kZXgsIHJpZ2h0UGFnZVN0YXJ0OiBkaXN0X2kucmlnaHRQYWdlU3RhcnQsIHBhZ2VSaWdodDogZmFsc2V9KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJlZ2luUG9zLnB1c2goY3VycmVudFtpXSlcbiAgICAgICAgICAgICAgICB9ZWxzZXsgIFxuICAgICAgICAgICAgICAgICAgICBsZXQgbGVzc1RoYW5oYWxmID0gc3RhcnREaXN0IDwgcG9zQ3VycmVudCB8fCAoc3RhcnREaXN0ICYmIHBvc0N1cnJlbnQgPCBkKSA/IHRydWUgOiBmYWxzZSAgXG4gICAgICAgICAgICAgICAgICAgIGxldCBkaXN0YW5jZSA9IGxlc3NUaGFuaGFsZiA/IHRoaXMubGVzc1RoYW5IYWxmKCBwb3NDdXJyZW50LCBkaXN0X2ksIHN0YXJ0RGlzdCkgOiB0aGlzLm1vcmVUaGFuSGFsZiggZCwgcG9zQ3VycmVudCwgc3RhcnREaXN0ICkgICAgXG4gICAgICAgICAgICAgICAgICAgIGxldCBQb3NPck5lZ0Rpc3RhbmNlID0gdGhpcy5yaWdodCA/IC1kaXN0YW5jZSA6IGRpc3RhbmNlXG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXN0LnB1c2goe2Rpc3Q6IFBvc09yTmVnRGlzdGFuY2UsIGluZGV4OiBkaXN0X2kuaW5kZXgsIHJpZ2h0UGFnZVN0YXJ0OiBkaXN0X2kucmlnaHRQYWdlU3RhcnQsIHBhZ2VSaWdodDogdHJ1ZX0pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYmVnaW5Qb3MucHVzaChjdXJyZW50W2ldKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL1JlbW92ZXMgcHJpb3IgdmFsdWVzIGluIGFycmF5c1xuICAgICAgICB0aGlzLmRpc3Quc3BsaWNlKDAsMyksIHRoaXMuYmVnaW5Qb3Muc3BsaWNlKDAsMylcbiAgICAgICAgY29uc29sZS5sb2codGhpcy5kaXN0LCB0aGlzLmJlZ2luUG9zKVxuICAgIH1cbiAgICAvL1VwZGF0ZXMgc2xpZGVycyBwb3NpdGlvbnNcbiAgICB1cGRhdGVQb3MoKXtcbiAgICAgICAgLy8gSGFuZGxlcyBiYWNrIGFuZCBmb3J0aCBjbGlja2luZ1xuICAgICAgICBpZih0aGlzLnN0YXJ0KXtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSAwXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERpc3QgPSB0aGlzLmdldERpc3RhbmNlKClcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJlZ2luUG9zID0gdGhpcy5zdGFydFBvcyh0aGlzLnNsaWRlcnMpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVEb3VibGVDbGljayh0aGlzLmN1cnJlbnQsIHRoaXMuZGlzdCwgdGhpcy5iZWdpblBvcylcbiAgICAgICAgICAgIFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQmVsdFBvcygpXG4gICAgICAgICAgICB0aGlzLmJlZ2luUG9zLmxlbmd0aCA9IDBcbiAgICAgICAgICAgIHRoaXMuZGlzdC5sZW5ndGggPSAwXG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gdGhpcy5nZXREaXN0YW5jZSgpXG4gICAgICAgICAgICBjb25zdCBiZWdpblBvcyA9IHRoaXMuc3RhcnRQb3ModGhpcy5zbGlkZXJzKVxuICAgICAgICAgICAgLy8gMyBpcyBsZW5ndGggb2Ygc2xpZGVyIGVsZW1lbnRzXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLmJlZ2luUG9zLnB1c2goYmVnaW5Qb3NbaV0pXG4gICAgICAgICAgICAgICAgdGhpcy5kaXN0LnB1c2goZGlzdFtpXSlcblxuICAgICAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5kcmF3KVxuICAgICAgICB9XG4gICAgfVxuICAgIGFuaW1hdGVCZWx0cyh0b3BHZWFycywgYm90dG9tR2VhcnMpe1xuICAgICAgICBfKCd0ZWV0aC13cmFwcGVyLXRvcCcpLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHsgdG9wR2VhcnMgfXB4KWBcbiAgICAgICAgXygndGVldGgtd3JhcHBlci1ib3R0b20nKS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7IGJvdHRvbUdlYXJzIH1weClgXG4gICAgfVxuXG4gICAgYW5pbWF0ZShzbGlkZXJzLCBpbWdHcm91cCwgdmFsdWUpe1xuICAgICAgICBzbGlkZXJzLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHsgdmFsdWUgfXB4KWBcbiAgICAgICAgaW1nR3JvdXAuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgkeyB2YWx1ZSB9cHgpYFxuICAgIH1cblxuICAgIGRyYXcodGltZXN0YW1wKXtcbiAgICAgICAgY29uc3QgdGltZSA9IHRoaXMudGltZVxuICAgICAgICBpZighdGhpcy5zdGFydCkgdGhpcy5zdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICB0aGlzLnJ1bnRpbWUgPSB0aW1lc3RhbXAgLSB0aGlzLnN0YXJ0O1xuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWluKHRoaXMucnVudGltZSAvIHRpbWUsIDEpXG5cbiAgICAgICAgbGV0IGogPSB0aGlzLmxlc3NUaGFuXG4gICAgXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgIFxuICAgICAgICAgICAgbGV0IG51bSA9IGkgIT09IGogPyBpIDogalxuICAgICAgICAgICAgbGV0IHNsaWRlcnMgPSB0aGlzLnNsaWRlcnNbbnVtXVxuICAgIFxuICAgICAgICAgICAgbGV0IGltZ0dyb3VwID0gdGhpcy5mb3JlaW5Hcm91cFtudW1dXG4gICAgXG4gICAgICAgICAgICBsZXQgYmVnaW5Qb3MgPSB0aGlzLmJlZ2luUG9zW251bV1cbiAgICAgICAgICAgIGxldCBkaXN0ID0gdGhpcy5kaXN0W251bV0uZGlzdFxuICAgICAgICAgICAgbGV0IHJpZ2h0U3RhcnQgPSB0aGlzLmRpc3RbbnVtXS5yaWdodFBhZ2VTdGFydFxuICAgICAgICAgICAgbGV0IHBhZ2VSaWdodCA9IHRoaXMuZGlzdFtudW1dLnBhZ2VSaWdodCAgIFxuICAgICAgICAgICAgLy9SaWdodCBvciBMZWZ0IHNpZGUgZWxlbWVudCBhbmltYXRlIHRvIG90aGVyIHNpZGUgb2Ygc2NyZWVuXG4gICAgICAgICAgICBpZihudW0gPT09IGogJiYgcGFnZVJpZ2h0KXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihwcm9ncmVzcyA8PSAuNSl7XG4gICAgICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IGJlZ2luUG9zIC0gKGRpc3QgKiBwcm9ncmVzcylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50W251bV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGUoc2xpZGVycywgaW1nR3JvdXAsIHZhbHVlKVxuICAgICAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHZhbHVlID0gcmlnaHRTdGFydCAtICggZGlzdCAqIChwcm9ncmVzcyAtIC41KSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50W251bV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGUoc2xpZGVycywgaW1nR3JvdXAsIHZhbHVlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYmVnaW5Qb3MgLSAoZGlzdCAqIHByb2dyZXNzKVxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFtudW1dID0gdmFsdWVcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGUoc2xpZGVycywgaW1nR3JvdXAsIHZhbHVlKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEJlbHRzIEFuaW1hdGlvblxuICAgICAgICBsZXQgdG9wR2VhcnMgPSB0aGlzLmJlbHRQb3Muc3RhcnRQb3NbMF0gKyAodGhpcy5iZWx0UG9zLmRpc3QgKiBwcm9ncmVzcykgXG4gICAgICAgIGxldCBib3R0b21HZWFycyA9IHRoaXMuYmVsdFBvcy5zdGFydFBvc1sxXSAtICh0aGlzLmJlbHRQb3MuZGlzdCAqIHByb2dyZXNzKVxuICAgICAgICB0aGlzLmFuaW1hdGVCZWx0cyh0b3BHZWFycywgYm90dG9tR2VhcnMpXG4gICAgICAgIGlmKHByb2dyZXNzIDwgMSl7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5kcmF3KVxuICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICB0aGlzLmZvcmVpbk9iakFycigpXG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gMFxuICAgICAgICAgICAgdGhpcy5iZWx0Q2xpY2sgKytcbiAgICAgICAgICAgIHRoaXMuY2xpY2sgPSAwXG4gICAgICAgICAgICBpbWdJbmxhcmdlLnRhcmdldEVsZW0oKVxuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgIH0gXG4gICAgfVxuICAgIC8vU3RhcnMgZ2VhcnMgaW5saW5lIGxlZnQgb3IgcmlnaHQgZGVwZW5kaW5nIG9uIGxlZnQgb3IgcmlnaHQgY2xpY2tcbiAgICBiZWx0RGlyZWN0aW9ucygpe1xuICAgICAgICBsZXQgYmVsdFdpZHRoID0gXygnYm90dG9tLW1haW4nKS5nZXRCQm94KCkud2lkdGhcblxuICAgICAgICBpZih0aGlzLnJpZ2h0KXtcbiAgICAgICAgICAgIF8oJ2JvdHRvbS10ZWV0aCcpLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoICR7YmVsdFdpZHRofXB4IClgXG4gICAgICAgICAgICBfKCd0b3AtdGVldGgnKS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCAkey1iZWx0V2lkdGh9cHggKWBcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBfKCdib3R0b20tdGVldGgnKS5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCAkey1iZWx0V2lkdGh9cHggKWBcbiAgICAgICAgICAgIF8oJ3RvcC10ZWV0aCcpLnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoICR7YmVsdFdpZHRofXB4IClgXG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlQmVsdFBvcygpe1xuICAgICAgICBsZXQgYmVsdHMgPSB0aGlzLnN0YXJ0UG9zKHRoaXMuYmVsdHMpXG4gICAgICAgIGxldCBzdGFydFBvcywgZGlzdDsgXG5cbiAgICAgICAgICAgIC8vIFN0YXJ0cyBnZWFycyBvbiBvbmUgc2lkZSBvZiB0aGUgcGFnZSBvciB0aGUgb3RoZXIgXG4gICAgICAgIGlmKCB0aGlzLmJlbHRDbGljayA9PT0gMCB8fCB0aGlzLmJlbHRDbGljayAmJiBiZWx0c1swXSA9PT0gMCApIHRoaXMuYmVsdERpcmVjdGlvbnMoKVxuXG4gICAgICAgIGlmKHRoaXMucmlnaHQpe1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBiZWx0c1xuICAgICAgICAgICAgZGlzdCA9IF8oJ3RvcC10ZWV0aCcpLmdldEJCb3goKS53aWR0aCAvIDNcbiAgICAgICAgfVxuICAgICAgICBpZih0aGlzLmxlZnQpe1xuICAgICAgICAgICAgc3RhcnRQb3MgPSBiZWx0c1xuICAgICAgICAgICAgZGlzdCA9IC0oIF8oJ3RvcC10ZWV0aCcpLmdldEJCb3goKS53aWR0aCAvIDMgKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL0tlZXBzIEdlYXJzIGFsd2F5cyBsb29raW5nIGxpa2UgdGhlaXIgbmV2ZXIgZW5kaW5nXG4gICAgICAgIGlmKCB0aGlzLmJlbHRDbGljayA9PT0gMyl7XG4gICAgICAgICAgICB0aGlzLmJlbHRDbGljayA9IDBcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0ZUJlbHRzKDAsIDApXG4gICAgICAgICAgICB0aGlzLmJlbHREaXJlY3Rpb25zKClcbiAgICAgICAgICAgIHN0YXJ0UG9zID0gWzAsMF1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlbHRQb3MgPSB7ZGlzdCwgc3RhcnRQb3N9XG4gICAgfSBcbn1cblxuY2xhc3MgSW5MYXJnZUltZyBleHRlbmRzIFJvbGxlclVuaXQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5jb250YWluZXIgPSAgXygnaW1nLWlubGFyZ2UtY29udGFpbmVyJylcbiAgICAgICAgdGhpcy5hbmltYXRlQ2xpcFBhdGggPSB0aGlzLmFuaW1hdGVDbGlwUGF0aC5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMuaW1nID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmlubGFyZ2UtaW1nLXdyYXAgaW1nJylcbiAgICAgICAgdGhpcy5pbWdXcmFwID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnaW5sYXJnZS1pbWctd3JhcCcpWzBdXG4gICAgICAgIHRoaXMubW91c2VNb3ZlID0gdGhpcy5tb3VzZU1vdmUuYmluZCh0aGlzKVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyID0gdGhpcy5yZW1vdmVMaXN0ZW5lci5iaW5kKHRoaXMpXG4gICAgICAgIHRoaXMubW91c2VZID0gMFxuICAgICAgICB0aGlzLmltYWdlQ2xvc2UgPSB0aGlzLmltYWdlQ2xvc2UuYmluZCh0aGlzKVxuICAgICAgICB0aGlzLnRhcmdldEVsZW0gPSB0aGlzLnRhcmdldEVsZW1cbiAgICAgICAgdGhpcy5jaGVja0ZvckR1cGxpY2F0ZXMgPSB0aGlzLmNoZWNrRm9yRHVwbGljYXRlc1xuICAgICAgICB0aGlzLm1vdmVFbGVtZW50ID0gdGhpcy5tb3ZlRWxlbWVudFxuICAgICAgICB0aGlzLlkgPSAwXG4gICAgfVxuICAgIFxuICAgIGFkZENsaWNrTGlzdGVuZXIoKXtcbiAgICAgICAgXygnaW1nLWlubGFyZ2UtY29udGFpbmVyJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmltYWdlQ2xvc2UpOyBcbiAgICB9XG4gICAgcmVtb3ZlQ2xpY2tMaXN0ZW5lcigpe1xuICAgICAgICBfKCdpbWctaW5sYXJnZS1jb250YWluZXInKS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaW1hZ2VDbG9zZSk7IFxuICAgIH1cbiAgICBjaGVja0ZvckR1cGxpY2F0ZXMoY2xzc05hbWUpe1xuICAgICAgICBjb25zdCBpbWdzID0gdGhpcy5pbWdXcmFwLmNoaWxkcmVuXG4gICAgICAgIGxldCBsZW5ndGggPSBpbWdzLmxlbmd0aFxuICAgICAgICB3aGlsZShsZW5ndGgtLSl7XG4gICAgICAgICAgICBpZiAoIGltZ3NbbGVuZ3RoXS5jbGFzc05hbWUgPT09IGNsc3NOYW1lICl7XG4gICAgICAgICAgICAgICAgdGhpcy5pbWcgPSBpbWdzW2xlbmd0aF07XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVJbWcoKVxuICAgICAgICAgICAgfSBcbiAgICAgICAgfVxuICAgIH1cbiAgICAvL1JlY3Vyc2lvblxuICAgIHRhcmdldEVsZW0oZWxlbVgpe1xuICAgICAgICBcbiAgICAgICAgbGV0IGxlbmd0aCA9IHRoaXMuZm9yZWluT2Jqcy5sZW5ndGhcbiAgICAgICAgbGV0IGFyciA9IFtdXG4gICAgICAgIGxldCBncm91cEFyciA9IFtdXG4gICAgICAgXG4gICAgICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSApe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyAxc3QgcHVzaGVzIG9ubHkgZWxlbWVudHMgd2l0aCBzdHlsZSBhdHRyaWJ0dWVzIG9mIHhcbiAgICAgICAgICAgIGlmKCFlbGVtWCAmJiB0aGlzLmZvcmVpbk9ianNbaV0uaGFzQXR0cmlidXRlKCd4JykgKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBhcnIucHVzaCggdGhpcy5mb3JlaW5PYmpzW2ldLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnggKVxuICAgICAgICAgICAgICAgIGdyb3VwQXJyLnB1c2godGhpcy5mb3JlaW5PYmpzW2ldLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTY2FsaW5nIGltYWdlIG9ubHlcbiAgICAgICAgICAgIGlmICggdGhpcy5mb3JlaW5PYmpzW2ldLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkueCA9PT0gZWxlbVggJiYgdGhpcy50b2dnbGVNb3ZlRWxlbWVudCl7XG4gICAgICAgICAgICAgICAgdGhpcy5ncm91cCA9IHRoaXMuZm9yZWluT2Jqc1tpXS5wYXJlbnROb2RlXG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHRoaXMuZm9yZWluT2Jqc1tpXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS54ID09PSBlbGVtWCApe1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tGb3JEdXBsaWNhdGVzKCd3ZWJWaXNpYmxlJylcbiAgICAgICAgICAgICAgICBsZXQgaW1nTm9kZSA9IHRoaXMuZm9yZWluT2Jqc1tpXS5jaGlsZE5vZGVzWzFdO1xuICAgICAgICAgICAgICAgIGxldCBjbG9uZWRJbWcgPSBpbWdOb2RlLmNsb25lTm9kZSh0cnVlKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1vdmVFbGVtZW50KCBjbG9uZWRJbWcsICd3ZWJWaXNpYmxlJyApICBcbiAgICAgICAgICAgIH0gXG4gICAgICAgIH1cbiAgICAgICAgLy8gTWlkZGxlIGVsZW1lbnQgd2hpY2ggaXMgdGhlIG1lZGlhbiBvZiB0aGUgdGhyZWUgZWxlbWVudHNcbiAgICAgICAgbGV0IHNvcnRlZCA9IGFyci5zb3J0KCAoYSxiKSA9PiBhIC0gYiApWzFdXG4gICAgICAgIHRoaXMudGFyZ2V0RWxlbShzb3J0ZWQpXG4gICAgfVxuICAgIGluc2VydFRleHQoaW1nKXtcbiAgICAgICAgbGV0IGltZ0NvbnRlbnQgPSBfKCdpbWctY29udGVudCcpXG4gICAgICAgIGxldCB1cmwgPSBpbWcuYXR0cmlidXRlc1syXS52YWx1ZVxuICAgICAgICBsZXQgdGV4dCA9IGltZy5hdHRyaWJ1dGVzWzFdLnRleHRDb250ZW50XG4gICAgICAgIGltZ0NvbnRlbnQudGV4dENvbnRlbnQgPSB0ZXh0XG4gICAgICAgIGltZ0NvbnRlbnQuaW5uZXJIVE1MICs9ICc8YnI+JysnPGEgaHJlZj1cIicgKyB1cmwgKyAnXCI+ICcgKyB1cmwgKyAnIDwvYT4nKyc8L2JyPidcbiAgICB9XG4gICAgbW92ZUVsZW1lbnQoZWwsIGNscyl7XG4gICAgICAgIHRoaXMuaW1nID0gZWwgLy91cGRhdGVzIGltYWdlIHRvIGJlIHVzZWQgZWxzZXdoZXJlIFxuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscylcbiAgICAgICAgbGV0IGltZ19jb250ZW50ID0gXygnaW1nLWNvbnRlbnQnKVxuICAgICAgICBsZXQgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGVsKVxuICAgICAgICB0aGlzLmltZ1dyYXAuaW5zZXJ0QmVmb3JlKGZyYWdtZW50LCBpbWdfY29udGVudCk7XG4gICAgICAgIHRoaXMuaW1nV3JhcC5jbGFzc0xpc3QuYWRkKCdzaG93LWltZycpXG4gICAgICAgIHRoaXMuaW1nV3JhcC5jbGFzc0xpc3QucmVtb3ZlKCdoaWRlLWltZycpXG4gICAgfVxuXG4gICAgcmVtb3ZlSW1nKGUpe1xuICAgXG4gICAgICAgIC8vT25seSByYW4gdG8gZXhpdCBvdXQgb2YgaW1hZ2UgZnJvbSBjbGljayBoYW5kbGVyXG4gICAgICAgIGlmKGUpe1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUub3BhY2l0eSA9IDBcbiAgICAgICAgICAgIHRoaXMuaW1nV3JhcC5jbGFzc0xpc3QucmVwbGFjZSgnc2hvdy1pbWcnLCAnaGlkZS1pbWcnKVxuICAgICAgICAgICAgc2V0VGltZW91dCggKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuaW1nV3JhcC5jbGFzc0xpc3QucmVwbGFjZSgnaGlkZS1pbWcnLCAnc2hvdy1pbWcnKVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKVxuICAgICAgICAgICAgICAgIHRoaXMuaW1nLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSdcbiAgICAgICAgICAgIH0sMTEwMClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIF8oJ2ltZy1jb250ZW50JykudGV4dENvbnRlbnQgPSAnJ1xuICAgICAgICAgICAgdGhpcy5pbWcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmltZylcbiAgICAgXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVtb3ZlcyBpbWFnZXMgXG4gICAgaW1hZ2VDbG9zZShlKXtcbiAgICAgICAgdGhpcy5yZW1vdmVDbGlja0xpc3RlbmVyKClcbiAgICAgICAgaWYoZS50YXJnZXQudGFnTmFtZSAhPT0gJ0lNRycpe1xuXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUltZyhlKVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIERpc3BsYXlzIGltYWdlXG4gICAgc2hvd0ltYWdlKGNsc3NOYW1lKXtcbiAgICAgICAgdGhpcy5pbWcgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsc3NOYW1lKVswXVxuICAgICAgICB0aGlzLmluc2VydFRleHQodGhpcy5pbWcpXG4gICAgICAgIHRoaXMuaW1nLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snXG4gICAgICAgIHRoaXMuYWRkQ2xpY2tMaXN0ZW5lcigpXG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCdcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUub3BhY2l0eSA9IDFcbiAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICoqICBSRU1PVkUgQU5JTUFURUNMSVBQQVRIIElGIEkgRE9OJ1QgUkVBTExMWSBIQVZFIFRPIFVTRSBJVCBGT1IgRklSRUZPWCAqKlxuICAgIC8vRmlyZWZveCBvbmx5XG4gICAgYW5pbWF0ZUNsaXBQYXRoKHRpbWVzdGFtcCl7XG4gICAgICAgIGlmKCF0aGlzLnN0YXJ0KSB0aGlzLnN0YXJ0ID0gdGltZXN0YW1wXG4gICAgICAgIHRoaXMucnVudGltZSA9IHRpbWVzdGFtcCAtIHRoaXMuc3RhcnQ7XG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gTWF0aC5taW4odGhpcy5ydW50aW1lIC8gMTAwMCwgMSlcbiAgICAgICAgdGhpcy5pbWdXcmFwLnN0eWxlLmNsaXBQYXRoID0gYGNpcmNsZSgke3RoaXMuY2xpcFN0YXJ0ICsgKHRoaXMuY2xpcFZhbHVlICogcHJvZ3Jlc3MpfSUpYFxuICAgIFxuICAgICAgICBpZihwcm9ncmVzcyA8IDEpe1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZUNsaXBQYXRoKVxuICAgICAgICB9ZWxzZSB7XG5cbiAgICAgICAgICAgIGlmKHRoaXMuY29udGFpbmVyLnN0eWxlLm9wYWNpdHkgPT0gMCl7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZXMgZmxleCBhbmQgb3BhY2l0eSwgc2V0cyBiYWNrIHRvIGRpc3BsYXkgbm9uZVxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKVxuICAgICAgICAgICAgICAgIC8vIHRoaXMuaW1nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5pbWcpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gMFxuICAgICAgICB9XG4gICAgfVxuICAgIGdldFRyYW5zZm9ybSgpe1xuICAgICAgICBsZXQgcmVnRXggPSAvXnNjYWxlL2c7XG4gICAgICAgIGxldCB0cmFuc2Zvcm0gPSB0aGlzLmdyb3VwLnN0eWxlLnRyYW5zZm9ybS5yZXBsYWNlKC9eKFxcdypcXCgtP1xcZCouXFx3KlxcKSkoLiopL2lnLCBcIiQxXCIpXG4gICAgICAgIGxldCBjaGVja0ZvclNjYWxlID0gdHJhbnNmb3JtLm1hdGNoKHJlZ0V4KVxuICAgICAgICAvL1NvIHR3byBzY2FsZSB2YWx1ZXMgZG9uJ3QgZ2V0IGFkZGVkIHRvIGVsZW1lbnQgd2hlbiB0cmFuc2xhdGUgZG9lc24ndCBleGlzdFxuICAgICAgICBpZihjaGVja0ZvclNjYWxlKXtcbiAgICAgICAgICAgIHJldHVybiAnJ1xuICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzY2FsZVBob3RvKGRpc3QsIHNjYWxlLCB0cmFuc2xhdGUpe1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2xpZGVyXzFfJykuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVkoJHtkaXN0fXB4KWBcbiAgICAgICAgdGhpcy5ncm91cC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2xhdGUgKyBgc2NhbGUoICR7MSArIHNjYWxlfSApYFxuICAgIH1cbiAgICBcbiAgICBtb3VzZU1vdmUoZSl7XG4gICAgICAgIC8vIG11bHRpcHkgYnkgMS41IGJlY2F1c2Ugb2YgdGhlIGxhZywgc28gSSBzcGVlZCBpdCB1cCBqdXN0IGEgYml0XG4gICAgICAgIGxldCBkaXN0ID0gZS5jbGllbnRZIC0gdGhpcy5tb3VzZVlcbiAgICAgICAgbGV0IHZhbHVlID0gICBkaXN0IC8gdGhpcy5ZXG4gICAgICAgIGxldCBzY2FsZSA9IE1hdGgubWluKCB2YWx1ZSA8IDAgPyAtdmFsdWUgOiAtdmFsdWUsIDEpXG4gICAgICAgIGxldCB0cmFuc2xhdGUgPSB0aGlzLmdldFRyYW5zZm9ybSgpIFxuICAgICAgICBsZXQgdHJhbnNsYXRlVmFsdWUgPSArKCB0cmFuc2xhdGUucmVwbGFjZSgvW14tXFxkLl0vaWcsIFwiXCIpIClcbiAgXG4gICAgICAgIC8vQ2hlY2tzIGlmIGVsZW1lbnQgaXMgZWl0aGVyIC00MzEgb3IgNDMxIHNvIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSBvcmlnaW4gY2FuIGJlIGFkZGVkXG4gICAgICAgIGlmKHRyYW5zbGF0ZVZhbHVlID4gMil7XG4gICAgICAgICAgICB0aGlzLmdyb3VwLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IDE2NSArIFwicHggXCIgKyA0NTAgKyBcInB4XCJcbiAgICAgICAgfWVsc2UgaWYodHJhbnNsYXRlVmFsdWUgPCAtMSl7XG4gICAgICAgICAgICB0aGlzLmdyb3VwLnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IDEwMzQgKyBcInB4IFwiICsgNDU4ICsgXCJweFwiXG4gICAgICAgIH1cbiAgICAgICAgLy9zY2FsZSBpcyAxIHdoZW4gY2xpY2tlZCBzb21ld2hlcmUgZWxzZVxuICAgICAgICBpZiggc2NhbGUgPCAxICYmIGRpc3QgPD0gNiApIHRoaXMuc2NhbGVQaG90byhkaXN0LCBzY2FsZSwgdHJhbnNsYXRlKVxuICAgIH1cblxuICAgIG1vdXNlRG93bihlKXtcbiAgICAgICAgXG4gICAgICAgIF8oJ3NsaWRlLWdyb3VwJykuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMucmVtb3ZlTGlzdGVuZXIsIHRydWUpXG5cbiAgICAgICAgdGhpcy50b2dnbGVNb3ZlRWxlbWVudCA9IHRydWVcbiAgICAgICAgdGhpcy50YXJnZXRFbGVtKClcbiAgICAgICAgbGV0IHZlclBpZWNlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ZlcnRfcGllY2UnKVxuICAgICAgICBsZXQgdmVydFkgPSB2ZXJQaWVjZS5nZXRCQm94KCkueVxuICAgICAgICBsZXQgaGFuZGxlWSA9IF8oJ2ltZy1zY2FsZScpLmdldEJCb3goKS55ICAgIFxuXG4gICAgICAgIC8vR2V0cyBkaXN0YW5jZSBzbGlkZXIgbmVlZHMgdG8gZ28gIFxuICAgICAgICB0aGlzLlkgPSBoYW5kbGVZIC0gdmVydFlcbiAgICAgICAgXG4gICAgICAgIC8vU3RhcnQgcG9zaXRpb24gZm9yIGRpc3RhbmNlXG4gICAgICAgIGlmKCF0aGlzLm1vdXNlWSkgdGhpcy5tb3VzZVkgPSBlLmNsaWVudFlcbiAgICAgICAgXygnc2xpZGUtZ3JvdXAnKS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlTW92ZSwgdHJ1ZSlcbiAgICAgICBcbiAgICB9XG5cbiAgICByZW1vdmVMaXN0ZW5lcihlKXtcbiAgICAgICAgXygnc2xpZGUtZ3JvdXAnKS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLm1vdXNlTW92ZSwgdHJ1ZSlcbiAgICAgICAgXG4gICAgICAgIGxldCB0cmFuc2xhdGUgPSB0aGlzLmdldFRyYW5zZm9ybSgpXG4gICAgICAgIHRoaXMuc2NhbGVQaG90bygwLDAsdHJhbnNsYXRlKVxuICAgICAgICBcbiAgICAgICAgXygnc2xpZGUtZ3JvdXAnKS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5yZW1vdmVMaXN0ZW5lciwgdHJ1ZSlcbiAgICAgICAgXygnaW1nLXNjYWxlJykucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5tb3VzZURvd24sIHRydWUpO1xuXG4gICAgICAgIC8vVXBkYXRlcyBwb3NpdGlvbiB3aGVuIG1vdXNlVXBcbiAgICAgICAgdGhpcy5tb3VzZVkgPSAwXG4gICAgICAgIHRoaXMudG9nZ2xlTW92ZUVsZW1lbnQgPSBmYWxzZVxuICAgIH1cbn1cblxubGV0IHJvbGxlclVuaXQgPSBuZXcgUm9sbGVyVW5pdCgpO1xubGV0IGltZ0lubGFyZ2UgPSBuZXcgSW5MYXJnZUltZygpO1xucm9sbGVyVW5pdC5wb3NpdGlvbkZvcmllZ25PYmplY3QoaW1nSW5sYXJnZSk7XG5cbl8oJ2ltZy1zY2FsZScpLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChlKSA9PiB7XG4gICAgXG4gICAgaW1nSW5sYXJnZS5tb3VzZURvd24oZSlcbn0sIHRydWUpO1xuXG5fKCdidXR0b25zJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGZ1bmN0aW9uKGUpe1xuICAgIFxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldC5wYXJlbnRFbGVtZW50LmNsYXNzTGlzdFswXVxuXG4gICAgaWYodGFyZ2V0ID09PSAnaW1nLWxlZnQnIHx8IHRhcmdldCA9PT0gJ2ltZy1yaWdodCcpe1xuICAgICAgICBpZihyb2xsZXJVbml0LmNsaWNrID09PSAxKSByZXR1cm4gIFxuICAgICAgICBcbiAgICAgICAgcm9sbGVyVW5pdC5sZWZ0ID0gdGFyZ2V0ID09PSAnaW1nLWxlZnQnID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgIHJvbGxlclVuaXQucmlnaHQgPSB0YXJnZXQgPT09ICdpbWctcmlnaHQnID8gdHJ1ZSA6IGZhbHNlXG4gICAgICAgIHJvbGxlclVuaXQudXBkYXRlUG9zKClcblxuICAgIH1lbHNlIGlmKHRhcmdldCA9PT0gJ2ltZy1pbmxhcmdlJyl7XG4gICAgICAgIGltZ0lubGFyZ2Uuc2hvd0ltYWdlKCd3ZWJWaXNpYmxlJylcbiAgICB9XG59KTtcblxuZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2J1dHRvbi1pbmxhcmdlJykuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xuICAgIGltZ0lubGFyZ2Uuc2hvd0ltYWdlKCdkZXNpZ25WaXNpYmxlJylcbn0pXG5cbi8vICoqKiogR1JBUEggU0VDVElPTiAqKioqXG5cbmNvbnN0IHJhbmRvbSA9IChtaW4sIG1heCkgPT4gTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pICsgbWluO1xuXG5jb25zdCB0b2dnbGVSb2JvdCA9IHtcbiAgICB0b2dnbGU6IGZhbHNlLFxuICAgIGZsaWdodDogZmFsc2UsIC8vVG9nZ2xlcyB3aGVuIHNjcm9sbGVkIG91dCBvZiBzY3JlZW4gdmlld1xuICAgIGRpcmVjdGlvbjogJ3VwJ1xufVxuXG5mdW5jdGlvbiBzdGFydFJvYm90RmxpZ2h0KCl7IFxuICAgIC8vICoqKiBCdXJuZXJzICoqKlxuXG4gICAgY29uc3QgZmxhbWVzID0gXygncm9ib3QtZmxhbWUnKVxuICAgIGNvbnN0IGxlbmd0aCA9IGZsYW1lcy5sZW5ndGhcblxuICAgIGNvbnN0IGZyb20gPSB7eDogMSwgeTogMX1cbiAgICBjb25zdCB0byA9IHt9XG4gICAgY29uc3QgZGlzdGFuY2UgPSB7fTtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG5cbiAgICBjb25zdCBuZXh0ID0gdGltZXN0YW1wID0+IHtcbiAgICAgICAgLy9zdGFydHMgYWxsIG92ZXIgZnJvbSBnZXRzIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBsYXN0IHNpemVcbiAgICAgICAgT2JqZWN0LmFzc2lnbihmcm9tLCB0byk7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBheGlzID0ga2V5c1tpXVxuICAgICAgICAgICAgdG9bYXhpc10gPSByYW5kb20oLjgsIDEpO1xuICAgICAgICAgICAgZGlzdGFuY2VbYXhpc10gPSBmcm9tW2F4aXNdIC0gdG9bYXhpc107XG4gICAgICAgIH1cblxuICAgICAgICB0aW1lLnN0YXJ0ID0gdGltZXN0YW1wO1xuICAgIH07XG5cbiAgICBjb25zdCB0aW1lID0ge1xuICAgICAgICB0b3RhbDogNDBcbiAgICB9O1xuXG4gICAgY29uc3QgZHJhd0J1cm5lcnMgPSB0aW1lc3RhbXAgPT4ge1xuICAgICAgICBpZiAodG9nZ2xlUm9ib3QuZmxpZ2h0KSByZXR1cm5cbiAgICAgICAgaWYgKHRpbWUucnVudGltZSA+IHRpbWUudG90YWwgfHwgIXRvLngpIG5leHQodGltZXN0YW1wKTtcblxuICAgICAgICB0aW1lLnJ1bnRpbWUgPSB0aW1lc3RhbXAgLSB0aW1lLnN0YXJ0O1xuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IHRpbWUucnVudGltZSAvIHRpbWUudG90YWw7XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IGtleXMubWFwKGF4aXMgPT4gZnJvbVtheGlzXSAtIHByb2dyZXNzICogZGlzdGFuY2VbYXhpc10pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZmxhbWUgPSBmbGFtZXNbaV1cbiAgICAgICAgICAgIGZsYW1lLnN0eWxlLnRyYW5zZm9ybSA9IGBzY2FsZSgke3h9LCAke3l9KWA7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXdCdXJuZXJzKTtcbiAgICB9O1xuXG5cbiAgICAvLyoqKiBEcmF3cyBTdGFycyAqKipcbiAgICBsZXQgZ3JhcGhzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZ3JhcGgtc3QyMCcpXG4gICAgY29uc3QgcmVjQ2xpcCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3JlYy1jbGlwJylbMF1cbiAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICBjb25zdCByb2JvdFJlY3QgPSBfKCdmbG9hdGluZ19yb2JvdCcpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgZ3JhcGggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZ3JhcGgtc3ZnJylcbiAgICBjb25zdCBbc2l6ZV0gPSAvWzEtOV0uKi8uZXhlYyggZ3JhcGguZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykgKVxuICAgIFxuICAgIGNvbnN0IHJlZ0V4ID0gLyhbMS05Ll0qKVxccyhbMS05Ll0uKikvaWc7XG4gICAgY29uc3QgZ3JhcGhXaWR0aCA9IHNpemUucmVwbGFjZShyZWdFeCwgJyQxJylcbiAgICBjb25zdCBncmFwaEhlaWdodCA9IHNpemUucmVwbGFjZShyZWdFeCwgJyQyJylcbiAgICBcbiAgICBjb25zdCByb2JvdEhlaWdodCA9IHJvYm90UmVjdC5oZWlnaHQ7XG4gICAgY29uc3Qgcm9ib3RXaWR0aCA9IHJvYm90UmVjdC53aWR0aDtcbiAgICBjb25zdCBzdGFydFkgPSBncmFwaEhlaWdodCAtIHJvYm90SGVpZ2h0XG4gICAgY29uc3Qgc3RhcnRYID0gcm9ib3RSZWN0LnggLSAod2luZG93LmlubmVyV2lkdGggLSBncmFwaFdpZHRoKSAvIDJcblxuICAgIC8vc3RhcnRzIHN0YXJzIHJhbmRvbWx5XG4gICAgY29uc3QgcmFuZG9tSW50ZXJ2YWwgPSBmdW5jdGlvbihjYWxsYmFjayxkYXRhLG1pbiwgbWF4KXtcblxuICAgICAgICBjb25zdCB0aW1lID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgdG90YWw6IHJhbmRvbShtaW4sIG1heClcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZHJhdyA9ICh0aW1lc3RhbXApID0+e1xuICAgICAgICAgICAgaWYodG9nZ2xlUm9ib3QuZmxpZ2h0KSByZXR1cm5cbiAgICAgICAgICAgIGlmICh0aW1lLnRvdGFsIDw9IHRpbWVzdGFtcCAtIHRpbWUuc3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aW1lLnN0YXJ0ID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIHRpbWUudG90YWwgPSByYW5kb20obWluLCBtYXgpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGRhdGEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhdyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRyYXcpO1xuICAgIH07XG5cbiAgICBjb25zdCBjcmVhdGVTdGFyID0gKGN4LCBjeSwgcmFkaXVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBcImNpcmNsZVwiKTtcbiAgICAgICAgc3Rhci5zZXRBdHRyaWJ1dGUoXCJyXCIsIHJhZGl1cyk7XG4gICAgICAgIHN0YXIuc2V0QXR0cmlidXRlKFwiY3lcIiwgY3kpO1xuICAgICAgICBzdGFyLnNldEF0dHJpYnV0ZShcImN4XCIsIGN4KTtcbiAgICAgICAgc3Rhci5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwid2hpdGVcIik7XG4gICAgICAgIHN0YXIuc2V0QXR0cmlidXRlKFwiZmlsbC1vcGFjaXR5XCIsIDApO1xuICAgICAgICByZXR1cm4gc3RhcjtcbiAgICB9O1xuXG4gICAgY29uc3QgRmFsbGluZ1N0YXJzID0gZnVuY3Rpb24oZGF0YSl7XG5cbiAgICAgICAgbGV0IGF0dHIgPSBuZXcgZGF0YSh0b2dnbGVSb2JvdC5kaXJlY3Rpb24pXG5cbiAgICAgICAgY29uc3QgcmFkaXVzID0gYXR0ci5yYWRpdXNcbiAgICAgICAgY29uc3QgY3ggPSBhdHRyLmN4XG4gICAgICAgIGNvbnN0IGN5ID0gYXR0ci5jeVxuICAgICAgICBjb25zdCBkaXN0ID0gYXR0ci5kaXN0XG4gICAgICAgIGNvbnN0IHN0YXIgPSBjcmVhdGVTdGFyKGN4LCBjeSwgcmFkaXVzKVxuICAgICAgIFxuICAgICAgICBjb25zdCB0aW1lID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHBlcmZvcm1hbmNlLm5vdygpLFxuICAgICAgICAgICAgdG90YWw6IHJhbmRvbSgxOTAwLCAyMDAwKVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZHJhdyA9ICh0aW1lc3RhbXApID0+IHtcbiAgICAgICAgICBpZih0b2dnbGVSb2JvdC50b2dnbGUgfHwgdG9nZ2xlUm9ib3QuZmxpZ2h0KXtcbiAgICAgICAgICAgICAgICBncmFwaC5yZW1vdmVDaGlsZChzdGFyKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICB0aW1lLmVsYXBzZWQgPSB0aW1lc3RhbXAgLSB0aW1lLnN0YXJ0XG4gICAgICAgICAgICBjb25zdCBwcm9ncmVzcyA9IE1hdGgubWluKHRpbWUuZWxhcHNlZCAvIHRpbWUudG90YWwsIDEpXG4gICAgICAgICAgXG4gICAgICAgICAgICBjb25zdCBvcGFjaXR5ID0gcHJvZ3Jlc3MgKiAyXG5cbiAgICAgICAgICAgIHN0YXIuc2V0QXR0cmlidXRlKFwiY3lcIiwgY3kgKyBwcm9ncmVzcyAqIGRpc3QpXG4gICAgICAgICAgICBzdGFyLnNldEF0dHJpYnV0ZShcImZpbGwtb3BhY2l0eVwiLCBwcm9ncmVzcyA8IC41ID8gb3BhY2l0eSA6IDIgLSBvcGFjaXR5KVxuICAgICAgICAgICAgdGltZS5lbGFwc2VkIDwgdGltZS50b3RhbCA/IHJlcXVlc3RBbmltYXRpb25GcmFtZShkcmF3KTogZ3JhcGgucmVtb3ZlQ2hpbGQoc3RhcilcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhdylcblxuICAgICAgICAvL0luc2VydHMgbmV3IHN0YXIgYmFzZWQgb24gcmFuZG9tSW50ZXJ2YWwgcnVuaW5nIHRocm91Z2hTdGFycygpXG4gICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHN0YXIpXG4gICAgICAgIGdyYXBoLmluc2VydEJlZm9yZShmcmFnbWVudCwgZ3JhcGguZmlyc3RDaGlsZClcblxuICAgIH07XG5cbiAgICB2YXIgZmx5SW50b1BsYWNlID0ge1xuICAgICAgICBiZWdpblk6IGdyYXBoSGVpZ2h0IC0gcm9ib3RIZWlnaHQgLyAxMixcbiAgICAgICAgaGlkZGVuWDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGxldCBkaWZmZXJlbmNlID0gZ3JhcGhXaWR0aCAgLSAgd1dcbiAgICAgICAgICAgIGlmKCF3VyA8IGdyYXBoV2lkdGgpe1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvYm90UmVjdC53aWR0aCArIHJvYm90UmVjdC54ICsgZGlmZmVyZW5jZSBcbiAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBoaWRlUm9ib3Q6IGZ1bmN0aW9uKHNpemUpe1xuICAgICAgICAgICAgaWYoIHNpemUgPT09IDEuMyl7XG4gICAgICAgICAgICAgICAgbGV0IGJlZ2luWCA9IHRoaXMuaGlkZGVuWCgpO1xuICAgICAgICAgICAgICAgIF8oJ2Zsb2F0aW5nX3JvYm90Jykuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgkezB9cHgsIC0ke3RoaXMuYmVnaW5ZfXB4KWBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY3JlYXRlU3RhcnM6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBsZXQgYXR0cmlidXRlcyA9IGZ1bmN0aW9uKGRpcmVjdGlvbil7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihkaXJlY3Rpb24gPT09ICdkb3duJyl7XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlUm9ib3QudG9nZ2xlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYWRpdXMgPSByYW5kb20oLjUsIDIuNylcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN4ID0gcmFuZG9tKHN0YXJ0WCAtIDEwMCwgc3RhcnRYICsgcm9ib3RXaWR0aCArIDEwMClcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN5ID0gcmFuZG9tKHN0YXJ0WSAtIDEyMCAsc3RhcnRZIC0gMTc1IClcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3QgPSAxMDAgKyByb2JvdEhlaWdodDtcblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyByYWRpdXMsIGN4LCBjeSwgZGlzdCB9IFxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9ZWxzZSBpZihkaXJlY3Rpb24gPT09ICd1cCcpe1xuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBsZXQgcmFkaXVzID0gcmFuZG9tKDEuNSwgMy43KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN4ID0gcmFuZG9tKDAgLSAyNSwgZ3JhcGhXaWR0aCArIDI1KVxuICAgICAgICAgICAgICAgICAgICBsZXQgY3kgPSByYW5kb20oZ3JhcGhIZWlnaHQgIC0gODAsIGdyYXBoSGVpZ2h0ICsgNTAgIClcbiAgICAgICAgICAgICAgICAgICAgbGV0IGRpc3QgPSAtZ3JhcGhIZWlnaHQ7IFxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHJhZGl1cywgY3gsIGN5LCBkaXN0IH0gXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9FdmVyeSA4MG1zIHRocm91Z2ggMTgwbXMgb2YgdGltZS50b3RhbCBpdCB3aWxsIGRyYXcgYSBzdGFyXG4gICAgICAgICAgICAvLyoqKiogU1RBUlRTIFNUQVJTIE1PVklORyAqKioqKlxuICAgICAgICAgICAgcmFuZG9tSW50ZXJ2YWwoRmFsbGluZ1N0YXJzLCBhdHRyaWJ1dGVzLDgwLCAxODApXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBncmFwaERhdGEgPSB7XG4gICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICB0b3RhbDogMjAwMCxcbiAgICB9XG4gICAgY29uc3Qgc3VidHJhY3RSYXkgPSAoKSA9PiB7XG4gICAgICAgIF8oJ2xlZnQtdGV4dC1wYW5lbCcpLnJlbW92ZUF0dHJpYnV0ZSgnY2xpcC1wYXRoJylcbiAgICAgICAgXygncmVjLWNsaXAnKS5zdHlsZS50cmFuc2Zvcm0gPSBcInRyYW5zbGF0ZSg0ODVweCwgNTIwcHgpXCJcbiAgICB9XG4gICAgY29uc3QgZ2V0U3Ryb2tlTGVuZ3RoID0gKCkgPT4ge1xuICAgICAgICBsZXQgaSA9IGdyYXBocy5sZW5ndGhcbiAgICAgICAgbGV0IHZhbHVlID0gbmV3IEFycmF5KGkpXG4gICAgICAgIGZ1bmN0aW9uIGdldExlbmd0aCgpe1xuICAgICAgICAgICAgd2hpbGUoaS0tKXtcbiAgICAgICAgICAgICAgICB2YWx1ZVtpXSA9IGdyYXBoc1tpXS5nZXRUb3RhbExlbmd0aCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJ1blZhbHVlOiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIGdldExlbmd0aCgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0cm9rZUxlbmd0aCA9IGdldFN0cm9rZUxlbmd0aCgpO1xuICAgIHN0cm9rZUxlbmd0aC5ydW5WYWx1ZSgpO1xuICAgIFxuICAgIGNvbnN0IGRyYXdQZXJjZW50U3Ryb2tlID0gKHByb2dyZXNzKSA9PiB7XG4gICAgICAgIGxldCBzdHJva2UgPSBzdHJva2VMZW5ndGguZ2V0VmFsdWUoKVxuICAgICAgICBsZXQgaSA9IGdyYXBocy5sZW5ndGhcbiAgICAgICAgd2hpbGUoaS0tKXtcbiAgICAgICAgICAgIGdyYXBoc1tpXS5zdHlsZS5zdHJva2UgPSAndXJsKCNkZXNpZ24tZ3JhZGllbnQpJ1xuICBcbiAgICAgICAgICAgIGdyYXBoc1swXS5zdHlsZS5zdHJva2VEYXNob2Zmc2V0ID0gc3Ryb2tlWzBdICsgKHN0cm9rZVswXSAqIHByb2dyZXNzKVxuICAgICAgICAgICAgZ3JhcGhzWzFdLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSBzdHJva2VbMV0gLSAoc3Ryb2tlWzFdICogcHJvZ3Jlc3MpXG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYW5pbWF0ZUdyYXBoID0gKHRpbWVzdGFtcCkgPT4ge1xuICAgICAgICBpZighZ3JhcGhEYXRhLnN0YXJ0KSBncmFwaERhdGEuc3RhcnQgPSB0aW1lc3RhbXBcbiAgICAgICAgbGV0IHJ1bnRpbWUgPSB0aW1lc3RhbXAgLSBncmFwaERhdGEuc3RhcnRcbiAgICAgICAgbGV0IHByb2dyZXNzID0gTWF0aC5taW4ocnVudGltZSAvIGdyYXBoRGF0YS50b3RhbCwgMSlcblxuICAgICAgICBfKCdncmFwaC1wZXJjZW50YWdlLXRvcCcpLnRleHRDb250ZW50ID0gTWF0aC5yb3VuZCggMCArIDkwICogcHJvZ3Jlc3MpICsgJyAlJ1xuICAgICAgICBfKCdncmFwaC1wZXJjZW50YWdlLWJvdHRvbScpLnRleHRDb250ZW50ID0gTWF0aC5yb3VuZCggMCArIDcwICogcHJvZ3Jlc3MpICsgJyAlJ1xuICAgICAgICBfKCdncmFwaC1yZWN0Jykuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgKDQxMiAqIHByb2dyZXNzKSArICdweCknIFxuICAgICAgICBkcmF3UGVyY2VudFN0cm9rZShwcm9ncmVzcylcbiAgICAgICAgXG4gICAgICAgIGlmKHByb2dyZXNzIDwgMSkgXG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZUdyYXBoKVxuICAgICAgICBlbHNlIFxuICAgICAgICAgICAgcmV0dXJuIHN1YnRyYWN0UmF5KClcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydEFuaW1hdGVHcmFwaCA9ICgpID0+e1xuICAgICAgICByZWNDbGlwLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMHB4LCAwcHgpJ1xuICAgICAgICBfKCdncmFwaC1jbGlwcGluZycpLmNsYXNzTGlzdC5hZGQoJ3Nob3ctZ3JhcGhzJylcblxuICAgICAgICAvL0FuaW1hdGUgZ3JhcGhzIGFmdGVyIHJlY0NsaXAgdHJhbnNmb3JtIGlzIGRvbmVcbiAgICAgICAgc2V0VGltZW91dCggKCkgPT4ge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGVHcmFwaClcbiAgICAgICAgfSwgMjUwMClcbiAgICAgICBcbiAgICB9XG5cbiAgICBjb25zdCBiZWdpbiA9IHtcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIHRvdGFsOiA0MDAwXG4gICAgfVxuXG4gICAgY29uc3QgZmx5SW4gPSAodGltZXN0YW1wKSA9PntcbiAgICAgICAgaWYoIWJlZ2luLnN0YXJ0KSBiZWdpbi5zdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICBiZWdpbi5ydW50aW1lID0gdGltZXN0YW1wIC0gYmVnaW4uc3RhcnRcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1pbihiZWdpbi5ydW50aW1lIC8gYmVnaW4udG90YWwsIDEpXG4gICAgICAgIGNvbnN0IGN1cnZlID0gNjI0LjkgLyAyXG4gICAgICAgIGNvbnN0IGVhc2UgPSBlYXNlT3V0KHByb2dyZXNzKVxuICAgICAgICBjb25zdCBpbmNyZW1lbnQgPSBjdXJ2ZSAqIHByb2dyZXNzIC8gNTBcbiAgICBcbiAgICAgICAgY29uc3QgeSA9IC1mbHlJbnRvUGxhY2UuYmVnaW5ZICsgZmx5SW50b1BsYWNlLmJlZ2luWSAqIHByb2dyZXNzXG4gICAgICAgIGNvbnN0IHggPSAtTWF0aC5jb3MoIGluY3JlbWVudCArIE1hdGguUEkvMTgwKSAqIGN1cnZlICsgY3VydmUgXG4gICAgICAgIC8vICFiZWdpbi50b2dnbGVcbiAgICAgICAgIF8oJ2Zsb2F0aW5nX3JvYm90Jykuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgkey14fXB4LCAke3l9cHgpYFxuICAgICAgICAvLyA6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNzZWN0aW9uLWZpdmUtd2ViIC5jb250YWluZXItbGcnKS5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHsxLjMgLSAuMyAqIGVhc2V9KWBcblxuICAgICAgICBpZihwcm9ncmVzcyA9PT0gMSl7XG4gICAgICAgICAgICAvLyB0b2dnbGVSb2JvdC50b2dnbGUgPSB0cnVlO1xuICAgICAgICAgICAgdG9nZ2xlUm9ib3QuZGlyZWN0aW9uID0gJ2Rvd24nXG4gICAgICAgIFxuICAgICAgICAgICAgLy9SZXNpemVzIHRoZSB3aG9sZSBjb250YWluZXIgc28gcm9ib3QgZml0cyBpbnRvIHNjcmVlblxuICAgICAgICAgICAgaWYoIHdXID4gMTA1MCApe1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoc3RhcnRBbmltYXRlR3JhcGgsIDYwMClcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjc2VjdGlvbi1maXZlLXdlYiAuY29udGFpbmVyLWxnJykuY2xhc3NMaXN0LmFkZCgnc2NhbGUtY29udGFpbmVyJylcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHN0YXJ0QW5pbWF0ZUdyYXBoKClcbiAgICAgICAgICAgIH0gXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZmx5SW4pXG4gICAgfVxuICAgIHJldHVybiB7Zmx5SW4sIGZseUludG9QbGFjZSwgZHJhd0J1cm5lcnN9XG59XG5cbmxldCBuYXZUb2dnbGUgPSB7XG4gICAgdG9nZ2xlOiB0cnVlXG59XG5cbmNsYXNzIE5hdmlnYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMubmF2SXRlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcubmF2LWxpc3QgYnV0dG9uJylcbiAgICAgICAgdGhpcy5zY3JvbGxUbyA9IHRoaXMuc2Nyb2xsVG8uYmluZCh0aGlzKVxuICAgICAgICB0aGlzLmFuaW1hdGVTY3JvbGwgPSB0aGlzLmFuaW1hdGVTY3JvbGwuYmluZCh0aGlzKVxuICAgICAgICB0aGlzLnN0YXJ0ID0gMFxuICAgIH1cbiAgICBnZXREaXN0YW5jZShlbCl7XG4gICAgIFxuICAgICAgICBsZXQgdG9wID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wXG4gICAgICAgIGxldCBoZWlnaHQgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHRcbiAgICAgICAgbGV0IGJvdHRvbSA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbVxuICAgICAgICByZXR1cm4ge3RvcCwgaGVpZ2h0LCBib3R0b219XG4gICAgfVxuICAgIGdldFNjcm9sbHRvRWxlbWVudCh0YXJnZXQsIHJlZ0V4KXtcbiAgICAgICAgbGV0IHNlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2VjdGlvbicpXG4gICAgICAgIGxldCBsZW5ndGggPSBzZWN0aW9uLmxlbmd0aFxuICAgICAgICB3aGlsZShsZW5ndGgtLSl7XG4gICAgICAgICAgICBpZiAoIHRhcmdldCA9PT0gc2VjdGlvbltsZW5ndGhdLmlkLnJlcGxhY2UocmVnRXgsIFwiJDFcIikgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IHNlY3Rpb25bbGVuZ3RoXSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGxlbmd0aFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBvdXRFeHBvKG4pe1xuICAgICAgICByZXR1cm4gMSA9PSBuID8gbiA6IDEgLSBNYXRoLnBvdygyLCAtMTAgKiBuKTtcbiAgICB9O1xuXG4gICAgYW5pbWF0ZVNjcm9sbCh0aW1lc3RhbXApe1xuICAgICAgICBpZighdGhpcy5zdGFydCkgdGhpcy5zdGFydCA9IHRpbWVzdGFtcFxuICAgICAgICBsZXQgcnVudGltZSA9ICB0aW1lc3RhbXAgLSB0aGlzLnN0YXJ0XG4gICAgICAgIGxldCBwcm9ncmVzcyA9IHRoaXMub3V0RXhwbyggTWF0aC5taW4oIHJ1bnRpbWUgLyAxMDAwLCAxICkgKVxuICAgICAgICBsZXQgeSA9IHRoaXMuc3RhcnRQb3MgKyAodGhpcy5lbERpc3QgKiBwcm9ncmVzcylcbiAgICAgICBcbiAgICAgICAgd2luZG93LnNjcm9sbCgwLCB5KVxuICAgICAgICBpZihwcm9ncmVzcyA8IDEpe1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0ZVNjcm9sbClcbiAgICAgICAgfWVsc2UgcmV0dXJuIG5hdlRvZ2dsZS50b2dnbGUgPSB0cnVlXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgIH1cblxuICAgIHRvZ2dsZU9wZW5CdG4oKXtcbiAgICAgICAgbGV0IGkgPSB0aGlzLm5hdkl0ZW1zLmxlbmd0aFxuICAgICAgICB3aGlsZShpLS0pe1xuICAgICAgICAgIFxuICAgICAgICAgICAgaWYodGhpcy5uYXZJdGVtc1tpXS5zdHlsZS50cmFuc2Zvcm0pe1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMubmF2SXRlbXNbaV0ucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHNjcm9sbFRvKGUpe1xuICAgICAgICB0aGlzLnRvZ2dsZU9wZW5CdG4oKVxuICAgICAgICBpZihlLnRhcmdldC5jbGFzc05hbWUgPT09ICdjb250YWN0LW1vZGFsJykgcmV0dXJuXG4gICAgICAgIGNvbnN0IHJlZ0V4ID0gLyhcXHcrXFwtXFx3KylcXC1cXHcrL2lnXG4gICAgICAgIGNvbnN0IHNlY3Rpb25JZCA9IGUudGFyZ2V0LmNsYXNzTmFtZS5yZXBsYWNlKHJlZ0V4LFwiJDFcIilcblxuICAgICAgICBsZXQgc2Nyb2xsVG9FbGVtID0gdGhpcy5nZXRTY3JvbGx0b0VsZW1lbnQoc2VjdGlvbklkLHJlZ0V4KS5lbFxuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmdldFNjcm9sbHRvRWxlbWVudChzZWN0aW9uSWQscmVnRXgpLmluZGV4XG4gICAgICAgIGxldCBlbERpc3QgPSB0aGlzLmdldERpc3RhbmNlKHNjcm9sbFRvRWxlbSwgaW5kZXgpLnRvcFxuICAgICAgICB0aGlzLmVsRGlzdCA9IGVsRGlzdFxuICAgICAgICB0aGlzLnN0YXJ0UG9zID0gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgICAgIHRoaXMuc3RhcnQgPSAwXG4gICAgICAgIFxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRlU2Nyb2xsKVxuICAgIH1cbiAgICBzY3JvbGxUbzc2OChlKXtcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBsZXQgdGFyZ2V0QnRuID0gZS50YXJnZXQucGFyZW50Tm9kZS5wYXJlbnROb2RlXG4gICAgICAgIGNvbnNvbGUubG9nKHRhcmdldEJ0bilcbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZih0YXJnZXRCdG4uaGFzQXR0cmlidXRlKCdzdHlsZScpKXtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvZ2dsZU9wZW5CdG4oKVxuICAgICAgICB9IFxuICAgICAgICB0aGlzLnRvZ2dsZU9wZW5CdG4oKVxuICAgICAgICB0YXJnZXRCdG4uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdhdXRvJ1xuICAgICAgICB0YXJnZXRCdG4uc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZVgoJHstMTMwfXB4KWBcbiAgIFxuICAgIH1cblxuICAgIGNvbnRyb2xsZXIoKXtcbiAgICAgICAgXygnbmF2LWxpc3QnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlLnRhcmdldClcbiAgICAgICAgICAgIG5hdlRvZ2dsZS50b2dnbGUgPSBmYWxzZVxuICAgICAgICAgICAgaWYoIGUudGFyZ2V0Lm5vZGVOYW1lID09PSBcIkJVVFRPTlwiKXtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG8oZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgQCBzY3JlZW4gc2l6ZSA3NjggYW5kIHNtYWxsZXJcbiAgICAgICAgICAgIGlmKGUudGFyZ2V0LnBhcmVudE5vZGUuY2xhc3NMaXN0WzFdID09PSAnbmF2LWljb24nKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbFRvNzY4KGUpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNvbnN0IG5hdmlnYXRpb24gPSBuZXcgTmF2aWdhdGlvbigpXG5uYXZpZ2F0aW9uLmNvbnRyb2xsZXIoKVxuXG5jb25zdCB0b2dnbGVBbmltYXRlID0ge1xuICAgIHN0YXJzOiB0cnVlLFxuICAgIGZsaWdodFN0YXJzOiB0cnVlLFxuICAgIGNpcmN1aXQ6IHRydWVcbn1cbi8vIGNpcmN1aXRUb2dnbGUudG9nZ2xlQW5pbSA9IGZhbHNlXG5jb25zdCByb2JvdCA9IG5ldyByb2JvdFNlY3Rpb24oJ2V2ZW50Jyk7XG5jb25zdCByb2JvdEZsaWdodCA9IHN0YXJ0Um9ib3RGbGlnaHQoKTtcblxuXG5jb25zdCB0cmlnZ2VyU3RhcnMgPSAoZSkgPT4ge1xuICAgIGNvbnNvbGUubG9nKGUudHlwZSlcbiAgICB2YXIgdXBkYXRlID0gcm9ib3RbMV0oZSkudXBkYXRlXG4gICAgdmFyIHN0YXJfY291bnQgPSAyNVxuICAgIHZhciBtYWtlU3RhcnMgPSByb2JvdFsxXSgpXG4gICAgbWFrZVN0YXJzLmNyZWF0ZVN0YXJzKHN0YXJfY291bnQsIHVwZGF0ZSlcbn1cblxuY2xhc3MgU2Nyb2xsQW5pbWF0ZSBleHRlbmRzIE5hdmlnYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHN1cGVyKClcbiAgICAgICAgdGhpcy5zZWN0aW9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zZWN0aW9uLXRocmVlLXJvYm90LCAjc2VjdGlvbi1maXZlLXdlYiwgI3NlY3Rpb24tb25lLWRpZ2l0YWwsICNzZWN0aW9uLXR3by1wb3B1cHMnKVxuICAgIH1cbiAgICBjaGVja0VsZW1Ub3AoZSl7XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLnNlY3Rpb25zLmxlbmd0aFxuICAgICAgIFxuICAgICAgICB3aGlsZShsZW5ndGgtLSl7XG4gICAgICAgICAgICBsZXQgZGlzdCA9IHRoaXMuZ2V0RGlzdGFuY2UodGhpcy5zZWN0aW9uc1tsZW5ndGhdKVxuICAgICAgICAgICAgbGV0IGVsbVRvcCA9IGRpc3QudG9wXG4gICAgICAgICAgICBsZXQgZWxtSGVpZ2h0ID0gZGlzdC5oZWlnaHRcbiAgICAgICAgICAgIGxldCBlbG1Cb3R0b20gPSBkaXN0LmJvdHRvbVxuXG4gICAgICAgICAgICAvL0RpZ2l0YWwgSGFuZFxuICAgICAgICAgICAgaWYobGVuZ3RoID09PSAwKXtcblxuICAgICAgICAgICAgICAgIGlmKGVsbUJvdHRvbSA8IDEwMCl0b2dnbGVBbmltYXRlLmNpcmN1aXQgPSBmYWxzZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy9NYXBcbiAgICAgICAgICAgIGlmKGxlbmd0aCA9PT0gMSl7XG4gICAgICAgICAgICAgICBjb25zdCBwb2ludGVyTG9jYXRpb24gPSBfKCdvdmFsLXBvaW50ZXInKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS54XG5cbiAgICAgICAgICAgICAgIC8vU3RvcHMgc2Nyb2xsIGZyb20gcnVubmluZyBob3Zlcm1hcCBmdW5jdGlvbiBvdmVyIGFuZCBvdmVyXG4gICAgICAgICAgICAgICBpZihwb2ludGVyTG9jYXRpb24gPiAwKXtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG92ZXJtYXAgPSBob3Zlck1hcCgpXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBob3Zlcm1hcFsxXShlKVswXTsgLy8gUG9zaXRpb24gZGlzdGFuY2Ugb2Ygc2hvdy1pY29uIGdvb2V5XG4gICAgICAgICAgICAgICAgICAgIGhvdmVybWFwWzBdKCBkaXN0LCB0cnVlICkgIC8vIGhhbmRsZXIoZSkgZnVuY3Rpb24gcmVtb3ZlIGdvb2V5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUm9ib3QgRGVzaWduIHN0YXJzIGVsZW1lbnRcbiAgICAgICAgICAgIGlmKGxlbmd0aCA9PT0gMikge1xuICBcbiAgICAgICAgICAgICAgICAvL1BhZ2UgaW4gdmlldyBzdGFydCBhbmltYXRlIHN0YXJzXG4gICAgICAgICAgICAgICAgaWYoZWxtVG9wIDw9IGVsbUhlaWdodCAmJiBlbG1Cb3R0b20gPj0gZWxtSGVpZ2h0ICYmIHRvZ2dsZUFuaW1hdGUuc3RhcnMpe1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQW5pbWF0ZS5zdGFycyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZVN0YXJzLnRvZ2dsZSA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyaWdnZXJTdGFycyhlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvL1BhZ2Ugb3V0IG9mIHZpZXcgc3RhcnQgc3RvcCBhbmltYXRlXG4gICAgICAgICAgICAgICAgaWYoICF0b2dnbGVBbmltYXRlLnN0YXJzICAmJiAgKGVsbVRvcCA+IGVsbUhlaWdodCB8fCBlbG1Cb3R0b20gPD0gMCkgKXtcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlQW5pbWF0ZS5zdGFycyA9IHRydWVcbiAgICAgICAgICAgICAgICAgICAgdG9nZ2xlU3RhcnMudG9nZ2xlID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vRmx5aW5nIFJvYm90IC8gR3JhcGggZWxlbWVudFxuICAgICAgICAgICAgaWYobGVuZ3RoID09PSAzKXtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZihlbG1Ub3AgPCBlbG1IZWlnaHQgLyAyICYmIGVsbUJvdHRvbSA+PSBlbG1IZWlnaHQgJiYgdG9nZ2xlQW5pbWF0ZS5mbGlnaHRTdGFycyl7XG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZVJvYm90LmZsaWdodCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZUFuaW1hdGUuZmxpZ2h0U3RhcnMgPSBmYWxzZVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHJvYm90RmxpZ2h0LmRyYXdCdXJuZXJzIClcbiAgICAgICAgICAgICAgICAgICAgcm9ib3RGbGlnaHQuZmx5SW50b1BsYWNlLmNyZWF0ZVN0YXJzKCd1cCcpXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShyb2JvdEZsaWdodC5mbHlJbilcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiggIXRvZ2dsZUFuaW1hdGUuZmxpZ2h0U3RhcnMgICYmICAoZWxtVG9wID4gZWxtSGVpZ2h0IC0gNzUgfHwgZWxtQm90dG9tIDw9IDApICl7XG5cbiAgICAgICAgICAgICAgICAgICAgLy9SZW1vdmVzIHJheVxuICAgICAgICAgICAgICAgICAgICBfKCdyZWMtY2xpcCcpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgICB0b2dnbGVBbmltYXRlLmZsaWdodFN0YXJzID0gdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB0b2dnbGVSb2JvdC5mbGlnaHQgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBcbiAgICAgICAgfVxuICAgIH1cblxuICAgXG4gICAgc2Nyb2xsKCl7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCAoZSkgPT4ge1xuICAgICAgICAgICAgLy8gSWYgbmF2IGl0ZW0gaXMgY2xpY2tlZCB0aGF0IHNjcm9sbCBldmVudCB3aWxsIHJ1biBhbmQgbm90IHRyaWdnZXIgdGhpcyBzY3JvbGwgZXZlbnRcbiAgICAgICAgICAgIGlmKG5hdlRvZ2dsZS50b2dnbGUpe1xuXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0VsZW1Ub3AoZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgXG4gICAgICAgIH0pXG4gICAgfVxufVxuY29uc3Qgc2Nyb2xsQW5pbWF0ZSA9IG5ldyBTY3JvbGxBbmltYXRlKClcbnNjcm9sbEFuaW1hdGUuc2Nyb2xsKClcblxuLy8qKiogSEFORCBTSEFLRSAqKipcbmNsYXNzIERpZ2l0YWwge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMucGF0aCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5zdHJva2UnKVxuICAgICAgICB0aGlzLndhdGNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3JvdGF0ZV93YXRjaCcpXG4gICAgfVxuXG4gICAgc3RhcnRIYW5kQW5pbWF0aW9uKCl7XG4gICAgICAgIGNvbnNvbGUubG9nKCdoZXknKVxuICAgICAgICB0aGlzLndhdGNoLmNsYXNzTGlzdC5hZGQoJ3JvdGF0ZVdhdGNoJylcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgdGhpcy5wYXRoW2ldLmNsYXNzTGlzdC5hZGQoJ3BhdGgnKVxuICAgICAgICB9XG4gICAgICAgIC8vUmVtb3ZlcyBhbmltYXRpb24gYWZ0ZXIgNCBpbnRlcnZhbHMgXG4gICAgICAgIHNldFRpbWVvdXQoICgpPT4geyB0aGlzLnJlbW92ZURpZ2l0YWxBbmltYXRpb24oKX0sODEwMClcbiAgICB9XG4gICAgcmVtb3ZlRGlnaXRhbEFuaW1hdGlvbigpe1xuICAgICAgICB0aGlzLndhdGNoLmNsYXNzTGlzdC5yZW1vdmUoJ3JvdGF0ZVdhdGNoJylcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICB0aGlzLnBhdGhbaV0uY2xhc3NMaXN0LnJlbW92ZSgncGF0aCcpXG4gICAgICAgIH0gXG4gICAgfVxufVxuXG5jb25zdCBjaXJjdWl0VG9nZ2xlID0ge1xuICAgIHRvZ2dsZUFuaW06IHRydWVcbn1cblxuY2xhc3MgQ2lyY3VpdCB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5hbmltQ2lyY3VpdCA9IF8oJ2FuaW1hdGUtY2lyY3VpdCcpXG4gICAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24gPSB0aGlzLnN0YXJ0QW5pbWF0aW9uLmJpbmQodGhpcylcbiAgICAgICAgdGhpcy5zcGVlZCA9IFtdXG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBbXVxuICAgICAgICB0aGlzLmluZGV4ID0gW11cbiAgICAgICAgdGhpcy5wYXRoTGVuZ3RoID0gW11cbiAgICB9XG4gICAgZ2V0RGFzaFN0cm9rZShlbCl7XG4gICBcbiAgICAgICAgbGV0IGxlbmd0aCA9IGVsLmxlbmd0aFxuICAgICAgICB3aGlsZShsZW5ndGgtLSl7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSBlbFtsZW5ndGhdXG4gICAgICAgICAgICB0aGlzLnBhdGhMZW5ndGgudW5zaGlmdChfKCdhbmltYXRlLWNpcmN1aXQnKVtpbmRleF0uZ2V0VG90YWxMZW5ndGgoKSApXG4gICAgICAgIH1cblxuICAgIH1cbiAgICBnZXRSYW5kb21QYXRoKGNvdW50KXtcbiAgICAgICAgbGV0IGkgPSAwXG4gICAgICAgIGxldCBsZW5ndGggPSBjb3VudCBcbiAgICAgICAgXG4gICAgICAgIHdoaWxlKGkgPCBsZW5ndGgpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQgaXRlbSA9IE1hdGguZmxvb3IoIE1hdGgucmFuZG9tKCkgKiAxMCApXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vQ2hlY2tzIGZpcnN0IHRvIG1ha2Ugc3VyZSBzYW1lIGluZGV4IGlzIG5vdCBpbiBhcnJheVxuICAgICAgICAgICAgbGV0IG5vdEluQXJyYXkgPSB0aGlzLmluZGV4LmluZGV4T2YoaXRlbSkgPT09IC0xXG4gICAgICAgICAgIFxuICAgICAgICAgICAgaWYobm90SW5BcnJheSl7XG4gICAgICAgICAgICAgICAgaSsrXG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKCBpdGVtIClcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzLnB1c2goIF8oJ2FuaW1hdGUtY2lyY3VpdCcpW2l0ZW1dIClcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vVXBkYXRlcyBuZXcgcmFuZG9tIGVsZW1lbnRzIGFuZCByZXR1cm5zIHRoZW1cbiAgICAgICAgdGhpcy5hbmltQ2lyY3VpdCA9IHRoaXMuZWxlbWVudHNcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhcbiAgICAgIFxuICAgIH1cbiAgICBhZGREYXRhKGluZGV4KXtcbiBcbiAgICAgICAgdGhpcy5zcGVlZC5wdXNoKHtzcGVlZDogMCwgajogMCwgZGVsYXk6IDI1ICogaW5kZXh9KVxuICAgIH1cbiAgICBzZXREYXNoQXJyYXkoY291bnQpe1xuICAgICAgICBsZXQgYWxsRWxlbWVudHMgPSBfKCdhbmltYXRlLWNpcmN1aXQnKS5sZW5ndGggXG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuZ2V0UmFuZG9tUGF0aChjb3VudClcbiAgICAgICAgbGV0IGkgPSBjb3VudFxuICAgICAgICB0aGlzLmdldERhc2hTdHJva2UoaW5kZXgpXG4gICAgICAgICAgICAgICAgXG4gICAgICAgIHdoaWxlKGktLSl7XG4gICBcbiAgICAgICAgICAgIHRoaXMuYW5pbUNpcmN1aXRbaV0uc3R5bGUuc3Ryb2tlID0gJ29yYW5nZSdcbiAgICAgICAgICAgIHRoaXMuYW5pbUNpcmN1aXRbaV0uc3R5bGUuc3Ryb2tlRGFzaG9mZnNldCA9IC10aGlzLnBhdGhMZW5ndGhbaV0gXG4gICAgICAgICAgICB0aGlzLmFuaW1DaXJjdWl0W2ldLnN0eWxlLnN0cm9rZURhc2hhcnJheSA9IHRoaXMucGF0aExlbmd0aFtpXSBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhpcy5hZGREYXRhKGNvdW50KVxuICAgICAgICAgICAgXG4gICAgICAgICAgIGlmKGkgPT09IDApIHRoaXMuc3RhcnRBbmltYXRpb24oKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhcnRBbmltYXRpb24oKXtcbiAgICAgICAgbGV0IGRpc3QgPSB0aGlzLnBhdGhMZW5ndGhcbiAgICAgICAgbGV0IGVsID0gdGhpcy5hbmltQ2lyY3VpdFxuICAgICAgICBsZXQgZHVyYXRpb24gPSB0aGlzLnNwZWVkXG4gICAgICAgIGxldCBsZW5ndGggPSBlbC5sZW5ndGhcbiAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gZHJhdygpe1xuICAgICAgICAgICAgLy9SZW1vdmVzIEFuaW1hdGlvblxuICAgICAgICAgICAgaWYoIXRvZ2dsZUFuaW1hdGUuY2lyY3VpdCl7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSBlbC5sZW5ndGhcblxuICAgICAgICAgICAgICAgIHdoaWxlKGktLSl7XG4gICAgICAgICAgICAgICAgICAgIGVsW2ldLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBkYXNoQXJyYXkgPSBlbFtpXS5zdHlsZS5zdHJva2VEYXNoYXJyYXlcbiAgICAgICAgICAgICAgICBsZXQgZGFzaE9mZnNldCA9IGVsW2ldLnN0eWxlLnN0cm9rZURhc2hvZmZzZXRcbiAgICAgICAgICAgICAgICAvLyBTdHJva2VEYXNob2Zmc2V0IGlzIGxlc3MgdGhlbiAwIHJ1bnMgc2FtZSBkaXJlY3Rpb24gXG4gICAgICAgICAgICAgICAgaWYoZGFzaE9mZnNldCA+PSAwICYmICFkdXJhdGlvbltpXS5qKXtcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25baV0uc3BlZWQgPSAwXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uW2ldLmogPSAxXG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdG9yID0gMFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBzcGVlZCA9IGR1cmF0aW9uW2ldLnNwZWVkICs9NFxuICAgICAgICAgICAgICAgIGxldCBpdGVyYXRvciA9IGRhc2hPZmZzZXQgPD0gMCA/IC1kaXN0W2ldIDogMFxuXG4gICAgICAgICAgICAgICAgLy9TdG9wcyBzdHJva2VkYXNoYXJyYXkgYXQgYWJvdXQgYSAzcmQgdG8ga2VlcCB0aGUgbGVuZ3RoIHRoYXQgc2l6ZVxuICAgICAgICAgICAgICAgIGlmKGRhc2hBcnJheSA+PSAoZGlzdFtpXSAvIDEuOCkgKXtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGRhc2hBcnJheSA9IGRpc3RbaV0gLSBzcGVlZFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGVsW2ldLnN0eWxlLnN0cm9rZURhc2hvZmZzZXQgPSBpdGVyYXRvciArIHNwZWVkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhdylcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZHJhdy5iaW5kKHRoaXMpKVxuICAgIH1cbn1cblxuY29uc3QgZGlnaXRhbCA9IG5ldyBEaWdpdGFsKClcbmNvbnN0IGNpcmN1aXQgPSBuZXcgQ2lyY3VpdCgpXG5cbiAgICBjaXJjdWl0VG9nZ2xlLnRvZ2dsZUFuaW0gPSBmYWxzZVxuXG53aW5kb3cub25sb2FkID0gZnVuY3Rpb24oZSl7XG4gICAgY2lyY3VpdC5zZXREYXNoQXJyYXkoNilcbiAgICAvLyBkaWdpdGFsLnN0YXJ0SGFuZEFuaW1hdGlvbigpXG4gICAgIC8vIGNvbnNvbGUubG9nKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZXN0LWxpbmUnKS5nZXRUb3RhbExlbmd0aCgpKTtcbiBcbiAgICBsZXQgbmV3VGVjaG5vbG9naWVzID0gbmV3IFRlY2hub2xvZ2llcygpO1xuICAgIG5ld1RlY2hub2xvZ2llcy5sb2FkSW1hZ2VzKCk7XG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudGVjaG5vbG9naWVzIC5zdGFydC1jYW52YXMnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCl7XG4gICAgICAgIFRlY2hub2xvZ2llcy5wcm90b3R5cGUudG9nZ2xlID0gdHJ1ZVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobmV3VGVjaG5vbG9naWVzLmRyYXcuYmluZChuZXdUZWNobm9sb2dpZXMpKSBcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRlY2hub2xvZ2llcyAuc3RvcC1jYW52YXMnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCl7XG4gICAgICAgIFRlY2hub2xvZ2llcy5wcm90b3R5cGUudG9nZ2xlID0gZmFsc2VcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKG5ld1RlY2hub2xvZ2llcy5kcmF3LmJpbmQobmV3VGVjaG5vbG9naWVzKSkgXG4gICAgfS5iaW5kKHRoaXMpKTtcblxuICAgIHZhciBzdGFycnlOaWdodCA9IG5ldyBTdGFycnlOaWdodCgpXG4gICAgc3RhcnJ5TmlnaHQubG9hZEltYWdlcygpXG5cbiAgICBob3Zlck1hcCgpXG4gICAgXG4gICAgdmFyIGRlc2lnblNsaWRlciA9IG5ldyBEZXNpZ25TbGlkZXIoKTtcbiAgICBkZXNpZ25TbGlkZXIoKTtcblxuICAgIHJvYm90WzFdKCkgLy91cGRhdGVzIHJvYm90IGxvY2F0aW9uXG4gICAgcm9ib3RbMF0ubG9hZEltYWdlcygpOyAvL3RoZW4gbG9hZGVzIGltYWdlcyBpbnRvIHNsaWRlclxuXG4gICAgcm9ib3RGbGlnaHQuZmx5SW50b1BsYWNlLmhpZGVSb2JvdCgxLjMpOyAvL0hpZGVzIGZseWluZyByb2JvdCBvdXQgb2Ygc2NyZWVuIHZpZXdcbiAgICBcbiAgICBcbn0uYmluZCh0aGlzKTtcblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBSUE7QUFDQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFDQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFoQkE7QUFrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBZEE7QUFnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQXJCQTtBQXVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFiQTtBQWVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFDQTtBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTVCQTtBQUNBO0FBOEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFmQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUlBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFUQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFBQTtBQUFBO0FBQ0E7QUFEQTtBQUtBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFWQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUFBO0FBQUE7QUFDQTtBQURBO0FBR0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBVkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUF2QkE7QUF5QkE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUF2SEE7QUFDQTtBQXlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUJBO0FBZ0NBO0FBQ0E7QUFDQTs7Ozs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFkQTtBQWVBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQXBaQTtBQUNBO0FBc1pBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYkE7QUFjQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQTdNQTtBQUNBO0FBK01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBREE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFNQTtBQUFBO0FBTkE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakRBO0FBQUE7QUFBQTtBQUNBO0FBa0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBekNBO0FBQ0E7QUEyQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUNBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBOzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBTEE7QUFPQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUFBO0FBQ0E7QUFEQTtBQUNBO0FBQ0E7QUFGQTtBQUdBO0FBQ0E7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOzs7O0FBOUVBO0FBQ0E7QUErRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQUdBO0FBQ0E7QUFEQTtBQUNBO0FBR0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ })

/******/ });